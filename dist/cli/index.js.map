{"version":3,"sources":["../../src/driver/health.ts","../../src/driver/query-tracker.ts","../../src/driver/retry.ts","../../src/driver/mongodb.ts","../../src/driver/mysql.ts","../../src/driver/sqlite.ts","../../src/cli/index.ts","../../src/driver/postgresql.ts","../../src/driver/index.ts","../../src/migrations/dialects/mysql.ts","../../src/migrations/dialects/postgresql.ts","../../src/migrations/dialects/sqlite.ts","../../src/migrations/dialects/index.ts","../../src/migrations/runner.ts","../../src/modules/collector.ts","../../src/modules/registry.ts","../../src/remote/auth.ts","../../src/schema/types.ts","../../src/remote/client.ts","../../src/schema/registry.ts","../../src/schema/introspect.ts","../../src/schema/diff.ts","../../src/schema/sync.ts","../../src/schema/sync-metadata.ts","../../src/types/generator.ts","../../src/types/hooks-generator.ts"],"sourcesContent":["export interface PoolStats {\n  totalConnections: number;\n  activeConnections: number;\n  idleConnections: number;\n  waitingRequests: number;\n  maxConnections: number;\n}\n\nexport interface HealthCheckResult {\n  healthy: boolean;\n  latencyMs: number;\n  lastCheckedAt: Date;\n  error?: string;\n}\n\nexport interface HealthCheckConfig {\n  enabled?: boolean;\n  intervalMs?: number;\n  timeoutMs?: number;\n  onHealthChange?: (healthy: boolean, result: HealthCheckResult) => void;\n}\n\nexport function createHealthCheckResult(\n  healthy: boolean,\n  latencyMs: number,\n  error?: string\n): HealthCheckResult {\n  return {\n    healthy,\n    latencyMs,\n    lastCheckedAt: new Date(),\n    ...(error && { error }),\n  };\n}\n\nexport function getDefaultHealthCheckConfig(\n  overrides?: Partial<HealthCheckConfig>\n): HealthCheckConfig {\n  return {\n    enabled: overrides?.enabled ?? false,\n    intervalMs: overrides?.intervalMs ?? 30000,\n    timeoutMs: overrides?.timeoutMs ?? 5000,\n    onHealthChange: overrides?.onHealthChange,\n  };\n}\n","export interface QueryInfo {\n  id: string;\n  query: string;\n  startedAt: Date;\n  backendPid?: number;\n}\n\nexport class QueryTracker {\n  private activeQueries = new Map<string, QueryInfo>();\n  private completedCount = 0;\n  private cancelledCount = 0;\n  private draining = false;\n  private drainResolve: (() => void) | null = null;\n\n  trackQuery(id: string, query: string, backendPid?: number): void {\n    if (this.draining) {\n      throw new Error('Driver is draining - new queries are not accepted');\n    }\n    this.activeQueries.set(id, {\n      id,\n      query: query.slice(0, 200),\n      startedAt: new Date(),\n      backendPid,\n    });\n  }\n\n  untrackQuery(id: string): void {\n    if (this.activeQueries.delete(id)) {\n      this.completedCount++;\n      if (this.draining && this.activeQueries.size === 0 && this.drainResolve) {\n        this.drainResolve();\n      }\n    }\n  }\n\n  getActiveCount(): number {\n    return this.activeQueries.size;\n  }\n\n  getActiveQueries(): QueryInfo[] {\n    return Array.from(this.activeQueries.values());\n  }\n\n  async startDrain(timeoutMs: number): Promise<{ timedOut: boolean }> {\n    this.draining = true;\n\n    if (this.activeQueries.size === 0) {\n      return { timedOut: false };\n    }\n\n    const drainPromise = new Promise<void>((resolve) => {\n      this.drainResolve = resolve;\n    });\n\n    const timeoutPromise = new Promise<'timeout'>((resolve) => {\n      setTimeout(() => resolve('timeout'), timeoutMs);\n    });\n\n    const result = await Promise.race([\n      drainPromise.then(() => 'drained' as const),\n      timeoutPromise,\n    ]);\n\n    return { timedOut: result === 'timeout' };\n  }\n\n  markCancelled(id: string): void {\n    if (this.activeQueries.delete(id)) {\n      this.cancelledCount++;\n      if (this.draining && this.activeQueries.size === 0 && this.drainResolve) {\n        this.drainResolve();\n      }\n    }\n  }\n\n  getStats(): { completed: number; cancelled: number; active: number } {\n    return {\n      completed: this.completedCount,\n      cancelled: this.cancelledCount,\n      active: this.activeQueries.size,\n    };\n  }\n\n  isDraining(): boolean {\n    return this.draining;\n  }\n\n  reset(): void {\n    this.activeQueries.clear();\n    this.completedCount = 0;\n    this.cancelledCount = 0;\n    this.draining = false;\n    this.drainResolve = null;\n  }\n}\n","export interface RetryConfig {\n  maxRetries?: number;\n  baseDelayMs?: number;\n  maxDelayMs?: number;\n  retryableErrors?: string[];\n}\n\nconst DEFAULT_RETRYABLE_ERRORS = [\n  'ECONNREFUSED',\n  'ETIMEDOUT',\n  'ECONNRESET',\n  'EPIPE',\n  'ENOTCONN',\n  '57P01',\n  '57P02',\n  '57P03',\n  'PROTOCOL_CONNECTION_LOST',\n  'ER_CON_COUNT_ERROR',\n];\n\nexport function isRetryableError(error: unknown, customErrors: string[] = []): boolean {\n  const allErrors = [...DEFAULT_RETRYABLE_ERRORS, ...customErrors];\n\n  if (error instanceof Error) {\n    const errorCode = (error as Error & { code?: string }).code;\n    const errorMessage = error.message;\n\n    return allErrors.some((code) => errorCode === code || errorMessage.includes(code));\n  }\n  return false;\n}\n\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  config: RetryConfig = {}\n): Promise<T> {\n  const maxRetries = config.maxRetries ?? 3;\n  const baseDelayMs = config.baseDelayMs ?? 100;\n  const maxDelayMs = config.maxDelayMs ?? 5000;\n  const retryableErrors = config.retryableErrors ?? [];\n\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === maxRetries || !isRetryableError(error, retryableErrors)) {\n        throw error;\n      }\n\n      const delay = Math.min(baseDelayMs * 2 ** attempt, maxDelayMs);\n      const jitter = Math.random() * delay * 0.1;\n\n      console.warn(\n        `[db-engine] Connection error (attempt ${attempt + 1}/${maxRetries + 1}), retrying in ${Math.round(delay)}ms:`,\n        lastError.message\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, delay + jitter));\n    }\n  }\n\n  throw lastError;\n}\n\nexport function createTimeoutPromise<T>(timeoutMs: number): Promise<T> {\n  return new Promise((_, reject) =>\n    setTimeout(() => reject(new Error('Health check timeout')), timeoutMs)\n  );\n}\n","import type { MongoOperation, QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport type {\n  DrainOptions,\n  DrainResult,\n  Driver,\n  DriverConfig,\n  TransactionClient,\n} from './types.js';\n\nlet mongodbModule: typeof import('mongodb') | null = null;\n\nasync function getMongoDBModule(): Promise<typeof import('mongodb')> {\n  if (!mongodbModule) {\n    try {\n      mongodbModule = await import('mongodb');\n    } catch {\n      throw new Error(\n        'MongoDB driver not found. Please install mongodb package: npm install mongodb'\n      );\n    }\n  }\n  return mongodbModule;\n}\n\nexport interface MongoDriverConfig extends DriverConfig {\n  database?: string;\n}\n\nexport interface MongoDriver extends Driver {\n  executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>>;\n  getDb(): unknown;\n  collection(name: string): unknown;\n}\n\nexport async function createMongoDriver(config: MongoDriverConfig): Promise<MongoDriver> {\n  const mongodb = await getMongoDBModule();\n  const { MongoClient } = mongodb;\n\n  const maxConnections = config.max ?? 10;\n\n  const client = new MongoClient(config.connectionString, {\n    maxPoolSize: maxConnections,\n    serverSelectionTimeoutMS: config.connectTimeout ?? 5000,\n    maxIdleTimeMS: config.idleTimeout ?? 30000,\n  });\n\n  await client.connect();\n  const db = client.db(config.database);\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `mongo-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      await db.command({ ping: 1 });\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  async function executeOperation<T = Record<string, unknown>>(\n    op: MongoOperation\n  ): Promise<QueryResult<T>> {\n    const queryId = generateQueryId();\n    tracker.trackQuery(queryId, `${op.type}:${op.collection}`);\n\n    try {\n      const collection = db.collection(op.collection);\n\n      switch (op.type) {\n        case 'find': {\n          let cursor = collection.find(op.filter ?? {});\n          if (op.options?.sort) cursor = cursor.sort(op.options.sort);\n          if (op.options?.skip) cursor = cursor.skip(op.options.skip);\n          if (op.options?.limit) cursor = cursor.limit(op.options.limit);\n          if (op.options?.projection) cursor = cursor.project(op.options.projection);\n          const rows = await cursor.toArray();\n          return { rows: rows as T[], rowCount: rows.length };\n        }\n\n        case 'aggregate': {\n          const result = await collection.aggregate(op.pipeline!).toArray();\n          return { rows: result as T[], rowCount: result.length };\n        }\n\n        case 'insertOne': {\n          const result = await collection.insertOne(op.document!);\n          const doc = { ...op.document, _id: result.insertedId } as T;\n          return { rows: [doc], rowCount: 1 };\n        }\n\n        case 'insertMany': {\n          const result = await collection.insertMany(op.documents!);\n          return { rows: op.documents as T[], rowCount: result.insertedCount };\n        }\n\n        case 'updateOne': {\n          const result = await collection.updateOne(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'updateMany': {\n          const result = await collection.updateMany(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'deleteOne': {\n          const result = await collection.deleteOne(op.filter!);\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'deleteMany': {\n          const result = await collection.deleteMany(op.filter!);\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'findOneAndUpdate': {\n          const result = await collection.findOneAndUpdate(op.filter!, op.update!, {\n            returnDocument: op.options?.returnDocument ?? 'after',\n            upsert: op.options?.upsert,\n            projection: op.options?.projection,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'findOneAndDelete': {\n          const result = await collection.findOneAndDelete(op.filter!, {\n            projection: op.options?.projection,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'countDocuments': {\n          const count = await collection.countDocuments(op.filter ?? {});\n          return { rows: [{ count } as T], rowCount: 1 };\n        }\n\n        default:\n          throw new Error(`Unsupported MongoDB operation: ${(op as MongoOperation).type}`);\n      }\n    } finally {\n      tracker.untrackQuery(queryId);\n    }\n  }\n\n  async function executeOperationWithSession<T = Record<string, unknown>>(\n    op: MongoOperation,\n    session: import('mongodb').ClientSession\n  ): Promise<QueryResult<T>> {\n    const queryId = generateQueryId();\n    tracker.trackQuery(queryId, `${op.type}:${op.collection}`);\n\n    try {\n      const collection = db.collection(op.collection);\n\n      switch (op.type) {\n        case 'find': {\n          let cursor = collection.find(op.filter ?? {}, { session });\n          if (op.options?.sort) cursor = cursor.sort(op.options.sort);\n          if (op.options?.skip) cursor = cursor.skip(op.options.skip);\n          if (op.options?.limit) cursor = cursor.limit(op.options.limit);\n          if (op.options?.projection) cursor = cursor.project(op.options.projection);\n          const rows = await cursor.toArray();\n          return { rows: rows as T[], rowCount: rows.length };\n        }\n\n        case 'aggregate': {\n          const result = await collection.aggregate(op.pipeline!, { session }).toArray();\n          return { rows: result as T[], rowCount: result.length };\n        }\n\n        case 'insertOne': {\n          const result = await collection.insertOne(op.document!, { session });\n          const doc = { ...op.document, _id: result.insertedId } as T;\n          return { rows: [doc], rowCount: 1 };\n        }\n\n        case 'insertMany': {\n          const result = await collection.insertMany(op.documents!, { session });\n          return { rows: op.documents as T[], rowCount: result.insertedCount };\n        }\n\n        case 'updateOne': {\n          const result = await collection.updateOne(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n            session,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'updateMany': {\n          const result = await collection.updateMany(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n            session,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'deleteOne': {\n          const result = await collection.deleteOne(op.filter!, { session });\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'deleteMany': {\n          const result = await collection.deleteMany(op.filter!, { session });\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'findOneAndUpdate': {\n          const result = await collection.findOneAndUpdate(op.filter!, op.update!, {\n            returnDocument: op.options?.returnDocument ?? 'after',\n            upsert: op.options?.upsert,\n            projection: op.options?.projection,\n            session,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'findOneAndDelete': {\n          const result = await collection.findOneAndDelete(op.filter!, {\n            projection: op.options?.projection,\n            session,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'countDocuments': {\n          const count = await collection.countDocuments(op.filter ?? {}, { session });\n          return { rows: [{ count } as T], rowCount: 1 };\n        }\n\n        default:\n          throw new Error(`Unsupported MongoDB operation: ${(op as MongoOperation).type}`);\n      }\n    } finally {\n      tracker.untrackQuery(queryId);\n    }\n  }\n\n  const driver: MongoDriver = {\n    dialect: 'mongodb',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      _sql: string,\n      _params?: unknown[]\n    ): Promise<QueryResult<T>> {\n      throw new Error(\n        'MongoDriver does not support SQL queries. Use executeOperation() with MongoOperation instead.'\n      );\n    },\n\n    async execute(_sql: string, _params?: unknown[]): Promise<{ rowCount: number }> {\n      throw new Error(\n        'MongoDriver does not support SQL execution. Use executeOperation() with MongoOperation instead.'\n      );\n    },\n\n    async transaction<T>(fn: (trx: MongoTransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const session = client.startSession();\n      try {\n        session.startTransaction();\n        const trxClient = new MongoTransactionClientImpl(session, executeOperationWithSession);\n        const result = await fn(trxClient);\n        await session.commitTransaction();\n        return result;\n      } catch (error) {\n        await session.abortTransaction();\n        throw error;\n      } finally {\n        await session.endSession();\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, ${activeQueries.length} queries still active`);\n        cancelledQueries = activeQueries.length;\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          tracker.markCancelled(query.id);\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connection');\n      await client.close(true);\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await client.close();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: maxConnections,\n        activeConnections: 0,\n        idleConnections: maxConnections,\n        waitingRequests: 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n\n    executeOperation,\n\n    getDb() {\n      return db;\n    },\n\n    collection(name: string) {\n      return db.collection(name);\n    },\n  };\n\n  return driver;\n}\n\nexport interface MongoTransactionClient extends TransactionClient {\n  executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>>;\n}\n\nclass MongoTransactionClientImpl implements MongoTransactionClient {\n  constructor(\n    private session: import('mongodb').ClientSession,\n    private execWithSession: <T>(\n      op: MongoOperation,\n      session: import('mongodb').ClientSession\n    ) => Promise<QueryResult<T>>\n  ) {}\n\n  async query<T = Record<string, unknown>>(\n    _sql: string,\n    _params?: unknown[]\n  ): Promise<QueryResult<T>> {\n    throw new Error('MongoTransactionClient does not support SQL queries.');\n  }\n\n  async execute(_sql: string, _params?: unknown[]): Promise<{ rowCount: number }> {\n    throw new Error('MongoTransactionClient does not support SQL execution.');\n  }\n\n  async executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>> {\n    return this.execWithSession<T>(op, this.session);\n  }\n}\n\nexport function isMongoDriver(driver: Driver): driver is MongoDriver {\n  return driver.dialect === 'mongodb' && 'executeOperation' in driver;\n}\n","import type { PoolConnection } from 'mysql2/promise';\nimport type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport { createTimeoutPromise } from './retry.js';\nimport type {\n  DrainOptions,\n  DrainResult,\n  Driver,\n  DriverConfig,\n  TransactionClient,\n} from './types.js';\n\nexport async function createMySQLDriver(config: DriverConfig): Promise<Driver> {\n  const mysql = await import('mysql2/promise');\n\n  const pool = mysql.createPool({\n    uri: config.connectionString,\n    waitForConnections: true,\n    connectionLimit: config.max ?? 20,\n    idleTimeout: (config.idleTimeout ?? 30) * 1000,\n    connectTimeout: (config.connectTimeout ?? 10) * 1000,\n  });\n\n  const maxConnections = config.max ?? 20;\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `mysql-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      const connection = (await Promise.race([\n        pool.getConnection(),\n        createTimeoutPromise<never>(healthCheckConfig.timeoutMs ?? 5000),\n      ])) as PoolConnection;\n\n      await connection.ping();\n      connection.release();\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'mysql',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const [rows] = await pool.execute(queryText, params);\n        const resultRows = Array.isArray(rows) ? rows : [];\n        return {\n          rows: resultRows as T[],\n          rowCount: resultRows.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const [result] = await pool.execute(queryText, params);\n        const affectedRows = (result as { affectedRows?: number }).affectedRows ?? 0;\n        return { rowCount: affectedRows };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const connection = await pool.getConnection();\n      await connection.beginTransaction();\n\n      try {\n        const client: TransactionClient = {\n          async query<R = Record<string, unknown>>(\n            queryText: string,\n            params: unknown[] = []\n          ): Promise<QueryResult<R>> {\n            const [rows] = await connection.execute(queryText, params);\n            const resultRows = Array.isArray(rows) ? rows : [];\n            return {\n              rows: resultRows as R[],\n              rowCount: resultRows.length,\n            };\n          },\n\n          async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n            const [result] = await connection.execute(queryText, params);\n            const affectedRows = (result as { affectedRows?: number }).affectedRows ?? 0;\n            return { rowCount: affectedRows };\n          },\n        };\n\n        const result = await fn(client);\n        await connection.commit();\n        return result;\n      } catch (error) {\n        await connection.rollback();\n        throw error;\n      } finally {\n        connection.release();\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n      const forceCancelOnTimeout = options.forceCancelOnTimeout ?? true;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut && forceCancelOnTimeout) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, cancelling ${activeQueries.length} queries`);\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          if (query.backendPid) {\n            try {\n              await pool.execute(`KILL QUERY ${query.backendPid}`);\n              tracker.markCancelled(query.id);\n              cancelledQueries++;\n            } catch (e) {\n              console.warn(`[db-engine] Failed to cancel query ${query.id}:`, e);\n            }\n          } else {\n            tracker.markCancelled(query.id);\n            cancelledQueries++;\n          }\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connections');\n      await pool.end();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await pool.end();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      const poolState = (pool as unknown as { pool?: MySQLPoolState }).pool;\n      return {\n        totalConnections: poolState?._allConnections?.length ?? 0,\n        activeConnections: poolState?._acquiringConnections?.length ?? 0,\n        idleConnections: poolState?._freeConnections?.length ?? 0,\n        waitingRequests: poolState?._connectionQueue?.length ?? 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n\ninterface MySQLPoolState {\n  _allConnections?: unknown[];\n  _acquiringConnections?: unknown[];\n  _freeConnections?: unknown[];\n  _connectionQueue?: unknown[];\n}\n","import type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport type {\n  DrainOptions,\n  DrainResult,\n  Driver,\n  DriverConfig,\n  TransactionClient,\n} from './types.js';\n\nexport async function createSQLiteDriver(config: DriverConfig): Promise<Driver> {\n  const Database = (await import('better-sqlite3')).default;\n\n  const dbPath = config.connectionString.replace('sqlite://', '').replace('file://', '');\n  const db = new Database(dbPath);\n\n  db.pragma('journal_mode = WAL');\n  db.pragma('foreign_keys = ON');\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `sqlite-${++queryIdCounter}`;\n\n  function performHealthCheck(): HealthCheckResult {\n    const startTime = Date.now();\n    try {\n      db.prepare('SELECT 1').get();\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'sqlite',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const stmt = db.prepare(queryText);\n        const rows = stmt.all(...params) as T[];\n        return {\n          rows,\n          rowCount: rows.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const stmt = db.prepare(queryText);\n        const result = stmt.run(...params);\n        return { rowCount: result.changes };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const client: TransactionClient = {\n        async query<R = Record<string, unknown>>(\n          queryText: string,\n          params: unknown[] = []\n        ): Promise<QueryResult<R>> {\n          const stmt = db.prepare(queryText);\n          const rows = stmt.all(...params) as R[];\n          return {\n            rows,\n            rowCount: rows.length,\n          };\n        },\n\n        async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n          const stmt = db.prepare(queryText);\n          const result = stmt.run(...params);\n          return { rowCount: result.changes };\n        },\n      };\n\n      let result: T;\n      let committed = false;\n\n      db.prepare('BEGIN IMMEDIATE').run();\n      try {\n        result = await fn(client);\n        db.prepare('COMMIT').run();\n        committed = true;\n        return result;\n      } catch (error) {\n        if (!committed) {\n          db.prepare('ROLLBACK').run();\n        }\n        throw error;\n      } finally {\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries: 0,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connection');\n      db.close();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries: 0,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      db.close();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: 1,\n        activeConnections: lastHealthCheck.healthy ? 1 : 0,\n        idleConnections: 0,\n        waitingRequests: 0,\n        maxConnections: 1,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n","import { mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport { createDriver } from '../driver/index.js';\nimport { getDialect } from '../migrations/dialects/index.js';\nimport { MigrationRunner } from '../migrations/runner.js';\nimport { MigrationCollector } from '../modules/collector.js';\nimport { ModuleRegistry } from '../modules/registry.js';\nimport type { ModuleDefinition } from '../modules/types.js';\nimport { createAuthHandler } from '../remote/auth.js';\nimport { createSchemaRemoteClient } from '../remote/client.js';\nimport {\n  BreakingChangeError,\n  UserCancelledError,\n  createSchemaSyncService,\n} from '../schema/index.js';\nimport { SchemaRegistry } from '../schema/registry.js';\nimport { generateTypes, generateZodSchemas } from '../types/generator.js';\nimport { generateHooks } from '../types/hooks-generator.js';\nimport type { SchemaDefinition } from '../types/index.js';\n\nexport interface CliConfig {\n  databaseUrl: string;\n  migrationsPath: string;\n  typesOutputPath?: string;\n}\n\nexport async function runMigrations(\n  config: CliConfig,\n  options: {\n    scope?: 'core' | 'template';\n    templateKey?: string;\n    steps?: number;\n    toVersion?: number;\n    dryRun?: boolean;\n    direction: 'up' | 'down';\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const runner = new MigrationRunner(driver, { migrationsPath: config.migrationsPath });\n\n  try {\n    const results =\n      options.direction === 'up' ? await runner.up(options) : await runner.down(options);\n\n    for (const result of results) {\n      if (result.success) {\n        console.log(`✓ ${result.version}__${result.name} (${result.duration}ms)`);\n      } else {\n        console.error(`✗ ${result.version}__${result.name}: ${result.error}`);\n      }\n    }\n\n    if (results.length === 0) {\n      console.log('No migrations to run');\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function getMigrationStatus(\n  config: CliConfig,\n  options: {\n    scope?: 'core' | 'template';\n    templateKey?: string;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const runner = new MigrationRunner(driver, { migrationsPath: config.migrationsPath });\n\n  try {\n    const status = await runner.status(options);\n\n    console.log('\\n=== Migration Status ===\\n');\n\n    if (status.current !== null) {\n      console.log(`Current version: ${status.current}`);\n    } else {\n      console.log('Current version: (none)');\n    }\n\n    console.log(`\\nApplied (${status.applied.length}):`);\n    for (const m of status.applied) {\n      console.log(`  ✓ ${m.version}__${m.name} (${m.appliedAt.toISOString()})`);\n    }\n\n    console.log(`\\nPending (${status.pending.length}):`);\n    for (const m of status.pending) {\n      console.log(`  ○ ${m.version}__${m.name}`);\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function verifyMigrations(\n  config: CliConfig,\n  options: {\n    scope?: 'core' | 'template';\n    templateKey?: string;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const runner = new MigrationRunner(driver, { migrationsPath: config.migrationsPath });\n\n  try {\n    const result = await runner.verify(options);\n\n    if (result.valid) {\n      console.log('✓ All migrations are valid');\n    } else {\n      console.error('✗ Migration verification failed:');\n      for (const issue of result.issues) {\n        console.error(`  - ${issue}`);\n      }\n      process.exit(1);\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function createMigration(\n  config: CliConfig,\n  options: {\n    name: string;\n    scope: 'core' | 'template';\n    templateKey?: string;\n  }\n): Promise<void> {\n  const timestamp = new Date()\n    .toISOString()\n    .replace(/[-:T.Z]/g, '')\n    .slice(0, 14);\n  const filename = `${timestamp}__${options.name}.sql`;\n\n  const dirPath =\n    options.scope === 'template' && options.templateKey\n      ? join(config.migrationsPath, 'templates', options.templateKey)\n      : join(config.migrationsPath, 'core');\n\n  await mkdir(dirPath, { recursive: true });\n\n  const filePath = join(dirPath, filename);\n  const content = `-- ${filename}\n-- Created: ${new Date().toISOString()}\n\n-- up\n\n\n-- down\n\n`;\n\n  await writeFile(filePath, content, 'utf-8');\n  console.log(`Created migration: ${filePath}`);\n}\n\nexport async function generateTypesFromRegistry(\n  config: CliConfig,\n  options: {\n    appId?: string;\n    outputPath?: string;\n    includeZodSchemas?: boolean;\n    includeInsertTypes?: boolean;\n    includeUpdateTypes?: boolean;\n    insertSuffix?: string;\n    updateSuffix?: string;\n    includeHooks?: boolean;\n    hooksOutputPath?: string;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new SchemaRegistry(driver);\n\n  try {\n    const schemas = await registry.listSchemas(options.appId);\n\n    if (schemas.length === 0) {\n      console.log('No schemas registered');\n      return;\n    }\n\n    const schemaMap = new Map<string, SchemaDefinition>();\n    for (const record of schemas) {\n      schemaMap.set(record.schema_name, record.schema);\n    }\n\n    const generatorOptions = {\n      includeInsertTypes: options.includeInsertTypes ?? true,\n      includeUpdateTypes: options.includeUpdateTypes ?? true,\n      insertSuffix: options.insertSuffix,\n      updateSuffix: options.updateSuffix,\n    };\n\n    const types = generateTypes(schemaMap, generatorOptions);\n    const outputPath = options.outputPath ?? config.typesOutputPath ?? './generated/types.ts';\n\n    await mkdir(dirname(outputPath), { recursive: true });\n    await writeFile(outputPath, types, 'utf-8');\n\n    console.log(`Generated types: ${outputPath}`);\n    console.log(`  Schemas: ${Array.from(schemaMap.keys()).join(', ')}`);\n    console.log(\n      `  Insert types: ${generatorOptions.includeInsertTypes ? 'yes' : 'no'}${options.insertSuffix ? ` (suffix: ${options.insertSuffix})` : ''}`\n    );\n    console.log(\n      `  Update types: ${generatorOptions.includeUpdateTypes ? 'yes' : 'no'}${options.updateSuffix ? ` (suffix: ${options.updateSuffix})` : ''}`\n    );\n\n    if (options.includeZodSchemas) {\n      const zodSchemas = generateZodSchemas(schemaMap, generatorOptions);\n      const zodOutputPath = outputPath.replace(/\\.ts$/, '.zod.ts');\n\n      await writeFile(zodOutputPath, zodSchemas, 'utf-8');\n\n      console.log(`Generated Zod schemas: ${zodOutputPath}`);\n    }\n\n    if (options.includeHooks) {\n      const hooksOutputPath = options.hooksOutputPath ?? outputPath.replace(/\\.ts$/, '.hooks.ts');\n      const typesImportPath = `./${hooksOutputPath.split('/').pop()!.replace('.hooks.ts', '').replace(/\\.ts$/, '')}`;\n\n      const hooks = generateHooks(schemaMap, {\n        includeQueryHooks: true,\n        includeMutationHooks: true,\n        typesImportPath: typesImportPath === './' ? './types' : typesImportPath,\n      });\n\n      await writeFile(hooksOutputPath, hooks, 'utf-8');\n\n      console.log(`Generated React Query hooks: ${hooksOutputPath}`);\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport interface WatchOptions {\n  appId?: string;\n  outputPath?: string;\n  debounceMs?: number;\n  includeZodSchemas?: boolean;\n  includeInsertTypes?: boolean;\n  includeUpdateTypes?: boolean;\n  insertSuffix?: string;\n  updateSuffix?: string;\n  includeHooks?: boolean;\n  hooksOutputPath?: string;\n}\n\nexport async function watchAndGenerateTypes(\n  config: CliConfig,\n  options: WatchOptions\n): Promise<void> {\n  const { debounceMs = 500 } = options;\n  const outputPath = options.outputPath ?? config.typesOutputPath ?? './generated/types.ts';\n\n  let isShuttingDown = false;\n  let debounceTimer: ReturnType<typeof setTimeout> | null = null;\n  let lastChecksum: string | null = null;\n  let pollInterval: ReturnType<typeof setInterval> | null = null;\n\n  const shutdown = async (driver?: { close: () => Promise<void> }) => {\n    if (isShuttingDown) return;\n    isShuttingDown = true;\n\n    console.log('\\n\\nShutting down watch mode...');\n\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n    if (pollInterval) {\n      clearInterval(pollInterval);\n    }\n    if (driver) {\n      await driver.close();\n    }\n\n    console.log('Watch mode stopped.');\n    process.exit(0);\n  };\n\n  const computeChecksum = (schemas: Map<string, SchemaDefinition>): string => {\n    const content = JSON.stringify(\n      Array.from(schemas.entries()).sort((a, b) => a[0].localeCompare(b[0]))\n    );\n    let hash = 0;\n    for (let i = 0; i < content.length; i++) {\n      const char = content.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash;\n    }\n    return hash.toString(16);\n  };\n\n  const regenerateTypes = async (registry: SchemaRegistry, reason: string): Promise<void> => {\n    try {\n      const schemas = await registry.listSchemas(options.appId);\n\n      if (schemas.length === 0) {\n        console.log(`[${new Date().toLocaleTimeString()}] No schemas registered`);\n        return;\n      }\n\n      const schemaMap = new Map<string, SchemaDefinition>();\n      for (const record of schemas) {\n        schemaMap.set(record.schema_name, record.schema);\n      }\n\n      const newChecksum = computeChecksum(schemaMap);\n\n      if (newChecksum === lastChecksum) {\n        return;\n      }\n\n      lastChecksum = newChecksum;\n\n      const generatorOptions = {\n        includeInsertTypes: options.includeInsertTypes ?? true,\n        includeUpdateTypes: options.includeUpdateTypes ?? true,\n        insertSuffix: options.insertSuffix,\n        updateSuffix: options.updateSuffix,\n      };\n\n      const types = generateTypes(schemaMap, generatorOptions);\n      await mkdir(dirname(outputPath), { recursive: true });\n      await writeFile(outputPath, types, 'utf-8');\n\n      const schemaNames = Array.from(schemaMap.keys()).join(', ');\n      console.log(\n        `[${new Date().toLocaleTimeString()}] ${reason} - Regenerated types (${schemaNames})`\n      );\n\n      if (options.includeZodSchemas) {\n        const zodSchemas = generateZodSchemas(schemaMap, generatorOptions);\n        const zodOutputPath = outputPath.replace(/\\.ts$/, '.zod.ts');\n        await writeFile(zodOutputPath, zodSchemas, 'utf-8');\n        console.log(`[${new Date().toLocaleTimeString()}] ${reason} - Regenerated Zod schemas`);\n      }\n\n      if (options.includeHooks) {\n        const hooksOutputPath = options.hooksOutputPath ?? outputPath.replace(/\\.ts$/, '.hooks.ts');\n        const typesImportPath = `./${hooksOutputPath.split('/').pop()!.replace('.hooks.ts', '').replace(/\\.ts$/, '')}`;\n\n        const hooks = generateHooks(schemaMap, {\n          includeQueryHooks: true,\n          includeMutationHooks: true,\n          typesImportPath: typesImportPath === './' ? './types' : typesImportPath,\n        });\n\n        await writeFile(hooksOutputPath, hooks, 'utf-8');\n        console.log(\n          `[${new Date().toLocaleTimeString()}] ${reason} - Regenerated React Query hooks`\n        );\n      }\n    } catch (error) {\n      console.error(\n        `[${new Date().toLocaleTimeString()}] Error regenerating types:`,\n        error instanceof Error ? error.message : error\n      );\n    }\n  };\n\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new SchemaRegistry(driver);\n\n  process.on('SIGINT', () => shutdown(driver));\n  process.on('SIGTERM', () => shutdown(driver));\n\n  console.log('Watching for schema changes...');\n  console.log(`  Output: ${outputPath}`);\n  console.log(`  Debounce: ${debounceMs}ms`);\n  console.log('  Press Ctrl+C to stop\\n');\n\n  await regenerateTypes(registry, 'Initial generation');\n\n  const debouncedRegenerate = (reason: string) => {\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n    debounceTimer = setTimeout(async () => {\n      await regenerateTypes(registry, reason);\n    }, debounceMs);\n  };\n\n  pollInterval = setInterval(() => {\n    if (!isShuttingDown) {\n      debouncedRegenerate('Schema change detected');\n    }\n  }, 1000);\n\n  await new Promise<void>(() => {});\n}\n\nexport async function registerSchema(\n  config: CliConfig,\n  options: {\n    appId: string;\n    schemaName: string;\n    version: string;\n    schemaPath: string;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new SchemaRegistry(driver);\n\n  try {\n    // Verify file exists by reading it\n    await readFile(options.schemaPath, 'utf-8');\n    const schemaModule = await import(options.schemaPath);\n    const schema: SchemaDefinition = schemaModule.schema || schemaModule.default;\n\n    if (!schema?.tables) {\n      throw new Error('Invalid schema file. Must export a SchemaDefinition with tables property.');\n    }\n\n    const results = await registry.register({\n      appId: options.appId,\n      schemaName: options.schemaName,\n      version: options.version,\n      schema,\n    });\n\n    if (results.length === 0) {\n      console.log('Schema is up to date');\n    } else {\n      console.log(`Applied ${results.length} schema changes:`);\n      for (const result of results) {\n        if (result.success) {\n          console.log(`  ✓ ${result.name}`);\n        } else {\n          console.error(`  ✗ ${result.name}: ${result.error}`);\n        }\n      }\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function listModules(config: CliConfig): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new ModuleRegistry(driver);\n\n  try {\n    const modules = await registry.list();\n\n    console.log('\\n=== Registered Modules ===\\n');\n\n    if (modules.length === 0) {\n      console.log('No modules registered');\n      return;\n    }\n\n    for (const mod of modules) {\n      console.log(`${mod.name} (v${mod.version})`);\n      console.log(`  Display name: ${mod.displayName}`);\n      if (mod.description) {\n        console.log(`  Description: ${mod.description}`);\n      }\n      console.log(`  Migration prefix: ${mod.migrationPrefix}`);\n      if (mod.dependencies?.length) {\n        console.log(`  Dependencies: ${mod.dependencies.join(', ')}`);\n      }\n      console.log();\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function registerModule(\n  config: CliConfig,\n  options: {\n    name: string;\n    displayName: string;\n    version: string;\n    migrationPrefix: string;\n    description?: string;\n    dependencies?: string[];\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new ModuleRegistry(driver);\n\n  try {\n    const module: ModuleDefinition = {\n      name: options.name,\n      displayName: options.displayName,\n      version: options.version,\n      migrationPrefix: options.migrationPrefix,\n      description: options.description,\n      dependencies: options.dependencies,\n    };\n\n    await registry.register(module);\n    console.log(`✓ Registered module: ${options.name} (v${options.version})`);\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function runModuleMigrations(\n  config: CliConfig,\n  options: {\n    modulesPath: string;\n    dryRun?: boolean;\n    direction?: 'up' | 'down';\n    steps?: number;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const runner = new MigrationRunner(driver, { migrationsPath: config.migrationsPath });\n  const collector = new MigrationCollector();\n\n  try {\n    const sources = await collector.discoverFromDirectory(options.modulesPath);\n\n    if (sources.length === 0) {\n      console.log('No module migrations found');\n      return;\n    }\n\n    console.log(`Found ${sources.length} module(s):`);\n    for (const source of sources) {\n      console.log(`  - ${source.moduleName}`);\n    }\n    console.log();\n\n    const migrations = await collector.collect(sources);\n\n    if (migrations.length === 0) {\n      console.log('No migrations to run');\n      return;\n    }\n\n    await runner.ensureMigrationsTable();\n\n    const direction = options.direction ?? 'up';\n    let migrationsToRun = migrations;\n\n    if (options.steps) {\n      migrationsToRun =\n        direction === 'up'\n          ? migrations.slice(0, options.steps)\n          : migrations.slice(-options.steps).reverse();\n    }\n\n    for (const migration of migrationsToRun) {\n      if (options.dryRun) {\n        console.log(\n          `[DRY RUN] Would ${direction === 'up' ? 'apply' : 'rollback'}: ${migration.version}__${migration.name} (module: ${migration.moduleName})`\n        );\n        continue;\n      }\n\n      const startTime = Date.now();\n      try {\n        const statements = direction === 'up' ? migration.up : migration.down;\n        for (const sql of statements) {\n          await driver.execute(sql);\n        }\n        console.log(\n          `✓ ${migration.version}__${migration.name} (module: ${migration.moduleName}) (${Date.now() - startTime}ms)`\n        );\n      } catch (error) {\n        console.error(\n          `✗ ${migration.version}__${migration.name} (module: ${migration.moduleName}): ${error instanceof Error ? error.message : error}`\n        );\n        break;\n      }\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport interface SyncConfig {\n  databaseUrl: string;\n  apiUrl: string;\n  projectId: string;\n  appId: string;\n  migrationsPath?: string;\n}\n\nexport async function pullSchema(\n  config: SyncConfig,\n  options: {\n    environment?: string;\n    dryRun?: boolean;\n    force?: boolean;\n  } = {}\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const dialect = getDialect(driver.dialect);\n\n  const authHandler = createAuthHandler();\n  let authToken: string;\n\n  try {\n    authToken = await authHandler.getToken();\n  } catch (error) {\n    console.error('Authentication required. Run `launchpad login` first.');\n    await driver.close();\n    process.exit(1);\n  }\n\n  const remoteClient = createSchemaRemoteClient({\n    apiUrl: config.apiUrl,\n    projectId: config.projectId,\n    authToken,\n  });\n\n  const syncService = createSchemaSyncService(driver, dialect, remoteClient, {\n    appId: config.appId,\n    migrationsPath: config.migrationsPath,\n  });\n\n  try {\n    const result = await syncService.pull({\n      environment: options.environment,\n      dryRun: options.dryRun,\n      force: options.force,\n    });\n\n    if (result.applied) {\n      console.log(`\\n✓ Applied ${result.diff.changes.length} change(s)`);\n    } else if (!result.diff.hasDifferences) {\n      console.log('\\n✓ Local schema is already up to date');\n    }\n  } catch (error) {\n    if (error instanceof BreakingChangeError) {\n      console.error(`\\n✗ ${error.message}`);\n      console.error('\\nBreaking changes detected:');\n      for (const change of error.changes) {\n        console.error(`  - ${change.description}`);\n      }\n      process.exit(1);\n    }\n    throw error;\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function pushSchema(\n  config: SyncConfig,\n  options: {\n    environment?: string;\n    dryRun?: boolean;\n    force?: boolean;\n  } = {}\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const dialect = getDialect(driver.dialect);\n\n  const authHandler = createAuthHandler();\n  let authToken: string;\n\n  try {\n    authToken = await authHandler.getToken();\n  } catch (error) {\n    console.error('Authentication required. Run `launchpad login` first.');\n    await driver.close();\n    process.exit(1);\n  }\n\n  const remoteClient = createSchemaRemoteClient({\n    apiUrl: config.apiUrl,\n    projectId: config.projectId,\n    authToken,\n  });\n\n  const syncService = createSchemaSyncService(driver, dialect, remoteClient, {\n    appId: config.appId,\n    migrationsPath: config.migrationsPath,\n  });\n\n  try {\n    const result = await syncService.push({\n      environment: options.environment,\n      dryRun: options.dryRun,\n      force: options.force,\n    });\n\n    if (result.applied) {\n      console.log(`\\n✓ Pushed ${result.diff.changes.length} change(s) to remote`);\n    } else if (!result.diff.hasDifferences) {\n      console.log('\\n✓ Remote schema is already up to date');\n    }\n  } catch (error) {\n    if (error instanceof BreakingChangeError) {\n      console.error(`\\n✗ ${error.message}`);\n      console.error('\\nBreaking changes detected:');\n      for (const change of error.changes) {\n        console.error(`  - ${change.description}`);\n      }\n      process.exit(1);\n    }\n    if (error instanceof UserCancelledError) {\n      console.error(`\\n${error.message}`);\n      process.exit(1);\n    }\n    throw error;\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function diffSchema(\n  config: SyncConfig,\n  options: {\n    environment?: string;\n    outputFormat?: 'text' | 'json' | 'sql';\n  } = {}\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const dialect = getDialect(driver.dialect);\n\n  const authHandler = createAuthHandler();\n  let authToken: string;\n\n  try {\n    authToken = await authHandler.getToken();\n  } catch (error) {\n    console.error('Authentication required. Run `launchpad login` first.');\n    await driver.close();\n    process.exit(1);\n  }\n\n  const remoteClient = createSchemaRemoteClient({\n    apiUrl: config.apiUrl,\n    projectId: config.projectId,\n    authToken,\n  });\n\n  const syncService = createSchemaSyncService(driver, dialect, remoteClient, {\n    appId: config.appId,\n    migrationsPath: config.migrationsPath,\n  });\n\n  try {\n    const diff = await syncService.diff({\n      environment: options.environment,\n    });\n\n    const output = syncService.formatDiff(diff, options.outputFormat ?? 'text');\n    console.log(output);\n\n    if (diff.hasDifferences) {\n      process.exit(1);\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function getSyncStatus(config: SyncConfig): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const dialect = getDialect(driver.dialect);\n\n  const authHandler = createAuthHandler();\n  let authToken: string;\n\n  try {\n    authToken = await authHandler.getToken();\n  } catch (error) {\n    console.error('Authentication required. Run `launchpad login` first.');\n    await driver.close();\n    process.exit(1);\n  }\n\n  const remoteClient = createSchemaRemoteClient({\n    apiUrl: config.apiUrl,\n    projectId: config.projectId,\n    authToken,\n  });\n\n  const syncService = createSchemaSyncService(driver, dialect, remoteClient, {\n    appId: config.appId,\n    migrationsPath: config.migrationsPath,\n  });\n\n  try {\n    const status = await syncService.getSyncStatus();\n\n    if (!status) {\n      console.log('No sync history found. Run `db pull` or `db push` to sync.');\n      return;\n    }\n\n    console.log('\\n=== Sync Status ===\\n');\n    console.log(`Status: ${status.syncStatus}`);\n    console.log(`Last sync: ${status.lastSyncAt?.toISOString() ?? 'Never'}`);\n    console.log(`Direction: ${status.lastSyncDirection ?? 'N/A'}`);\n    console.log(`Local checksum: ${status.localChecksum ?? 'N/A'}`);\n    console.log(`Remote checksum: ${status.remoteChecksum ?? 'N/A'}`);\n\n    if (status.syncStatus === 'conflict') {\n      console.log('\\n⚠️  Conflict detected! Manual resolution required.');\n    }\n  } finally {\n    await driver.close();\n  }\n}\n","import postgres, { type ParameterOrJSON } from 'postgres';\nimport type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport { createTimeoutPromise } from './retry.js';\nimport type {\n  DrainOptions,\n  DrainResult,\n  Driver,\n  DriverConfig,\n  TransactionClient,\n} from './types.js';\n\nexport function createPostgresDriver(config: DriverConfig): Driver {\n  const sql = postgres(config.connectionString, {\n    max: config.max ?? 20,\n    idle_timeout: config.idleTimeout ?? 30,\n    connect_timeout: config.connectTimeout ?? 10,\n    prepare: true,\n  });\n\n  const maxConnections = config.max ?? 20;\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `pg-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      await Promise.race([\n        sql`SELECT 1`,\n        createTimeoutPromise<never>(healthCheckConfig.timeoutMs ?? 5000),\n      ]);\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'postgresql',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const result = await sql.unsafe<T[]>(queryText, params as ParameterOrJSON<never>[]);\n        return {\n          rows: result as T[],\n          rowCount: result.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const result = await sql.unsafe(queryText, params as ParameterOrJSON<never>[]);\n        return { rowCount: result.count ?? 0 };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      try {\n        const result = await sql.begin(async (tx) => {\n          const client: TransactionClient = {\n            async query<R = Record<string, unknown>>(\n              queryText: string,\n              params: unknown[] = []\n            ): Promise<QueryResult<R>> {\n              const txResult = await tx.unsafe<R[]>(queryText, params as ParameterOrJSON<never>[]);\n              return {\n                rows: txResult as R[],\n                rowCount: txResult.length,\n              };\n            },\n\n            async execute(\n              queryText: string,\n              params: unknown[] = []\n            ): Promise<{ rowCount: number }> {\n              const txResult = await tx.unsafe(queryText, params as ParameterOrJSON<never>[]);\n              return { rowCount: txResult.count ?? 0 };\n            },\n          };\n\n          return fn(client);\n        });\n        return result as T;\n      } finally {\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n      const forceCancelOnTimeout = options.forceCancelOnTimeout ?? true;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut && forceCancelOnTimeout) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, cancelling ${activeQueries.length} queries`);\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          try {\n            await sql.unsafe(\n              `SELECT pg_cancel_backend(pid) FROM pg_stat_activity\n               WHERE state = 'active' AND query LIKE $1`,\n              [`%${query.query.slice(0, 50)}%`]\n            );\n            tracker.markCancelled(query.id);\n            cancelledQueries++;\n          } catch (e) {\n            console.warn(`[db-engine] Failed to cancel query ${query.id}:`, e);\n          }\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connections');\n      await sql.end();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await sql.end();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: maxConnections,\n        activeConnections: (sql as unknown as { connections?: number }).connections ?? 0,\n        idleConnections:\n          maxConnections - ((sql as unknown as { connections?: number }).connections ?? 0),\n        waitingRequests: 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n","import type { DialectName } from '../types/index.js';\nimport { createPostgresDriver } from './postgresql.js';\nimport type { Driver, DriverConfig } from './types.js';\n\nexport type {\n  Driver,\n  DriverConfig,\n  TransactionClient,\n  DrainOptions,\n  DrainProgress,\n  DrainResult,\n  DrainPhase,\n} from './types.js';\nexport type { MongoDriver, MongoDriverConfig, MongoTransactionClient } from './mongodb.js';\nexport { createMongoDriver, isMongoDriver } from './mongodb.js';\nexport { QueryTracker, type QueryInfo } from './query-tracker.js';\nexport { registerSignalHandlers, type SignalHandlerOptions } from './signal-handler.js';\n\nexport type {\n  PoolStats,\n  HealthCheckResult,\n  HealthCheckConfig,\n} from './health.js';\nexport {\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\n\nexport type { PoolMonitorConfig, PoolMonitor } from './pool-monitor.js';\nexport { createPoolMonitor } from './pool-monitor.js';\n\nexport type { RetryConfig } from './retry.js';\nexport { isRetryableError, withRetry, createTimeoutPromise } from './retry.js';\n\nexport interface CreateDriverOptions extends DriverConfig {\n  dialect?: DialectName;\n  database?: string;\n}\n\nexport function detectDialect(connectionString: string): DialectName {\n  if (connectionString.startsWith('mongodb://') || connectionString.startsWith('mongodb+srv://')) {\n    return 'mongodb';\n  }\n  if (connectionString.startsWith('postgres://') || connectionString.startsWith('postgresql://')) {\n    return 'postgresql';\n  }\n  if (connectionString.startsWith('mysql://') || connectionString.startsWith('mariadb://')) {\n    return 'mysql';\n  }\n  if (\n    connectionString.startsWith('sqlite://') ||\n    connectionString.startsWith('file://') ||\n    connectionString.endsWith('.db') ||\n    connectionString.endsWith('.sqlite') ||\n    connectionString.endsWith('.sqlite3')\n  ) {\n    return 'sqlite';\n  }\n  throw new Error(`Unable to detect database dialect from connection string: ${connectionString}`);\n}\n\nexport async function createDriver(options: CreateDriverOptions): Promise<Driver> {\n  const dialect = options.dialect ?? detectDialect(options.connectionString);\n\n  switch (dialect) {\n    case 'postgresql':\n      return createPostgresDriver(options);\n\n    case 'mysql': {\n      const { createMySQLDriver } = await import('./mysql.js');\n      return createMySQLDriver(options);\n    }\n\n    case 'sqlite': {\n      const { createSQLiteDriver } = await import('./sqlite.js');\n      return createSQLiteDriver(options);\n    }\n\n    case 'mongodb': {\n      const { createMongoDriver } = await import('./mongodb.js');\n      return createMongoDriver(options);\n    }\n\n    default:\n      throw new Error(`Unsupported dialect: ${dialect}`);\n  }\n}\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nfunction compileMysqlDefault(colDef: ColumnDefinition): string {\n  if (!colDef.default) return '';\n  const defaultVal = colDef.default === 'gen_random_uuid()' ? '(UUID())' : colDef.default;\n  return ` DEFAULT ${defaultVal}`;\n}\n\nfunction compileMysqlConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  sql += compileMysqlDefault(colDef);\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compileMysqlForeignKeys(\n  tableName: string,\n  columns: Record<string, ColumnDefinition>\n): string[] {\n  const fkDefs: string[] = [];\n  for (const [colName, colDef] of Object.entries(columns)) {\n    if (colDef.references) {\n      const fkName = `fk_${tableName}_${colName}`;\n      let fk = `  CONSTRAINT \\`${fkName}\\` FOREIGN KEY (\\`${colName}\\`) `;\n      fk += `REFERENCES \\`${colDef.references.table}\\`(\\`${colDef.references.column}\\`)`;\n      if (colDef.references.onDelete) {\n        fk += ` ON DELETE ${colDef.references.onDelete}`;\n      }\n      fkDefs.push(fk);\n    }\n  }\n  return fkDefs;\n}\n\nexport const mysqlDialect: Dialect = {\n  name: 'mysql',\n  supportsTransactionalDDL: false,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'CHAR(36)',\n      string: 'VARCHAR(255)',\n      text: 'TEXT',\n      integer: 'INT',\n      bigint: 'BIGINT',\n      float: 'DOUBLE',\n      decimal: 'DECIMAL(10,2)',\n      boolean: 'TINYINT(1)',\n      datetime: 'DATETIME',\n      date: 'DATE',\n      time: 'TIME',\n      json: 'JSON',\n      binary: 'BLOB',\n    };\n    return map[type] || 'VARCHAR(255)';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \\`${colName}\\` ${this.mapType(colDef.type)}`;\n      return typeSql + compileMysqlConstraints(colDef);\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\\`${c}\\``).join(', ')})`);\n    }\n\n    const foreignKeys = compileMysqlForeignKeys(name, def.columns);\n    columnDefs.push(...foreignKeys);\n\n    return `CREATE TABLE \\`${name}\\` (\\n${columnDefs.join(',\\n')}\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \\`${name}\\``;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \\`${table}\\` ADD COLUMN \\`${column}\\` ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    if (def.unique) {\n      sql += ' UNIQUE';\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \\`${table}\\` DROP COLUMN \\`${column}\\``;\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \\`${table}\\` MODIFY COLUMN \\`${column}\\` ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    return sql;\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\\`${c}\\``).join(', ');\n    return `CREATE ${unique}INDEX \\`${indexName}\\` ON \\`${table}\\` (${columns})`;\n  },\n\n  dropIndex(name: string, table?: string): string {\n    if (!table) {\n      throw new Error('MySQL requires table name for DROP INDEX');\n    }\n    return `DROP INDEX \\`${name}\\` ON \\`${table}\\``;\n  },\n\n  addForeignKey(\n    table: string,\n    column: string,\n    refTable: string,\n    refColumn: string,\n    onDelete?: string\n  ): string {\n    const constraintName = `fk_${table}_${column}_${refTable}`;\n    let sql = `ALTER TABLE \\`${table}\\` ADD CONSTRAINT \\`${constraintName}\\` `;\n    sql += `FOREIGN KEY (\\`${column}\\`) REFERENCES \\`${refTable}\\`(\\`${refColumn}\\`)`;\n    if (onDelete) {\n      sql += ` ON DELETE ${onDelete}`;\n    }\n    return sql;\n  },\n\n  dropForeignKey(table: string, constraintName: string): string {\n    return `ALTER TABLE \\`${table}\\` DROP FOREIGN KEY \\`${constraintName}\\``;\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT table_name\n      FROM information_schema.tables\n      WHERE table_schema = DATABASE()\n        AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `\n      SELECT\n        column_name,\n        data_type,\n        is_nullable,\n        column_default,\n        character_maximum_length\n      FROM information_schema.columns\n      WHERE table_schema = DATABASE() AND table_name = '${table}'\n      ORDER BY ordinal_position\n    `;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `\n      SELECT\n        index_name,\n        column_name,\n        non_unique\n      FROM information_schema.statistics\n      WHERE table_schema = DATABASE() AND table_name = '${table}'\n      ORDER BY index_name, seq_in_index\n    `;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nfunction compilePostgresConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  if (colDef.default) {\n    sql += ` DEFAULT ${colDef.default}`;\n  }\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compilePostgresReferences(colDef: ColumnDefinition): string {\n  if (!colDef.references) return '';\n  let sql = ` REFERENCES \"${colDef.references.table}\"(\"${colDef.references.column}\")`;\n  if (colDef.references.onDelete) {\n    sql += ` ON DELETE ${colDef.references.onDelete}`;\n  }\n  if (colDef.references.onUpdate) {\n    sql += ` ON UPDATE ${colDef.references.onUpdate}`;\n  }\n  return sql;\n}\n\nexport const postgresDialect: Dialect = {\n  name: 'postgresql',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'UUID',\n      string: 'TEXT',\n      text: 'TEXT',\n      integer: 'INTEGER',\n      bigint: 'BIGINT',\n      float: 'DOUBLE PRECISION',\n      decimal: 'NUMERIC',\n      boolean: 'BOOLEAN',\n      datetime: 'TIMESTAMPTZ',\n      date: 'DATE',\n      time: 'TIME',\n      json: 'JSONB',\n      binary: 'BYTEA',\n    };\n    return map[type] || 'TEXT';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \"${colName}\" ${this.mapType(colDef.type)}`;\n      const constraints = compilePostgresConstraints(colDef);\n      const references = compilePostgresReferences(colDef);\n      return typeSql + constraints + references;\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\"${c}\"`).join(', ')})`);\n    }\n\n    return `CREATE TABLE \"${name}\" (\\n${columnDefs.join(',\\n')}\\n)`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \"${name}\" CASCADE`;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \"${table}\" ADD COLUMN \"${column}\" ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    if (def.unique) {\n      sql += ' UNIQUE';\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \"${table}\" DROP COLUMN \"${column}\"`;\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): string {\n    const statements: string[] = [];\n\n    statements.push(\n      `ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" TYPE ${this.mapType(def.type)}`\n    );\n\n    if (def.nullable === false) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" SET NOT NULL`);\n    } else if (def.nullable === true) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" DROP NOT NULL`);\n    }\n\n    if (def.default !== undefined) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" SET DEFAULT ${def.default}`);\n    }\n\n    return statements.join(';\\n');\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\"${c}\"`).join(', ');\n    let sql = `CREATE ${unique}INDEX \"${indexName}\" ON \"${table}\" (${columns})`;\n\n    if (index.where) {\n      sql += ` WHERE ${index.where}`;\n    }\n\n    return sql;\n  },\n\n  dropIndex(name: string): string {\n    return `DROP INDEX IF EXISTS \"${name}\"`;\n  },\n\n  addForeignKey(\n    table: string,\n    column: string,\n    refTable: string,\n    refColumn: string,\n    onDelete?: string\n  ): string {\n    const constraintName = `fk_${table}_${column}_${refTable}`;\n    let sql = `ALTER TABLE \"${table}\" ADD CONSTRAINT \"${constraintName}\" `;\n    sql += `FOREIGN KEY (\"${column}\") REFERENCES \"${refTable}\"(\"${refColumn}\")`;\n    if (onDelete) {\n      sql += ` ON DELETE ${onDelete}`;\n    }\n    return sql;\n  },\n\n  dropForeignKey(table: string, constraintName: string): string {\n    return `ALTER TABLE \"${table}\" DROP CONSTRAINT \"${constraintName}\"`;\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT table_name\n      FROM information_schema.tables\n      WHERE table_schema = 'public'\n        AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `\n      SELECT\n        column_name,\n        data_type,\n        is_nullable,\n        column_default,\n        character_maximum_length\n      FROM information_schema.columns\n      WHERE table_schema = 'public' AND table_name = '${table}'\n      ORDER BY ordinal_position\n    `;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `\n      SELECT\n        i.relname as index_name,\n        a.attname as column_name,\n        ix.indisunique as is_unique,\n        ix.indisprimary as is_primary\n      FROM pg_class t\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE t.relname = '${table}'\n      ORDER BY i.relname, a.attnum\n    `;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nconst SQLITE_UUID_DEFAULT =\n  \"(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))\";\n\nfunction compileSqliteDefault(colDef: ColumnDefinition): string {\n  if (!colDef.default) return '';\n  let defaultVal = colDef.default;\n  if (colDef.default === 'gen_random_uuid()') {\n    defaultVal = SQLITE_UUID_DEFAULT;\n  } else if (colDef.default === 'now()' || colDef.default === 'NOW()') {\n    defaultVal = \"datetime('now')\";\n  }\n  return ` DEFAULT ${defaultVal}`;\n}\n\nfunction compileSqliteConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  sql += compileSqliteDefault(colDef);\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compileSqliteReferences(colDef: ColumnDefinition): string {\n  if (!colDef.references) return '';\n  let sql = ` REFERENCES \"${colDef.references.table}\"(\"${colDef.references.column}\")`;\n  if (colDef.references.onDelete) {\n    sql += ` ON DELETE ${colDef.references.onDelete}`;\n  }\n  return sql;\n}\n\nexport const sqliteDialect: Dialect = {\n  name: 'sqlite',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'TEXT',\n      string: 'TEXT',\n      text: 'TEXT',\n      integer: 'INTEGER',\n      bigint: 'INTEGER',\n      float: 'REAL',\n      decimal: 'REAL',\n      boolean: 'INTEGER',\n      datetime: 'TEXT',\n      date: 'TEXT',\n      time: 'TEXT',\n      json: 'TEXT',\n      binary: 'BLOB',\n    };\n    return map[type] || 'TEXT';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \"${colName}\" ${this.mapType(colDef.type)}`;\n      const constraints = compileSqliteConstraints(colDef);\n      const references = compileSqliteReferences(colDef);\n      return typeSql + constraints + references;\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\"${c}\"`).join(', ')})`);\n    }\n\n    return `CREATE TABLE \"${name}\" (\\n${columnDefs.join(',\\n')}\\n)`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \"${name}\"`;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \"${table}\" ADD COLUMN \"${column}\" ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \"${table}\" DROP COLUMN \"${column}\"`;\n  },\n\n  alterColumn(_table: string, _column: string, _def: ColumnDefinition): string {\n    throw new Error(\n      'SQLite does not support ALTER COLUMN. Use table recreation instead: ' +\n        '1. Create new table with desired schema, 2. Copy data, 3. Drop old table, 4. Rename new table'\n    );\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\"${c}\"`).join(', ');\n    let sql = `CREATE ${unique}INDEX \"${indexName}\" ON \"${table}\" (${columns})`;\n\n    if (index.where) {\n      sql += ` WHERE ${index.where}`;\n    }\n\n    return sql;\n  },\n\n  dropIndex(name: string): string {\n    return `DROP INDEX IF EXISTS \"${name}\"`;\n  },\n\n  addForeignKey(\n    _table: string,\n    _column: string,\n    _refTable: string,\n    _refColumn: string,\n    _onDelete?: string\n  ): string {\n    throw new Error(\n      'SQLite does not support adding foreign keys after table creation. ' +\n        'Define foreign keys in CREATE TABLE or use table recreation.'\n    );\n  },\n\n  dropForeignKey(_table: string, _constraintName: string): string {\n    throw new Error('SQLite does not support dropping foreign keys. Use table recreation instead.');\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT name as table_name\n      FROM sqlite_master\n      WHERE type = 'table' AND name NOT LIKE 'sqlite_%'\n      ORDER BY name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `PRAGMA table_info(\"${table}\")`;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `PRAGMA index_list(\"${table}\")`;\n  },\n};\n","import type { DialectName } from '../../types/index.js';\nimport { mysqlDialect } from './mysql.js';\nimport { postgresDialect } from './postgresql.js';\nimport { sqliteDialect } from './sqlite.js';\nimport type { Dialect } from './types.js';\n\nexport type { Dialect } from './types.js';\nexport { mongoDialect, executeMongoMigration } from './mongodb.js';\nexport type { MongoDialect, MongoMigrationOperation } from './mongodb.js';\n\nexport function getDialect(name: DialectName): Dialect {\n  switch (name) {\n    case 'postgresql':\n      return postgresDialect;\n    case 'mysql':\n      return mysqlDialect;\n    case 'sqlite':\n      return sqliteDialect;\n    case 'mongodb':\n      throw new Error(\n        'MongoDB uses a different dialect interface. Use mongoDialect and executeMongoMigration instead.'\n      );\n    default:\n      throw new Error(`Unsupported dialect: ${name}`);\n  }\n}\n\nexport { postgresDialect, mysqlDialect, sqliteDialect };\n","import { createHash } from 'node:crypto';\nimport { readFile, readdir } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { Driver } from '../driver/types.js';\nimport type {\n  MigrationFile,\n  MigrationRecord,\n  MigrationResult,\n  MigrationStatus,\n} from '../types/index.js';\nimport { getDialect } from './dialects/index.js';\nimport type { Dialect } from './dialects/types.js';\n\nexport interface MigrationRunnerOptions {\n  migrationsPath: string;\n  tableName?: string;\n}\n\nexport interface MigrationRunOptions {\n  scope?: 'core' | 'template';\n  templateKey?: string;\n  moduleName?: string;\n  steps?: number;\n  toVersion?: number;\n  dryRun?: boolean;\n}\n\nexport class MigrationRunner {\n  private driver: Driver;\n  private dialect: Dialect;\n  private migrationsPath: string;\n  private tableName: string;\n\n  constructor(driver: Driver, options: MigrationRunnerOptions) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.migrationsPath = options.migrationsPath;\n    this.tableName = options.tableName ?? 'lp_migrations';\n  }\n\n  async ensureMigrationsTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          version BIGINT PRIMARY KEY,\n          name TEXT NOT NULL,\n          scope TEXT NOT NULL CHECK (scope IN ('core', 'template')),\n          template_key TEXT,\n          module_name TEXT,\n          checksum TEXT NOT NULL,\n          up_sql TEXT[] NOT NULL,\n          down_sql TEXT[],\n          applied_at TIMESTAMPTZ DEFAULT NOW(),\n          executed_by TEXT\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            version BIGINT PRIMARY KEY,\n            name VARCHAR(255) NOT NULL,\n            scope VARCHAR(20) NOT NULL,\n            template_key VARCHAR(255),\n            module_name VARCHAR(255),\n            checksum VARCHAR(64) NOT NULL,\n            up_sql JSON NOT NULL,\n            down_sql JSON,\n            applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            executed_by VARCHAR(255)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            version INTEGER PRIMARY KEY,\n            name TEXT NOT NULL,\n            scope TEXT NOT NULL CHECK (scope IN ('core', 'template')),\n            template_key TEXT,\n            module_name TEXT,\n            checksum TEXT NOT NULL,\n            up_sql TEXT NOT NULL,\n            down_sql TEXT,\n            applied_at TEXT DEFAULT (datetime('now')),\n            executed_by TEXT\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(`\n        CREATE UNIQUE INDEX IF NOT EXISTS idx_${this.tableName}_scope_version\n        ON \"${this.tableName}\" (scope, COALESCE(template_key, ''), version)\n      `);\n    }\n  }\n\n  async up(options: MigrationRunOptions = {}): Promise<MigrationResult[]> {\n    await this.ensureMigrationsTable();\n\n    const pending = await this.getPendingMigrations(options);\n    const results: MigrationResult[] = [];\n\n    let migrationsToRun = pending;\n    if (options.steps) {\n      migrationsToRun = pending.slice(0, options.steps);\n    }\n    if (options.toVersion) {\n      migrationsToRun = pending.filter((m) => m.version <= options.toVersion!);\n    }\n\n    for (const migration of migrationsToRun) {\n      const startTime = Date.now();\n\n      if (options.dryRun) {\n        console.log(`[DRY RUN] Would apply migration: ${migration.version}__${migration.name}`);\n        console.log(migration.up.join('\\n'));\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: 0,\n        });\n        continue;\n      }\n\n      try {\n        if (this.dialect.supportsTransactionalDDL) {\n          await this.driver.transaction(async (trx) => {\n            for (const sql of migration.up) {\n              await trx.execute(sql);\n            }\n            await this.recordMigration(trx, migration);\n          });\n        } else {\n          for (const sql of migration.up) {\n            await this.driver.execute(sql);\n          }\n          await this.recordMigration(this.driver, migration);\n        }\n\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: Date.now() - startTime,\n        });\n      } catch (error) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n        break;\n      }\n    }\n\n    return results;\n  }\n\n  async down(options: MigrationRunOptions = {}): Promise<MigrationResult[]> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const results: MigrationResult[] = [];\n\n    let migrationsToRollback = applied.reverse();\n    if (options.steps) {\n      migrationsToRollback = migrationsToRollback.slice(0, options.steps);\n    }\n    if (options.toVersion) {\n      migrationsToRollback = migrationsToRollback.filter((m) => m.version > options.toVersion!);\n    }\n\n    for (const migration of migrationsToRollback) {\n      if (!migration.downSql?.length) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: 'No down migration available',\n          duration: 0,\n        });\n        break;\n      }\n\n      const startTime = Date.now();\n\n      if (options.dryRun) {\n        console.log(`[DRY RUN] Would rollback migration: ${migration.version}__${migration.name}`);\n        console.log(migration.downSql.join('\\n'));\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: 0,\n        });\n        continue;\n      }\n\n      try {\n        if (this.dialect.supportsTransactionalDDL) {\n          await this.driver.transaction(async (trx) => {\n            for (const sql of migration.downSql) {\n              await trx.execute(sql);\n            }\n            await this.removeMigrationRecord(trx, migration.version);\n          });\n        } else {\n          for (const sql of migration.downSql) {\n            await this.driver.execute(sql);\n          }\n          await this.removeMigrationRecord(this.driver, migration.version);\n        }\n\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: Date.now() - startTime,\n        });\n      } catch (error) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n        break;\n      }\n    }\n\n    return results;\n  }\n\n  async status(options: MigrationRunOptions = {}): Promise<MigrationStatus> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const pending = await this.getPendingMigrations(options);\n    const current = applied.length ? applied[applied.length - 1].version : null;\n\n    return { applied, pending, current };\n  }\n\n  async verify(options: MigrationRunOptions = {}): Promise<{ valid: boolean; issues: string[] }> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const files = await this.loadMigrationFiles(options);\n    const issues: string[] = [];\n\n    for (const record of applied) {\n      const file = files.find((f) => f.version === record.version);\n      if (!file) {\n        issues.push(`Migration ${record.version}__${record.name} was applied but file is missing`);\n        continue;\n      }\n\n      const fileChecksum = this.computeChecksum(file.up);\n      if (fileChecksum !== record.checksum) {\n        issues.push(\n          `Migration ${record.version}__${record.name} checksum mismatch. File has been modified after being applied.`\n        );\n      }\n    }\n\n    return { valid: issues.length === 0, issues };\n  }\n\n  private sanitizeTemplateKey(templateKey: string): string {\n    if (!/^[a-zA-Z0-9_-]+$/.test(templateKey)) {\n      throw new Error(\n        `Invalid templateKey: \"${templateKey}\". Only alphanumeric characters, hyphens, and underscores are allowed.`\n      );\n    }\n    return templateKey;\n  }\n\n  private async loadMigrationFiles(options: MigrationRunOptions = {}): Promise<MigrationFile[]> {\n    const scope = options.scope ?? 'core';\n    let dirPath: string;\n\n    if (scope === 'template' && options.templateKey) {\n      const sanitizedKey = this.sanitizeTemplateKey(options.templateKey);\n      dirPath = join(this.migrationsPath, 'templates', sanitizedKey);\n    } else {\n      dirPath = join(this.migrationsPath, 'core');\n    }\n\n    try {\n      const files = await readdir(dirPath);\n      const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();\n\n      const migrations: MigrationFile[] = [];\n\n      for (const file of sqlFiles) {\n        const content = await readFile(join(dirPath, file), 'utf-8');\n        const parsed = this.parseMigrationFile(file, content, scope, options.templateKey);\n        if (parsed) {\n          migrations.push(parsed);\n        }\n      }\n\n      return migrations;\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  private parseMigrationFile(\n    filename: string,\n    content: string,\n    scope: 'core' | 'template',\n    templateKey?: string\n  ): MigrationFile | null {\n    const match = filename.match(/^(\\d+)__(.+)\\.sql$/);\n    if (!match) return null;\n\n    const [, versionStr, name] = match;\n    const version = Number.parseInt(versionStr, 10);\n\n    const upMatch = content.match(/--\\s*up\\s*\\n([\\s\\S]*?)(?=--\\s*down|$)/i);\n    const downMatch = content.match(/--\\s*down\\s*\\n([\\s\\S]*?)$/i);\n\n    const up = upMatch ? this.splitSqlStatements(upMatch[1]) : [];\n    const down = downMatch ? this.splitSqlStatements(downMatch[1]) : [];\n\n    if (!up.length) return null;\n\n    return {\n      version,\n      name,\n      up,\n      down,\n      scope,\n      templateKey,\n    };\n  }\n\n  private async getAppliedMigrations(\n    options: MigrationRunOptions = {}\n  ): Promise<MigrationRecord[]> {\n    const scope = options.scope ?? 'core';\n    const templateKey = options.templateKey ?? null;\n    const moduleName = options.moduleName ?? null;\n\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT version, name, scope, template_key, module_name, checksum, up_sql, down_sql, applied_at, executed_by\n        FROM \"${this.tableName}\"\n        WHERE scope = $1 AND (template_key = $2 OR (template_key IS NULL AND $2 IS NULL))\n          AND (module_name = $3 OR (module_name IS NULL AND $3 IS NULL))\n        ORDER BY version ASC\n      `;\n      params = [scope, templateKey, moduleName];\n    } else {\n      sql = `\n        SELECT version, name, scope, template_key, module_name, checksum, up_sql, down_sql, applied_at, executed_by\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE scope = ? AND (template_key = ? OR (template_key IS NULL AND ? IS NULL))\n          AND (module_name = ? OR (module_name IS NULL AND ? IS NULL))\n        ORDER BY version ASC\n      `;\n      params = [scope, templateKey, templateKey, moduleName, moduleName];\n    }\n\n    const result = await this.driver.query<{\n      version: number;\n      name: string;\n      scope: 'core' | 'template';\n      template_key: string | null;\n      module_name: string | null;\n      checksum: string;\n      up_sql: string[] | string;\n      down_sql: string[] | string | null;\n      applied_at: Date | string;\n      executed_by: string | null;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      version: Number(row.version),\n      name: row.name,\n      scope: row.scope,\n      templateKey: row.template_key,\n      moduleName: row.module_name,\n      checksum: row.checksum,\n      upSql: typeof row.up_sql === 'string' ? JSON.parse(row.up_sql) : row.up_sql,\n      downSql: row.down_sql\n        ? typeof row.down_sql === 'string'\n          ? JSON.parse(row.down_sql)\n          : row.down_sql\n        : [],\n      appliedAt: new Date(row.applied_at),\n      executedBy: row.executed_by,\n    }));\n  }\n\n  private async getPendingMigrations(options: MigrationRunOptions = {}): Promise<MigrationFile[]> {\n    const files = await this.loadMigrationFiles(options);\n    const applied = await this.getAppliedMigrations(options);\n    const appliedVersions = new Set(applied.map((m) => m.version));\n\n    return files.filter((f) => !appliedVersions.has(f.version));\n  }\n\n  private async recordMigration(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    migration: MigrationFile\n  ): Promise<void> {\n    const checksum = this.computeChecksum(migration.up);\n\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          migration.up,\n          migration.down.length ? migration.down : null,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await client.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          JSON.stringify(migration.up),\n          migration.down.length ? JSON.stringify(migration.down) : null,\n        ]\n      );\n    } else {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          JSON.stringify(migration.up),\n          migration.down.length ? JSON.stringify(migration.down) : null,\n        ]\n      );\n    }\n  }\n\n  private async removeMigrationRecord(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    version: number\n  ): Promise<void> {\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(`DELETE FROM \"${this.tableName}\" WHERE version = $1`, [version]);\n    } else {\n      await client.execute(\n        `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE version = ?`,\n        [version]\n      );\n    }\n  }\n\n  private computeChecksum(statements: string[]): string {\n    return createHash('sha256').update(statements.join('\\n')).digest('hex');\n  }\n\n  private splitSqlStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inSingleQuote) {\n        current += char;\n        if (char === \"'\" && next !== \"'\") {\n          inSingleQuote = false;\n        } else if (char === \"'\" && next === \"'\") {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (inDoubleQuote) {\n        current += char;\n        if (char === '\"' && next !== '\"') {\n          inDoubleQuote = false;\n        } else if (char === '\"' && next === '\"') {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\") {\n        inSingleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '\"') {\n        inDoubleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n\nexport function createMigrationRunner(\n  driver: Driver,\n  options: MigrationRunnerOptions\n): MigrationRunner {\n  return new MigrationRunner(driver, options);\n}\n","import { readFile, readdir, stat } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { MigrationFile } from '../types/index.js';\nimport type { ModuleMigrationSource } from './types.js';\n\nexport interface MigrationCollectorOptions {\n  scope?: 'core' | 'template';\n}\n\nexport class MigrationCollector {\n  async discoverFromDirectory(basePath: string): Promise<ModuleMigrationSource[]> {\n    const sources: ModuleMigrationSource[] = [];\n\n    try {\n      const entries = await readdir(basePath);\n\n      for (const entry of entries) {\n        const entryPath = join(basePath, entry);\n        const entryStat = await stat(entryPath);\n\n        if (entryStat.isDirectory()) {\n          sources.push({\n            moduleName: entry,\n            migrationsPath: entryPath,\n          });\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n\n    return sources.sort((a, b) => a.moduleName.localeCompare(b.moduleName));\n  }\n\n  async collect(\n    sources: ModuleMigrationSource[],\n    options: MigrationCollectorOptions = {}\n  ): Promise<MigrationFile[]> {\n    const migrations: MigrationFile[] = [];\n\n    for (const source of sources) {\n      const sourceMigrations = await this.loadMigrationsFromSource(source, options);\n      migrations.push(...sourceMigrations);\n    }\n\n    return this.orderMigrations(migrations);\n  }\n\n  private async loadMigrationsFromSource(\n    source: ModuleMigrationSource,\n    options: MigrationCollectorOptions = {}\n  ): Promise<MigrationFile[]> {\n    const scope = options.scope ?? 'core';\n    const migrations: MigrationFile[] = [];\n\n    try {\n      const files = await readdir(source.migrationsPath);\n      const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();\n\n      for (const file of sqlFiles) {\n        const content = await readFile(join(source.migrationsPath, file), 'utf-8');\n        const parsed = this.parseMigrationFile(file, content, scope, source.moduleName);\n        if (parsed) {\n          migrations.push(parsed);\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n\n    return migrations;\n  }\n\n  private parseMigrationFile(\n    filename: string,\n    content: string,\n    scope: 'core' | 'template',\n    moduleName: string\n  ): MigrationFile | null {\n    const match = filename.match(/^(\\d+)__(.+)\\.sql$/);\n    if (!match) return null;\n\n    const [, versionStr, name] = match;\n    const version = Number.parseInt(versionStr, 10);\n\n    const upMatch = content.match(/--\\s*up\\s*\\n([\\s\\S]*?)(?=--\\s*down|$)/i);\n    const downMatch = content.match(/--\\s*down\\s*\\n([\\s\\S]*?)$/i);\n\n    const up = upMatch ? this.splitSqlStatements(upMatch[1]) : [];\n    const down = downMatch ? this.splitSqlStatements(downMatch[1]) : [];\n\n    if (!up.length) return null;\n\n    return {\n      version,\n      name,\n      up,\n      down,\n      scope,\n      moduleName,\n    };\n  }\n\n  private orderMigrations(migrations: MigrationFile[]): MigrationFile[] {\n    return migrations.sort((a, b) => {\n      if (a.version !== b.version) {\n        return a.version - b.version;\n      }\n      const moduleA = a.moduleName ?? '';\n      const moduleB = b.moduleName ?? '';\n      return moduleA.localeCompare(moduleB);\n    });\n  }\n\n  private splitSqlStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inSingleQuote) {\n        current += char;\n        if (char === \"'\" && next !== \"'\") {\n          inSingleQuote = false;\n        } else if (char === \"'\" && next === \"'\") {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (inDoubleQuote) {\n        current += char;\n        if (char === '\"' && next !== '\"') {\n          inDoubleQuote = false;\n        } else if (char === '\"' && next === '\"') {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\") {\n        inSingleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '\"') {\n        inDoubleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n\nexport function createMigrationCollector(): MigrationCollector {\n  return new MigrationCollector();\n}\n","import type { Driver } from '../driver/types.js';\nimport { getDialect } from '../migrations/dialects/index.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { ModuleDefinition } from './types.js';\n\nexport interface ModuleRegistryOptions {\n  tableName?: string;\n}\n\nexport class ModuleRegistry {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: ModuleRegistryOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_module_registry';\n  }\n\n  async ensureTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          name TEXT PRIMARY KEY,\n          display_name TEXT NOT NULL,\n          description TEXT,\n          version TEXT NOT NULL,\n          dependencies TEXT[] DEFAULT '{}',\n          migration_prefix TEXT NOT NULL UNIQUE,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW()\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            name VARCHAR(255) PRIMARY KEY,\n            display_name VARCHAR(255) NOT NULL,\n            description TEXT,\n            version VARCHAR(50) NOT NULL,\n            dependencies JSON DEFAULT ('[]'),\n            migration_prefix VARCHAR(255) NOT NULL UNIQUE,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            name TEXT PRIMARY KEY,\n            display_name TEXT NOT NULL,\n            description TEXT,\n            version TEXT NOT NULL,\n            dependencies TEXT DEFAULT '[]',\n            migration_prefix TEXT NOT NULL UNIQUE,\n            created_at TEXT DEFAULT (datetime('now')),\n            updated_at TEXT DEFAULT (datetime('now'))\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n  }\n\n  async register(module: ModuleDefinition): Promise<void> {\n    await this.ensureTable();\n\n    const dependencies = module.dependencies ?? [];\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES ($1, $2, $3, $4, $5, $6)\n        ON CONFLICT (name) DO UPDATE SET\n          display_name = EXCLUDED.display_name,\n          description = EXCLUDED.description,\n          version = EXCLUDED.version,\n          dependencies = EXCLUDED.dependencies,\n          migration_prefix = EXCLUDED.migration_prefix,\n          updated_at = NOW()\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          dependencies,\n          module.migrationPrefix,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES (?, ?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          display_name = VALUES(display_name),\n          description = VALUES(description),\n          version = VALUES(version),\n          dependencies = VALUES(dependencies),\n          migration_prefix = VALUES(migration_prefix)\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          JSON.stringify(dependencies),\n          module.migrationPrefix,\n        ]\n      );\n    } else {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES (?, ?, ?, ?, ?, ?)\n        ON CONFLICT (name) DO UPDATE SET\n          display_name = excluded.display_name,\n          description = excluded.description,\n          version = excluded.version,\n          dependencies = excluded.dependencies,\n          migration_prefix = excluded.migration_prefix,\n          updated_at = datetime('now')\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          JSON.stringify(dependencies),\n          module.migrationPrefix,\n        ]\n      );\n    }\n  }\n\n  async get(name: string): Promise<ModuleDefinition | null> {\n    await this.ensureTable();\n\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM \"${this.tableName}\"\n        WHERE name = $1\n      `;\n      params = [name];\n    } else {\n      sql = `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE name = ?\n      `;\n      params = [name];\n    }\n\n    const result = await this.driver.query<{\n      name: string;\n      display_name: string;\n      description: string | null;\n      version: string;\n      dependencies: string[] | string;\n      migration_prefix: string;\n    }>(sql, params);\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0];\n    return {\n      name: row.name,\n      displayName: row.display_name,\n      description: row.description ?? undefined,\n      version: row.version,\n      dependencies:\n        typeof row.dependencies === 'string' ? JSON.parse(row.dependencies) : row.dependencies,\n      migrationPrefix: row.migration_prefix,\n    };\n  }\n\n  async list(): Promise<ModuleDefinition[]> {\n    await this.ensureTable();\n\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM \"${this.tableName}\"\n        ORDER BY name ASC\n      `\n        : `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        ORDER BY name ASC\n      `;\n\n    const result = await this.driver.query<{\n      name: string;\n      display_name: string;\n      description: string | null;\n      version: string;\n      dependencies: string[] | string;\n      migration_prefix: string;\n    }>(sql);\n\n    return result.rows.map((row) => ({\n      name: row.name,\n      displayName: row.display_name,\n      description: row.description ?? undefined,\n      version: row.version,\n      dependencies:\n        typeof row.dependencies === 'string' ? JSON.parse(row.dependencies) : row.dependencies,\n      migrationPrefix: row.migration_prefix,\n    }));\n  }\n\n  async unregister(name: string): Promise<void> {\n    await this.ensureTable();\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(`DELETE FROM \"${this.tableName}\" WHERE name = $1`, [name]);\n    } else {\n      await this.driver.execute(\n        `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE name = ?`,\n        [name]\n      );\n    }\n  }\n}\n\nexport function createModuleRegistry(\n  driver: Driver,\n  options: ModuleRegistryOptions = {}\n): ModuleRegistry {\n  return new ModuleRegistry(driver, options);\n}\n","import { mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { homedir } from 'node:os';\nimport { dirname, join } from 'node:path';\nimport { AuthenticationError } from '../schema/types.js';\n\nexport interface Credentials {\n  token: string;\n  refreshToken?: string;\n  expiresAt?: string;\n  projectId?: string;\n}\n\nexport interface AuthConfig {\n  credentialsPath?: string;\n}\n\nconst DEFAULT_CREDENTIALS_PATH = join(homedir(), '.launchpad', 'credentials.json');\n\nexport class AuthHandler {\n  private credentialsPath: string;\n  private cachedCredentials: Credentials | null = null;\n\n  constructor(config: AuthConfig = {}) {\n    this.credentialsPath = config.credentialsPath ?? DEFAULT_CREDENTIALS_PATH;\n  }\n\n  async getToken(): Promise<string> {\n    const credentials = await this.loadCredentials();\n\n    if (!credentials?.token) {\n      throw new AuthenticationError(\n        'No authentication token found. Run `launchpad login` to authenticate.'\n      );\n    }\n\n    if (credentials.expiresAt) {\n      const expiresAt = new Date(credentials.expiresAt);\n      if (expiresAt <= new Date()) {\n        if (credentials.refreshToken) {\n          return this.refreshToken(credentials.refreshToken);\n        }\n        throw new AuthenticationError(\n          'Authentication token has expired. Run `launchpad login` to re-authenticate.'\n        );\n      }\n    }\n\n    return credentials.token;\n  }\n\n  async getProjectId(): Promise<string | undefined> {\n    const credentials = await this.loadCredentials();\n    return credentials?.projectId;\n  }\n\n  async saveCredentials(credentials: Credentials): Promise<void> {\n    await mkdir(dirname(this.credentialsPath), { recursive: true });\n    await writeFile(this.credentialsPath, JSON.stringify(credentials, null, 2), 'utf-8');\n    this.cachedCredentials = credentials;\n  }\n\n  async clearCredentials(): Promise<void> {\n    try {\n      await writeFile(this.credentialsPath, '{}', 'utf-8');\n      this.cachedCredentials = null;\n    } catch {}\n  }\n\n  async isAuthenticated(): Promise<boolean> {\n    try {\n      await this.getToken();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async loadCredentials(): Promise<Credentials | null> {\n    if (this.cachedCredentials) {\n      return this.cachedCredentials;\n    }\n\n    try {\n      const content = await readFile(this.credentialsPath, 'utf-8');\n      this.cachedCredentials = JSON.parse(content) as Credentials;\n      return this.cachedCredentials;\n    } catch {\n      return null;\n    }\n  }\n\n  private async refreshToken(_refreshToken: string): Promise<string> {\n    throw new AuthenticationError(\n      'Token refresh not implemented. Run `launchpad login` to re-authenticate.'\n    );\n  }\n}\n\nexport function createAuthHandler(config?: AuthConfig): AuthHandler {\n  return new AuthHandler(config);\n}\n","import type { SchemaDefinition } from '../types/index.js';\n\nexport interface IntrospectedColumn {\n  name: string;\n  dataType: string;\n  udtName: string;\n  isNullable: boolean;\n  defaultValue: string | null;\n  maxLength: number | null;\n  numericPrecision: number | null;\n  numericScale: number | null;\n  isIdentity: boolean;\n  identityGeneration: 'ALWAYS' | 'BY DEFAULT' | null;\n}\n\nexport interface IntrospectedIndex {\n  name: string;\n  columns: string[];\n  isUnique: boolean;\n  isPrimary: boolean;\n  type: 'btree' | 'hash' | 'gin' | 'gist' | 'brin';\n  expression: string | null;\n}\n\nexport interface IntrospectedForeignKey {\n  name: string;\n  columns: string[];\n  referencedTable: string;\n  referencedColumns: string[];\n  onDelete: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n  onUpdate: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n}\n\nexport interface IntrospectedConstraint {\n  name: string;\n  type: 'CHECK' | 'UNIQUE' | 'PRIMARY KEY' | 'FOREIGN KEY' | 'EXCLUDE';\n  definition: string;\n}\n\nexport interface IntrospectedTable {\n  name: string;\n  schema: string;\n  columns: IntrospectedColumn[];\n  primaryKey: string[];\n  foreignKeys: IntrospectedForeignKey[];\n  indexes: IntrospectedIndex[];\n  constraints: IntrospectedConstraint[];\n}\n\nexport interface IntrospectedEnum {\n  name: string;\n  values: string[];\n}\n\nexport interface SchemaIntrospectionResult {\n  tables: IntrospectedTable[];\n  enums: IntrospectedEnum[];\n  extensions: string[];\n  introspectedAt: Date;\n  databaseVersion: string;\n}\n\nexport interface IntrospectOptions {\n  schemaPattern?: string;\n  excludeTables?: string[];\n  includeLaunchpadTables?: boolean;\n}\n\nexport type ChangeType =\n  | 'table_add'\n  | 'table_drop'\n  | 'column_add'\n  | 'column_drop'\n  | 'column_modify'\n  | 'index_add'\n  | 'index_drop'\n  | 'constraint_add'\n  | 'constraint_drop'\n  | 'foreign_key_add'\n  | 'foreign_key_drop';\n\nexport interface SchemaChange {\n  type: ChangeType;\n  tableName: string;\n  objectName?: string;\n  isBreaking: boolean;\n  description: string;\n  upSql: string;\n  downSql: string;\n  oldValue?: unknown;\n  newValue?: unknown;\n}\n\nexport interface DiffSummary {\n  tablesAdded: number;\n  tablesDropped: number;\n  tablesModified: number;\n  columnsAdded: number;\n  columnsDropped: number;\n  columnsModified: number;\n  indexesAdded: number;\n  indexesDropped: number;\n  foreignKeysAdded: number;\n  foreignKeysDropped: number;\n}\n\nexport interface MigrationScript {\n  version: string;\n  name: string;\n  upSql: string[];\n  downSql: string[];\n  checksum: string;\n}\n\nexport interface SchemaSyncDiff {\n  hasDifferences: boolean;\n  summary: DiffSummary;\n  changes: SchemaChange[];\n  breakingChanges: SchemaChange[];\n  migration: MigrationScript | null;\n}\n\nexport interface SyncStatus {\n  appId: string;\n  tableName: string;\n  localChecksum: string | null;\n  localVersion: string | null;\n  localUpdatedAt: Date | null;\n  remoteChecksum: string | null;\n  remoteVersion: string | null;\n  remoteUpdatedAt: Date | null;\n  syncStatus: 'synced' | 'pending' | 'behind' | 'conflict' | 'unknown';\n  lastSyncAt: Date | null;\n  lastSyncDirection: 'push' | 'pull' | null;\n  lastSyncBy: string | null;\n  baseChecksum: string | null;\n  conflictDetails: Record<string, unknown> | null;\n}\n\nexport interface PullOptions {\n  environment?: string;\n  dryRun?: boolean;\n  force?: boolean;\n}\n\nexport interface PushOptions {\n  environment?: string;\n  dryRun?: boolean;\n  force?: boolean;\n}\n\nexport interface DiffOptions {\n  environment?: string;\n  outputFormat?: 'text' | 'json' | 'sql';\n}\n\nexport interface PullResult {\n  applied: boolean;\n  diff: SchemaSyncDiff;\n}\n\nexport interface PushResult {\n  applied: boolean;\n  diff: SchemaSyncDiff;\n  remoteResult?: RemotePushResult;\n}\n\nexport interface RemoteSchemaResponse {\n  schema: SchemaDefinition;\n  version: string;\n  checksum: string;\n  updatedAt: string;\n  environment: string;\n}\n\nexport interface RemotePushResult {\n  success: boolean;\n  applied: boolean;\n  migration?: MigrationScript;\n  errors?: string[];\n  warnings?: string[];\n}\n\nexport interface RemoteSyncStatus {\n  version: string;\n  checksum: string;\n  updatedAt: string;\n  environment: string;\n}\n\nexport class SchemaRemoteError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number\n  ) {\n    super(message);\n    this.name = 'SchemaRemoteError';\n  }\n}\n\nexport class BreakingChangeError extends Error {\n  constructor(\n    message: string,\n    public changes: SchemaChange[] = []\n  ) {\n    super(message);\n    this.name = 'BreakingChangeError';\n  }\n}\n\nexport class ConflictError extends Error {\n  constructor(\n    message: string,\n    public conflicts: SchemaChange[] = []\n  ) {\n    super(message);\n    this.name = 'ConflictError';\n  }\n}\n\nexport class AuthenticationError extends Error {\n  constructor(message = 'Authentication failed. Run `launchpad login` to authenticate.') {\n    super(message);\n    this.name = 'AuthenticationError';\n  }\n}\n\nexport class UserCancelledError extends Error {\n  constructor(message = 'Operation cancelled by user.') {\n    super(message);\n    this.name = 'UserCancelledError';\n  }\n}\n","import type { MigrationScript } from '../schema/types.js';\nimport { AuthenticationError, SchemaRemoteError } from '../schema/types.js';\nimport type {\n  RemoteConfig,\n  RemoteHealthResponse,\n  RemotePushOptions,\n  RemotePushResult,\n  RemoteSchemaResponse,\n  RemoteSyncStatus,\n} from './types.js';\n\nexport interface SchemaRemoteClientOptions {\n  timeout?: number;\n  retries?: number;\n}\n\nexport class SchemaRemoteClient {\n  private apiUrl: string;\n  private projectId: string;\n  private authToken: string;\n  private timeout: number;\n  private retries: number;\n\n  private schemaCache: Map<string, { schema: RemoteSchemaResponse; cachedAt: number }> = new Map();\n  private readonly CACHE_TTL = 5 * 60 * 1000;\n\n  constructor(config: RemoteConfig, options: SchemaRemoteClientOptions = {}) {\n    this.apiUrl = config.apiUrl.replace(/\\/$/, '');\n    this.projectId = config.projectId;\n    this.authToken = config.authToken;\n    this.timeout = options.timeout ?? 30000;\n    this.retries = options.retries ?? 3;\n  }\n\n  async fetchSchema(environment = 'production'): Promise<RemoteSchemaResponse> {\n    const cacheKey = `${this.projectId}-${environment}`;\n    const cached = this.schemaCache.get(cacheKey);\n\n    if (cached && Date.now() - cached.cachedAt < this.CACHE_TTL) {\n      return cached.schema;\n    }\n\n    const response = await this.request<RemoteSchemaResponse>(\n      'GET',\n      `/v1/projects/${this.projectId}/schema`,\n      undefined,\n      { 'X-Environment': environment }\n    );\n\n    this.schemaCache.set(cacheKey, {\n      schema: response,\n      cachedAt: Date.now(),\n    });\n\n    return response;\n  }\n\n  async pushMigration(\n    migration: MigrationScript,\n    options: RemotePushOptions = {}\n  ): Promise<RemotePushResult> {\n    const environment = options.environment ?? 'production';\n\n    this.schemaCache.delete(`${this.projectId}-${environment}`);\n\n    return this.request<RemotePushResult>(\n      'POST',\n      `/v1/projects/${this.projectId}/schema/migrations`,\n      {\n        migration,\n        dryRun: options.dryRun ?? false,\n        force: options.force ?? false,\n      },\n      { 'X-Environment': environment }\n    );\n  }\n\n  async getSyncStatus(environment = 'production'): Promise<RemoteSyncStatus> {\n    return this.request<RemoteSyncStatus>(\n      'GET',\n      `/v1/projects/${this.projectId}/schema/sync-status`,\n      undefined,\n      { 'X-Environment': environment }\n    );\n  }\n\n  async healthCheck(): Promise<RemoteHealthResponse> {\n    return this.request<RemoteHealthResponse>('GET', '/v1/health');\n  }\n\n  clearCache(): void {\n    this.schemaCache.clear();\n  }\n\n  private async request<T>(\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    path: string,\n    body?: unknown,\n    additionalHeaders?: Record<string, string>\n  ): Promise<T> {\n    const url = `${this.apiUrl}${path}`;\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${this.authToken}`,\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n      ...additionalHeaders,\n    };\n\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt < this.retries; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n        const response = await fetch(url, {\n          method,\n          headers,\n          body: body ? JSON.stringify(body) : undefined,\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          if (response.status === 401) {\n            throw new AuthenticationError('Invalid or expired authentication token.');\n          }\n\n          if (response.status === 403) {\n            throw new SchemaRemoteError('Permission denied. Check your API key permissions.', 403);\n          }\n\n          if (response.status === 404) {\n            throw new SchemaRemoteError(`Project not found: ${this.projectId}`, 404);\n          }\n\n          if (response.status >= 500 && attempt < this.retries - 1) {\n            await this.delay(2 ** attempt * 1000);\n            continue;\n          }\n\n          const errorBody = await response.text();\n          let errorMessage: string;\n\n          try {\n            const parsed = JSON.parse(errorBody);\n            errorMessage = parsed.message || parsed.error || errorBody;\n          } catch {\n            errorMessage = errorBody || response.statusText;\n          }\n\n          throw new SchemaRemoteError(errorMessage, response.status);\n        }\n\n        return (await response.json()) as T;\n      } catch (error) {\n        if (error instanceof AuthenticationError || error instanceof SchemaRemoteError) {\n          throw error;\n        }\n\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (error instanceof Error && error.name === 'AbortError') {\n          lastError = new SchemaRemoteError(`Request timeout after ${this.timeout}ms`);\n        }\n\n        if (attempt < this.retries - 1) {\n          await this.delay(2 ** attempt * 1000);\n        }\n      }\n    }\n\n    throw lastError ?? new SchemaRemoteError('Request failed after retries');\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\nexport function createSchemaRemoteClient(\n  config: RemoteConfig,\n  options?: SchemaRemoteClientOptions\n): SchemaRemoteClient {\n  return new SchemaRemoteClient(config, options);\n}\n","import { createHash } from 'node:crypto';\nimport type { Driver } from '../driver/types.js';\nimport { type Dialect, getDialect } from '../migrations/dialects/index.js';\nimport type { MigrationResult, SchemaDefinition, TableDefinition } from '../types/index.js';\n\nexport interface SchemaRegistryOptions {\n  tableName?: string;\n}\n\nexport interface RegisterSchemaOptions {\n  appId: string;\n  schemaName: string;\n  version: string;\n  schema: SchemaDefinition;\n}\n\nexport interface SchemaRecord {\n  app_id: string;\n  schema_name: string;\n  version: string;\n  schema: SchemaDefinition;\n  checksum: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport class SchemaRegistry {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: SchemaRegistryOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_schema_registry';\n  }\n\n  async ensureRegistryTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          app_id TEXT NOT NULL,\n          schema_name TEXT NOT NULL,\n          version TEXT NOT NULL,\n          schema JSONB NOT NULL,\n          checksum TEXT NOT NULL,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW(),\n          PRIMARY KEY (app_id, schema_name)\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            app_id VARCHAR(255) NOT NULL,\n            schema_name VARCHAR(255) NOT NULL,\n            version VARCHAR(50) NOT NULL,\n            schema JSON NOT NULL,\n            checksum VARCHAR(64) NOT NULL,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            PRIMARY KEY (app_id, schema_name)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            app_id TEXT NOT NULL,\n            schema_name TEXT NOT NULL,\n            version TEXT NOT NULL,\n            schema TEXT NOT NULL,\n            checksum TEXT NOT NULL,\n            created_at TEXT DEFAULT (datetime('now')),\n            updated_at TEXT DEFAULT (datetime('now')),\n            PRIMARY KEY (app_id, schema_name)\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n  }\n\n  async register(options: RegisterSchemaOptions): Promise<MigrationResult[]> {\n    await this.ensureRegistryTable();\n\n    this.validateSchema(options.schema);\n\n    const current = await this.getCurrentSchema(options.appId, options.schemaName);\n    const diff = this.computeDiff(current?.schema ?? null, options.schema);\n\n    if (diff.length === 0) {\n      return [];\n    }\n\n    const results: MigrationResult[] = [];\n    const checksum = this.computeChecksum(options.schema);\n\n    if (this.dialect.supportsTransactionalDDL) {\n      await this.driver.transaction(async (trx) => {\n        for (const change of diff) {\n          const startTime = Date.now();\n          try {\n            await trx.execute(change.sql);\n            results.push({\n              version: Date.now(),\n              name: change.description,\n              success: true,\n              duration: Date.now() - startTime,\n            });\n          } catch (error) {\n            results.push({\n              version: Date.now(),\n              name: change.description,\n              success: false,\n              error: error instanceof Error ? error.message : String(error),\n              duration: Date.now() - startTime,\n            });\n            throw error;\n          }\n        }\n\n        await this.upsertSchemaRecord(trx, {\n          appId: options.appId,\n          schemaName: options.schemaName,\n          version: options.version,\n          schema: options.schema,\n          checksum,\n        });\n      });\n    } else {\n      for (const change of diff) {\n        const startTime = Date.now();\n        try {\n          await this.driver.execute(change.sql);\n          results.push({\n            version: Date.now(),\n            name: change.description,\n            success: true,\n            duration: Date.now() - startTime,\n          });\n        } catch (error) {\n          results.push({\n            version: Date.now(),\n            name: change.description,\n            success: false,\n            error: error instanceof Error ? error.message : String(error),\n            duration: Date.now() - startTime,\n          });\n          throw error;\n        }\n      }\n\n      await this.upsertSchemaRecord(this.driver, {\n        appId: options.appId,\n        schemaName: options.schemaName,\n        version: options.version,\n        schema: options.schema,\n        checksum,\n      });\n    }\n\n    return results;\n  }\n\n  async getCurrentSchema(appId: string, schemaName: string): Promise<SchemaRecord | null> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT app_id, schema_name, version, schema, checksum, created_at, updated_at\n        FROM \"${this.tableName}\"\n        WHERE app_id = $1 AND schema_name = $2\n      `;\n      params = [appId, schemaName];\n    } else {\n      sql = `\n        SELECT app_id, schema_name, version, schema, checksum, created_at, updated_at\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE app_id = ? AND schema_name = ?\n      `;\n      params = [appId, schemaName];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      schema_name: string;\n      version: string;\n      schema: SchemaDefinition | string;\n      checksum: string;\n      created_at: Date | string;\n      updated_at: Date | string;\n    }>(sql, params);\n\n    if (!result.rows.length) return null;\n\n    const row = result.rows[0];\n    return {\n      app_id: row.app_id,\n      schema_name: row.schema_name,\n      version: row.version,\n      schema: typeof row.schema === 'string' ? JSON.parse(row.schema) : row.schema,\n      checksum: row.checksum,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    };\n  }\n\n  async listSchemas(appId?: string): Promise<SchemaRecord[]> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = appId\n        ? `SELECT * FROM \"${this.tableName}\" WHERE app_id = $1 ORDER BY schema_name`\n        : `SELECT * FROM \"${this.tableName}\" ORDER BY app_id, schema_name`;\n      params = appId ? [appId] : [];\n    } else {\n      const table = this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`;\n      sql = appId\n        ? `SELECT * FROM ${table} WHERE app_id = ? ORDER BY schema_name`\n        : `SELECT * FROM ${table} ORDER BY app_id, schema_name`;\n      params = appId ? [appId] : [];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      schema_name: string;\n      version: string;\n      schema: SchemaDefinition | string;\n      checksum: string;\n      created_at: Date | string;\n      updated_at: Date | string;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      app_id: row.app_id,\n      schema_name: row.schema_name,\n      version: row.version,\n      schema: typeof row.schema === 'string' ? JSON.parse(row.schema) : row.schema,\n      checksum: row.checksum,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n  }\n\n  private validateSchema(schema: SchemaDefinition): void {\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      if (!table.columns.app_id) {\n        throw new Error(`Table \"${tableName}\" must have an \"app_id\" column for multi-tenancy`);\n      }\n      if (!table.columns.organization_id) {\n        throw new Error(\n          `Table \"${tableName}\" must have an \"organization_id\" column for multi-tenancy`\n        );\n      }\n      if (!table.columns.id) {\n        throw new Error(`Table \"${tableName}\" must have an \"id\" column`);\n      }\n\n      const appIdCol = table.columns.app_id;\n      const orgIdCol = table.columns.organization_id;\n\n      if (!appIdCol.tenant) {\n        throw new Error(`Column \"app_id\" in table \"${tableName}\" must be marked as tenant column`);\n      }\n      if (!orgIdCol.tenant) {\n        throw new Error(\n          `Column \"organization_id\" in table \"${tableName}\" must be marked as tenant column`\n        );\n      }\n    }\n  }\n\n  private computeDiff(\n    current: SchemaDefinition | null,\n    desired: SchemaDefinition\n  ): Array<{ sql: string; description: string }> {\n    const changes: Array<{ sql: string; description: string }> = [];\n\n    for (const [tableName, desiredTable] of Object.entries(desired.tables)) {\n      const currentTable = current?.tables[tableName];\n\n      if (!currentTable) {\n        const sql = this.dialect.createTable(tableName, desiredTable);\n        changes.push({ sql, description: `Create table ${tableName}` });\n\n        if (desiredTable.indexes) {\n          for (const index of desiredTable.indexes) {\n            const indexSql = this.dialect.createIndex(tableName, index);\n            changes.push({\n              sql: indexSql,\n              description: `Create index on ${tableName}(${index.columns.join(', ')})`,\n            });\n          }\n        }\n\n        continue;\n      }\n\n      for (const [colName, desiredCol] of Object.entries(desiredTable.columns)) {\n        const currentCol = currentTable.columns[colName];\n\n        if (!currentCol) {\n          const sql = this.dialect.addColumn(tableName, colName, desiredCol);\n          changes.push({ sql, description: `Add column ${tableName}.${colName}` });\n        } else if (!this.columnsEqual(currentCol, desiredCol)) {\n          try {\n            const sql = this.dialect.alterColumn(tableName, colName, desiredCol);\n            changes.push({ sql, description: `Alter column ${tableName}.${colName}` });\n          } catch (error) {\n            console.warn(`Cannot alter column ${tableName}.${colName}: ${error}`);\n          }\n        }\n      }\n\n      for (const colName of Object.keys(currentTable.columns)) {\n        if (!desiredTable.columns[colName]) {\n          try {\n            const sql = this.dialect.dropColumn(tableName, colName);\n            changes.push({ sql, description: `Drop column ${tableName}.${colName}` });\n          } catch (error) {\n            console.warn(`Cannot drop column ${tableName}.${colName}: ${error}`);\n          }\n        }\n      }\n    }\n\n    if (current) {\n      for (const tableName of Object.keys(current.tables)) {\n        if (!desired.tables[tableName]) {\n          const sql = this.dialect.dropTable(tableName);\n          changes.push({ sql, description: `Drop table ${tableName}` });\n        }\n      }\n    }\n\n    return changes;\n  }\n\n  private columnsEqual(\n    a: TableDefinition['columns'][string],\n    b: TableDefinition['columns'][string]\n  ): boolean {\n    return (\n      a.type === b.type &&\n      a.nullable === b.nullable &&\n      a.unique === b.unique &&\n      a.default === b.default &&\n      JSON.stringify(a.references) === JSON.stringify(b.references)\n    );\n  }\n\n  private async upsertSchemaRecord(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    data: {\n      appId: string;\n      schemaName: string;\n      version: string;\n      schema: SchemaDefinition;\n      checksum: string;\n    }\n  ): Promise<void> {\n    const schemaJson = JSON.stringify(data.schema);\n\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (app_id, schema_name, version, schema, checksum)\n        VALUES ($1, $2, $3, $4, $5)\n        ON CONFLICT (app_id, schema_name) DO UPDATE SET\n          version = EXCLUDED.version,\n          schema = EXCLUDED.schema,\n          checksum = EXCLUDED.checksum,\n          updated_at = NOW()\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await client.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (app_id, schema_name, version, schema, checksum)\n        VALUES (?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          version = VALUES(version),\n          schema = VALUES(schema),\n          checksum = VALUES(checksum)\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    } else {\n      await client.execute(\n        `\n        INSERT OR REPLACE INTO \"${this.tableName}\" (app_id, schema_name, version, schema, checksum, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, datetime('now'), datetime('now'))\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    }\n  }\n\n  private computeChecksum(schema: SchemaDefinition): string {\n    return createHash('sha256').update(JSON.stringify(schema)).digest('hex');\n  }\n}\n\nexport function createSchemaRegistry(\n  driver: Driver,\n  options?: SchemaRegistryOptions\n): SchemaRegistry {\n  return new SchemaRegistry(driver, options);\n}\n","import type { Driver } from '../driver/types.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type {\n  ColumnDefinition,\n  ColumnType,\n  SchemaDefinition,\n  TableDefinition,\n} from '../types/index.js';\nimport type {\n  IntrospectOptions,\n  IntrospectedColumn,\n  IntrospectedConstraint,\n  IntrospectedEnum,\n  IntrospectedForeignKey,\n  IntrospectedIndex,\n  IntrospectedTable,\n  SchemaIntrospectionResult,\n} from './types.js';\n\nexport class SchemaIntrospector {\n  constructor(\n    private driver: Driver,\n    private dialect: Dialect\n  ) {}\n\n  async introspect(options: IntrospectOptions = {}): Promise<SchemaIntrospectionResult> {\n    const tables = await this.introspectTables(options);\n    const enums = await this.introspectEnums();\n    const extensions = await this.introspectExtensions();\n    const databaseVersion = await this.getDatabaseVersion();\n\n    return {\n      tables,\n      enums,\n      extensions,\n      introspectedAt: new Date(),\n      databaseVersion,\n    };\n  }\n\n  async introspectTables(options: IntrospectOptions = {}): Promise<IntrospectedTable[]> {\n    const tableNames = await this.listTables(options);\n    const tables: IntrospectedTable[] = [];\n\n    for (const tableName of tableNames) {\n      const table = await this.introspectTable(tableName);\n      tables.push(table);\n    }\n\n    return tables;\n  }\n\n  async listTables(options: IntrospectOptions = {}): Promise<string[]> {\n    const excludePatterns = options.includeLaunchpadTables ? [] : ['lp_%', 'pg_%', 'sql_%'];\n    const additionalExcludes = options.excludeTables ?? [];\n\n    let sql: string;\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT table_name\n        FROM information_schema.tables\n        WHERE table_schema = 'public'\n          AND table_type = 'BASE TABLE'\n        ORDER BY table_name\n      `;\n    } else if (this.dialect.name === 'mysql') {\n      sql = `\n        SELECT table_name\n        FROM information_schema.tables\n        WHERE table_schema = DATABASE()\n          AND table_type = 'BASE TABLE'\n        ORDER BY table_name\n      `;\n    } else {\n      sql = `\n        SELECT name as table_name\n        FROM sqlite_master\n        WHERE type = 'table'\n          AND name NOT LIKE 'sqlite_%'\n        ORDER BY name\n      `;\n    }\n\n    const result = await this.driver.query<{ table_name: string }>(sql);\n\n    return result.rows\n      .map((row) => row.table_name)\n      .filter((name) => {\n        for (const pattern of excludePatterns) {\n          if (pattern.endsWith('%')) {\n            const prefix = pattern.slice(0, -1);\n            if (name.startsWith(prefix)) return false;\n          } else if (name === pattern) {\n            return false;\n          }\n        }\n        for (const exclude of additionalExcludes) {\n          if (name === exclude) return false;\n        }\n        return true;\n      });\n  }\n\n  async introspectTable(tableName: string): Promise<IntrospectedTable> {\n    const [columns, indexes, foreignKeys, constraints] = await Promise.all([\n      this.introspectColumns(tableName),\n      this.introspectIndexes(tableName),\n      this.introspectForeignKeys(tableName),\n      this.introspectConstraints(tableName),\n    ]);\n\n    const primaryKey = this.extractPrimaryKey(indexes);\n\n    return {\n      name: tableName,\n      schema: 'public',\n      columns,\n      primaryKey,\n      foreignKeys,\n      indexes: indexes.filter((i) => !i.isPrimary),\n      constraints,\n    };\n  }\n\n  async introspectColumns(tableName: string): Promise<IntrospectedColumn[]> {\n    if (this.dialect.name === 'postgresql') {\n      return this.introspectPostgresColumns(tableName);\n    }\n    if (this.dialect.name === 'mysql') {\n      return this.introspectMysqlColumns(tableName);\n    }\n    return this.introspectSqliteColumns(tableName);\n  }\n\n  private async introspectPostgresColumns(tableName: string): Promise<IntrospectedColumn[]> {\n    const sql = `\n      SELECT\n        column_name,\n        data_type,\n        udt_name,\n        is_nullable,\n        column_default,\n        character_maximum_length,\n        numeric_precision,\n        numeric_scale,\n        is_identity,\n        identity_generation\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = $1\n      ORDER BY ordinal_position\n    `;\n\n    const result = await this.driver.query<{\n      column_name: string;\n      data_type: string;\n      udt_name: string;\n      is_nullable: string;\n      column_default: string | null;\n      character_maximum_length: number | null;\n      numeric_precision: number | null;\n      numeric_scale: number | null;\n      is_identity: string;\n      identity_generation: string | null;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.column_name,\n      dataType: row.data_type,\n      udtName: row.udt_name,\n      isNullable: row.is_nullable === 'YES',\n      defaultValue: row.column_default,\n      maxLength: row.character_maximum_length,\n      numericPrecision: row.numeric_precision,\n      numericScale: row.numeric_scale,\n      isIdentity: row.is_identity === 'YES',\n      identityGeneration: row.identity_generation as 'ALWAYS' | 'BY DEFAULT' | null,\n    }));\n  }\n\n  private async introspectMysqlColumns(tableName: string): Promise<IntrospectedColumn[]> {\n    const sql = `\n      SELECT\n        column_name,\n        data_type,\n        column_type as udt_name,\n        is_nullable,\n        column_default,\n        character_maximum_length,\n        numeric_precision,\n        numeric_scale,\n        extra\n      FROM information_schema.columns\n      WHERE table_schema = DATABASE()\n        AND table_name = ?\n      ORDER BY ordinal_position\n    `;\n\n    const result = await this.driver.query<{\n      column_name: string;\n      data_type: string;\n      udt_name: string;\n      is_nullable: string;\n      column_default: string | null;\n      character_maximum_length: number | null;\n      numeric_precision: number | null;\n      numeric_scale: number | null;\n      extra: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.column_name,\n      dataType: row.data_type,\n      udtName: row.udt_name,\n      isNullable: row.is_nullable === 'YES',\n      defaultValue: row.column_default,\n      maxLength: row.character_maximum_length,\n      numericPrecision: row.numeric_precision,\n      numericScale: row.numeric_scale,\n      isIdentity: row.extra.includes('auto_increment'),\n      identityGeneration: row.extra.includes('auto_increment') ? 'ALWAYS' : null,\n    }));\n  }\n\n  private async introspectSqliteColumns(tableName: string): Promise<IntrospectedColumn[]> {\n    const sql = `PRAGMA table_info(\"${tableName}\")`;\n\n    const result = await this.driver.query<{\n      cid: number;\n      name: string;\n      type: string;\n      notnull: number;\n      dflt_value: string | null;\n      pk: number;\n    }>(sql);\n\n    return result.rows.map((row) => ({\n      name: row.name,\n      dataType: row.type.toLowerCase(),\n      udtName: row.type.toLowerCase(),\n      isNullable: row.notnull === 0,\n      defaultValue: row.dflt_value,\n      maxLength: null,\n      numericPrecision: null,\n      numericScale: null,\n      isIdentity: row.pk === 1 && row.type.toLowerCase() === 'integer',\n      identityGeneration: row.pk === 1 && row.type.toLowerCase() === 'integer' ? 'ALWAYS' : null,\n    }));\n  }\n\n  async introspectIndexes(tableName: string): Promise<IntrospectedIndex[]> {\n    if (this.dialect.name === 'postgresql') {\n      return this.introspectPostgresIndexes(tableName);\n    }\n    if (this.dialect.name === 'mysql') {\n      return this.introspectMysqlIndexes(tableName);\n    }\n    return this.introspectSqliteIndexes(tableName);\n  }\n\n  private async introspectPostgresIndexes(tableName: string): Promise<IntrospectedIndex[]> {\n    const sql = `\n      SELECT\n        i.relname AS index_name,\n        array_agg(a.attname ORDER BY array_position(ix.indkey, a.attnum)) AS columns,\n        ix.indisunique AS is_unique,\n        ix.indisprimary AS is_primary,\n        am.amname AS index_type,\n        pg_get_expr(ix.indexprs, ix.indrelid) AS expression\n      FROM pg_index ix\n      JOIN pg_class i ON ix.indexrelid = i.oid\n      JOIN pg_class t ON ix.indrelid = t.oid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      JOIN pg_am am ON i.relam = am.oid\n      WHERE t.relname = $1\n        AND t.relnamespace = 'public'::regnamespace\n      GROUP BY i.relname, ix.indisunique, ix.indisprimary, am.amname, ix.indexprs, ix.indrelid\n    `;\n\n    const result = await this.driver.query<{\n      index_name: string;\n      columns: string[];\n      is_unique: boolean;\n      is_primary: boolean;\n      index_type: string;\n      expression: string | null;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.index_name,\n      columns: row.columns,\n      isUnique: row.is_unique,\n      isPrimary: row.is_primary,\n      type: row.index_type as IntrospectedIndex['type'],\n      expression: row.expression,\n    }));\n  }\n\n  private async introspectMysqlIndexes(tableName: string): Promise<IntrospectedIndex[]> {\n    const sql = `\n      SELECT\n        index_name,\n        GROUP_CONCAT(column_name ORDER BY seq_in_index) as columns,\n        NOT non_unique as is_unique,\n        index_name = 'PRIMARY' as is_primary,\n        index_type\n      FROM information_schema.statistics\n      WHERE table_schema = DATABASE()\n        AND table_name = ?\n      GROUP BY index_name, non_unique, index_type\n    `;\n\n    const result = await this.driver.query<{\n      index_name: string;\n      columns: string;\n      is_unique: boolean;\n      is_primary: boolean;\n      index_type: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.index_name,\n      columns: row.columns.split(','),\n      isUnique: row.is_unique,\n      isPrimary: row.is_primary,\n      type: row.index_type.toLowerCase() as IntrospectedIndex['type'],\n      expression: null,\n    }));\n  }\n\n  private async introspectSqliteIndexes(tableName: string): Promise<IntrospectedIndex[]> {\n    const indexListSql = `PRAGMA index_list(\"${tableName}\")`;\n    const indexList = await this.driver.query<{\n      seq: number;\n      name: string;\n      unique: number;\n      origin: string;\n      partial: number;\n    }>(indexListSql);\n\n    const indexes: IntrospectedIndex[] = [];\n\n    for (const idx of indexList.rows) {\n      const indexInfoSql = `PRAGMA index_info(\"${idx.name}\")`;\n      const indexInfo = await this.driver.query<{\n        seqno: number;\n        cid: number;\n        name: string;\n      }>(indexInfoSql);\n\n      indexes.push({\n        name: idx.name,\n        columns: indexInfo.rows.map((row) => row.name),\n        isUnique: idx.unique === 1,\n        isPrimary: idx.origin === 'pk',\n        type: 'btree',\n        expression: null,\n      });\n    }\n\n    return indexes;\n  }\n\n  async introspectForeignKeys(tableName: string): Promise<IntrospectedForeignKey[]> {\n    if (this.dialect.name === 'postgresql') {\n      return this.introspectPostgresForeignKeys(tableName);\n    }\n    if (this.dialect.name === 'mysql') {\n      return this.introspectMysqlForeignKeys(tableName);\n    }\n    return this.introspectSqliteForeignKeys(tableName);\n  }\n\n  private async introspectPostgresForeignKeys(\n    tableName: string\n  ): Promise<IntrospectedForeignKey[]> {\n    const sql = `\n      SELECT\n        tc.constraint_name,\n        array_agg(kcu.column_name ORDER BY kcu.ordinal_position) AS columns,\n        ccu.table_name AS referenced_table,\n        array_agg(ccu.column_name ORDER BY kcu.ordinal_position) AS referenced_columns,\n        rc.delete_rule AS on_delete,\n        rc.update_rule AS on_update\n      FROM information_schema.table_constraints tc\n      JOIN information_schema.key_column_usage kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      JOIN information_schema.constraint_column_usage ccu\n        ON ccu.constraint_name = tc.constraint_name\n        AND ccu.table_schema = tc.table_schema\n      JOIN information_schema.referential_constraints rc\n        ON rc.constraint_name = tc.constraint_name\n        AND rc.constraint_schema = tc.table_schema\n      WHERE tc.table_name = $1\n        AND tc.table_schema = 'public'\n        AND tc.constraint_type = 'FOREIGN KEY'\n      GROUP BY tc.constraint_name, ccu.table_name, rc.delete_rule, rc.update_rule\n    `;\n\n    const result = await this.driver.query<{\n      constraint_name: string;\n      columns: string[];\n      referenced_table: string;\n      referenced_columns: string[];\n      on_delete: string;\n      on_update: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.constraint_name,\n      columns: row.columns,\n      referencedTable: row.referenced_table,\n      referencedColumns: row.referenced_columns,\n      onDelete: row.on_delete as IntrospectedForeignKey['onDelete'],\n      onUpdate: row.on_update as IntrospectedForeignKey['onUpdate'],\n    }));\n  }\n\n  private async introspectMysqlForeignKeys(tableName: string): Promise<IntrospectedForeignKey[]> {\n    const sql = `\n      SELECT\n        constraint_name,\n        GROUP_CONCAT(column_name ORDER BY ordinal_position) as columns,\n        referenced_table_name as referenced_table,\n        GROUP_CONCAT(referenced_column_name ORDER BY ordinal_position) as referenced_columns\n      FROM information_schema.key_column_usage\n      WHERE table_schema = DATABASE()\n        AND table_name = ?\n        AND referenced_table_name IS NOT NULL\n      GROUP BY constraint_name, referenced_table_name\n    `;\n\n    const result = await this.driver.query<{\n      constraint_name: string;\n      columns: string;\n      referenced_table: string;\n      referenced_columns: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.constraint_name,\n      columns: row.columns.split(','),\n      referencedTable: row.referenced_table,\n      referencedColumns: row.referenced_columns.split(','),\n      onDelete: 'NO ACTION' as const,\n      onUpdate: 'NO ACTION' as const,\n    }));\n  }\n\n  private async introspectSqliteForeignKeys(tableName: string): Promise<IntrospectedForeignKey[]> {\n    const sql = `PRAGMA foreign_key_list(\"${tableName}\")`;\n\n    const result = await this.driver.query<{\n      id: number;\n      seq: number;\n      table: string;\n      from: string;\n      to: string;\n      on_update: string;\n      on_delete: string;\n      match: string;\n    }>(sql);\n\n    const fkMap = new Map<number, IntrospectedForeignKey>();\n\n    for (const row of result.rows) {\n      if (!fkMap.has(row.id)) {\n        fkMap.set(row.id, {\n          name: `fk_${tableName}_${row.id}`,\n          columns: [],\n          referencedTable: row.table,\n          referencedColumns: [],\n          onDelete: row.on_delete.replace(' ', '_') as IntrospectedForeignKey['onDelete'],\n          onUpdate: row.on_update.replace(' ', '_') as IntrospectedForeignKey['onUpdate'],\n        });\n      }\n      const fk = fkMap.get(row.id)!;\n      fk.columns.push(row.from);\n      fk.referencedColumns.push(row.to);\n    }\n\n    return Array.from(fkMap.values());\n  }\n\n  async introspectConstraints(tableName: string): Promise<IntrospectedConstraint[]> {\n    if (this.dialect.name !== 'postgresql') {\n      return [];\n    }\n\n    const sql = `\n      SELECT\n        con.conname AS constraint_name,\n        CASE con.contype\n          WHEN 'c' THEN 'CHECK'\n          WHEN 'u' THEN 'UNIQUE'\n          WHEN 'p' THEN 'PRIMARY KEY'\n          WHEN 'f' THEN 'FOREIGN KEY'\n          WHEN 'x' THEN 'EXCLUDE'\n        END AS constraint_type,\n        pg_get_constraintdef(con.oid) AS definition\n      FROM pg_constraint con\n      JOIN pg_class rel ON rel.oid = con.conrelid\n      JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace\n      WHERE rel.relname = $1\n        AND nsp.nspname = 'public'\n        AND con.contype = 'c'\n    `;\n\n    const result = await this.driver.query<{\n      constraint_name: string;\n      constraint_type: string;\n      definition: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.constraint_name,\n      type: row.constraint_type as IntrospectedConstraint['type'],\n      definition: row.definition,\n    }));\n  }\n\n  async introspectEnums(): Promise<IntrospectedEnum[]> {\n    if (this.dialect.name !== 'postgresql') {\n      return [];\n    }\n\n    const sql = `\n      SELECT\n        t.typname AS name,\n        array_agg(e.enumlabel ORDER BY e.enumsortorder) AS values\n      FROM pg_type t\n      JOIN pg_enum e ON t.oid = e.enumtypid\n      JOIN pg_namespace n ON t.typnamespace = n.oid\n      WHERE n.nspname = 'public'\n      GROUP BY t.typname\n    `;\n\n    const result = await this.driver.query<{\n      name: string;\n      values: string[];\n    }>(sql);\n\n    return result.rows;\n  }\n\n  async introspectExtensions(): Promise<string[]> {\n    if (this.dialect.name !== 'postgresql') {\n      return [];\n    }\n\n    const sql = `SELECT extname FROM pg_extension WHERE extname != 'plpgsql'`;\n    const result = await this.driver.query<{ extname: string }>(sql);\n    return result.rows.map((row) => row.extname);\n  }\n\n  async getDatabaseVersion(): Promise<string> {\n    if (this.dialect.name === 'postgresql') {\n      const result = await this.driver.query<{ version: string }>('SELECT version()');\n      return result.rows[0]?.version ?? 'unknown';\n    }\n    if (this.dialect.name === 'mysql') {\n      const result = await this.driver.query<{ version: string }>('SELECT VERSION() as version');\n      return result.rows[0]?.version ?? 'unknown';\n    }\n    const result = await this.driver.query<{ 'sqlite_version()': string }>(\n      'SELECT sqlite_version()'\n    );\n    return result.rows[0]?.['sqlite_version()'] ?? 'unknown';\n  }\n\n  private extractPrimaryKey(indexes: IntrospectedIndex[]): string[] {\n    const pkIndex = indexes.find((i) => i.isPrimary);\n    return pkIndex?.columns ?? [];\n  }\n\n  toSchemaDefinition(result: SchemaIntrospectionResult): SchemaDefinition {\n    const tables: Record<string, TableDefinition> = {};\n\n    for (const table of result.tables) {\n      tables[table.name] = this.tableToDefinition(table);\n    }\n\n    return { tables };\n  }\n\n  private tableToDefinition(table: IntrospectedTable): TableDefinition {\n    const columns: Record<string, ColumnDefinition> = {};\n\n    for (const col of table.columns) {\n      columns[col.name] = this.columnToDefinition(col, table);\n    }\n\n    const indexes = table.indexes.map((idx) => ({\n      name: idx.name,\n      columns: idx.columns,\n      unique: idx.isUnique,\n    }));\n\n    return {\n      columns,\n      indexes: indexes.length > 0 ? indexes : undefined,\n      primaryKey: table.primaryKey.length > 1 ? table.primaryKey : undefined,\n    };\n  }\n\n  private columnToDefinition(col: IntrospectedColumn, table: IntrospectedTable): ColumnDefinition {\n    const type = this.mapDataTypeToColumnType(col.dataType, col.udtName);\n    const isPrimaryKey = table.primaryKey.length === 1 && table.primaryKey[0] === col.name;\n\n    const def: ColumnDefinition = {\n      type,\n      nullable: col.isNullable,\n    };\n\n    if (isPrimaryKey) {\n      def.primaryKey = true;\n    }\n\n    if (col.defaultValue !== null) {\n      def.default = col.defaultValue;\n    }\n\n    const fk = table.foreignKeys.find(\n      (fk) => fk.columns.length === 1 && fk.columns[0] === col.name\n    );\n    if (fk) {\n      def.references = {\n        table: fk.referencedTable,\n        column: fk.referencedColumns[0],\n        onDelete: fk.onDelete,\n        onUpdate: fk.onUpdate,\n      };\n    }\n\n    if (col.name === 'app_id' || col.name === 'organization_id') {\n      def.tenant = true;\n    }\n\n    return def;\n  }\n\n  private mapDataTypeToColumnType(dataType: string, udtName: string): ColumnType {\n    const normalized = dataType.toLowerCase();\n    const udt = udtName.toLowerCase();\n\n    if (udt === 'uuid' || normalized === 'uuid') return 'uuid';\n    if (normalized.includes('int') && normalized !== 'interval') return 'integer';\n    if (normalized === 'bigint' || udt === 'int8') return 'bigint';\n    if (normalized.includes('float') || normalized.includes('double') || normalized === 'real')\n      return 'float';\n    if (normalized.includes('numeric') || normalized.includes('decimal')) return 'decimal';\n    if (normalized === 'boolean' || normalized === 'bool') return 'boolean';\n    if (normalized.includes('timestamp') || normalized === 'datetime') return 'datetime';\n    if (normalized === 'date') return 'date';\n    if (normalized === 'time') return 'time';\n    if (normalized === 'json' || normalized === 'jsonb') return 'json';\n    if (normalized === 'bytea' || normalized.includes('blob') || normalized === 'binary')\n      return 'binary';\n    if (normalized === 'text' || udt === 'text') return 'text';\n    return 'string';\n  }\n}\n\nexport function createSchemaIntrospector(driver: Driver, dialect: Dialect): SchemaIntrospector {\n  return new SchemaIntrospector(driver, dialect);\n}\n","import { createHash } from 'node:crypto';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type {\n  ColumnDefinition,\n  IndexDefinition,\n  SchemaDefinition,\n  TableDefinition,\n} from '../types/index.js';\nimport type { DiffSummary, MigrationScript, SchemaChange, SchemaSyncDiff } from './types.js';\n\nexport interface SchemaDiffOptions {\n  generateMigration?: boolean;\n  treatColumnDropAsBreaking?: boolean;\n  treatTableDropAsBreaking?: boolean;\n  migrationName?: string;\n}\n\nexport class SchemaDiffEngine {\n  constructor(private dialect: Dialect) {}\n\n  computeDiff(\n    current: SchemaDefinition | null,\n    target: SchemaDefinition,\n    options: SchemaDiffOptions = {}\n  ): SchemaSyncDiff {\n    const changes: SchemaChange[] = [];\n    const currentTables = new Set(Object.keys(current?.tables ?? {}));\n    const targetTables = new Set(Object.keys(target.tables));\n\n    for (const tableName of targetTables) {\n      if (!currentTables.has(tableName)) {\n        const tableChanges = this.generateTableAddChanges(tableName, target.tables[tableName]);\n        changes.push(...tableChanges);\n      }\n    }\n\n    for (const tableName of currentTables) {\n      if (!targetTables.has(tableName)) {\n        changes.push(this.generateTableDropChange(tableName, current!.tables[tableName], options));\n      }\n    }\n\n    for (const tableName of currentTables) {\n      if (targetTables.has(tableName)) {\n        const columnChanges = this.compareColumns(\n          tableName,\n          current!.tables[tableName],\n          target.tables[tableName],\n          options\n        );\n        changes.push(...columnChanges);\n\n        const indexChanges = this.compareIndexes(\n          tableName,\n          current!.tables[tableName],\n          target.tables[tableName]\n        );\n        changes.push(...indexChanges);\n      }\n    }\n\n    const breakingChanges = changes.filter((c) => c.isBreaking);\n    const summary = this.summarizeChanges(changes);\n\n    let migration: MigrationScript | null = null;\n    if (options.generateMigration !== false && changes.length > 0) {\n      migration = this.generateMigration(changes, options.migrationName);\n    }\n\n    return {\n      hasDifferences: changes.length > 0,\n      summary,\n      changes,\n      breakingChanges,\n      migration,\n    };\n  }\n\n  private generateTableAddChanges(tableName: string, table: TableDefinition): SchemaChange[] {\n    const changes: SchemaChange[] = [];\n\n    const createSql = this.dialect.createTable(tableName, table);\n    const dropSql = this.dialect.dropTable(tableName);\n\n    changes.push({\n      type: 'table_add',\n      tableName,\n      isBreaking: false,\n      description: `Add table \"${tableName}\"`,\n      upSql: createSql,\n      downSql: dropSql,\n    });\n\n    if (table.indexes) {\n      for (const index of table.indexes) {\n        const indexSql = this.dialect.createIndex(tableName, index);\n        const dropIndexSql = this.dialect.dropIndex(\n          index.name ?? `idx_${tableName}_${index.columns.join('_')}`\n        );\n\n        changes.push({\n          type: 'index_add',\n          tableName,\n          objectName: index.name ?? `idx_${tableName}_${index.columns.join('_')}`,\n          isBreaking: false,\n          description: `Add index on \"${tableName}\"(${index.columns.join(', ')})`,\n          upSql: indexSql,\n          downSql: dropIndexSql,\n        });\n      }\n    }\n\n    return changes;\n  }\n\n  private generateTableDropChange(\n    tableName: string,\n    table: TableDefinition,\n    options: SchemaDiffOptions\n  ): SchemaChange {\n    const dropSql = this.dialect.dropTable(tableName);\n    const createSql = this.dialect.createTable(tableName, table);\n\n    return {\n      type: 'table_drop',\n      tableName,\n      isBreaking: options.treatTableDropAsBreaking !== false,\n      description: `Drop table \"${tableName}\"`,\n      upSql: dropSql,\n      downSql: createSql,\n      oldValue: table,\n    };\n  }\n\n  private compareColumns(\n    tableName: string,\n    current: TableDefinition,\n    target: TableDefinition,\n    options: SchemaDiffOptions\n  ): SchemaChange[] {\n    const changes: SchemaChange[] = [];\n    const currentCols = new Set(Object.keys(current.columns));\n    const targetCols = new Set(Object.keys(target.columns));\n\n    for (const colName of targetCols) {\n      if (!currentCols.has(colName)) {\n        const colDef = target.columns[colName];\n        const addSql = this.dialect.addColumn(tableName, colName, colDef);\n        const dropSql = this.dialect.dropColumn(tableName, colName);\n\n        changes.push({\n          type: 'column_add',\n          tableName,\n          objectName: colName,\n          isBreaking: false,\n          description: `Add column \"${tableName}\".\"${colName}\"`,\n          upSql: addSql,\n          downSql: dropSql,\n          newValue: colDef,\n        });\n\n        if (colDef.references) {\n          const fkName = `fk_${tableName}_${colName}_${colDef.references.table}`;\n          const addFkSql = this.dialect.addForeignKey(\n            tableName,\n            colName,\n            colDef.references.table,\n            colDef.references.column,\n            colDef.references.onDelete\n          );\n          const dropFkSql = this.dialect.dropForeignKey(tableName, fkName);\n\n          changes.push({\n            type: 'foreign_key_add',\n            tableName,\n            objectName: fkName,\n            isBreaking: false,\n            description: `Add foreign key \"${tableName}\".\"${colName}\" -> \"${colDef.references.table}\"`,\n            upSql: addFkSql,\n            downSql: dropFkSql,\n            newValue: colDef.references,\n          });\n        }\n      }\n    }\n\n    for (const colName of currentCols) {\n      if (!targetCols.has(colName)) {\n        const colDef = current.columns[colName];\n        const dropSql = this.dialect.dropColumn(tableName, colName);\n        const addSql = this.dialect.addColumn(tableName, colName, colDef);\n\n        changes.push({\n          type: 'column_drop',\n          tableName,\n          objectName: colName,\n          isBreaking: options.treatColumnDropAsBreaking !== false,\n          description: `Drop column \"${tableName}\".\"${colName}\"`,\n          upSql: dropSql,\n          downSql: addSql,\n          oldValue: colDef,\n        });\n      }\n    }\n\n    for (const colName of currentCols) {\n      if (targetCols.has(colName)) {\n        const currentCol = current.columns[colName];\n        const targetCol = target.columns[colName];\n\n        if (!this.columnsEqual(currentCol, targetCol)) {\n          const alteration = this.generateColumnAlteration(\n            tableName,\n            colName,\n            currentCol,\n            targetCol\n          );\n          if (alteration) {\n            changes.push(alteration);\n          }\n        }\n      }\n    }\n\n    return changes;\n  }\n\n  private compareIndexes(\n    tableName: string,\n    current: TableDefinition,\n    target: TableDefinition\n  ): SchemaChange[] {\n    const changes: SchemaChange[] = [];\n\n    const currentIndexes = new Map<string, IndexDefinition>();\n    const targetIndexes = new Map<string, IndexDefinition>();\n\n    for (const idx of current.indexes ?? []) {\n      const key = idx.name ?? `idx_${tableName}_${idx.columns.join('_')}`;\n      currentIndexes.set(key, idx);\n    }\n\n    for (const idx of target.indexes ?? []) {\n      const key = idx.name ?? `idx_${tableName}_${idx.columns.join('_')}`;\n      targetIndexes.set(key, idx);\n    }\n\n    for (const [name, idx] of targetIndexes) {\n      if (!currentIndexes.has(name)) {\n        const addSql = this.dialect.createIndex(tableName, idx);\n        const dropSql = this.dialect.dropIndex(name);\n\n        changes.push({\n          type: 'index_add',\n          tableName,\n          objectName: name,\n          isBreaking: false,\n          description: `Add index \"${name}\" on \"${tableName}\"`,\n          upSql: addSql,\n          downSql: dropSql,\n          newValue: idx,\n        });\n      }\n    }\n\n    for (const [name, idx] of currentIndexes) {\n      if (!targetIndexes.has(name)) {\n        const dropSql = this.dialect.dropIndex(name);\n        const addSql = this.dialect.createIndex(tableName, idx);\n\n        changes.push({\n          type: 'index_drop',\n          tableName,\n          objectName: name,\n          isBreaking: false,\n          description: `Drop index \"${name}\" from \"${tableName}\"`,\n          upSql: dropSql,\n          downSql: addSql,\n          oldValue: idx,\n        });\n      }\n    }\n\n    return changes;\n  }\n\n  private generateColumnAlteration(\n    tableName: string,\n    colName: string,\n    current: ColumnDefinition,\n    target: ColumnDefinition\n  ): SchemaChange | null {\n    const isBreaking = this.isColumnChangeBreaking(current, target);\n\n    try {\n      const alterSql = this.dialect.alterColumn(tableName, colName, target);\n      const revertSql = this.dialect.alterColumn(tableName, colName, current);\n\n      return {\n        type: 'column_modify',\n        tableName,\n        objectName: colName,\n        isBreaking,\n        description: `Modify column \"${tableName}\".\"${colName}\"`,\n        upSql: alterSql,\n        downSql: revertSql,\n        oldValue: current,\n        newValue: target,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  private isColumnChangeBreaking(current: ColumnDefinition, target: ColumnDefinition): boolean {\n    if (target.nullable === false && current.nullable === true) {\n      return true;\n    }\n\n    const typeOrder: Record<string, number> = {\n      uuid: 10,\n      boolean: 20,\n      integer: 30,\n      bigint: 40,\n      float: 50,\n      decimal: 60,\n      string: 70,\n      text: 80,\n      date: 90,\n      time: 100,\n      datetime: 110,\n      json: 120,\n      binary: 130,\n    };\n\n    const currentOrder = typeOrder[current.type] ?? 0;\n    const targetOrder = typeOrder[target.type] ?? 0;\n\n    if (targetOrder < currentOrder) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private columnsEqual(a: ColumnDefinition, b: ColumnDefinition): boolean {\n    return (\n      a.type === b.type &&\n      (a.nullable ?? false) === (b.nullable ?? false) &&\n      (a.unique ?? false) === (b.unique ?? false) &&\n      a.default === b.default &&\n      JSON.stringify(a.references) === JSON.stringify(b.references)\n    );\n  }\n\n  private summarizeChanges(changes: SchemaChange[]): DiffSummary {\n    const summary: DiffSummary = {\n      tablesAdded: 0,\n      tablesDropped: 0,\n      tablesModified: 0,\n      columnsAdded: 0,\n      columnsDropped: 0,\n      columnsModified: 0,\n      indexesAdded: 0,\n      indexesDropped: 0,\n      foreignKeysAdded: 0,\n      foreignKeysDropped: 0,\n    };\n\n    const modifiedTables = new Set<string>();\n\n    for (const change of changes) {\n      switch (change.type) {\n        case 'table_add':\n          summary.tablesAdded++;\n          break;\n        case 'table_drop':\n          summary.tablesDropped++;\n          break;\n        case 'column_add':\n          summary.columnsAdded++;\n          modifiedTables.add(change.tableName);\n          break;\n        case 'column_drop':\n          summary.columnsDropped++;\n          modifiedTables.add(change.tableName);\n          break;\n        case 'column_modify':\n          summary.columnsModified++;\n          modifiedTables.add(change.tableName);\n          break;\n        case 'index_add':\n          summary.indexesAdded++;\n          break;\n        case 'index_drop':\n          summary.indexesDropped++;\n          break;\n        case 'foreign_key_add':\n          summary.foreignKeysAdded++;\n          break;\n        case 'foreign_key_drop':\n          summary.foreignKeysDropped++;\n          break;\n      }\n    }\n\n    summary.tablesModified = modifiedTables.size;\n\n    return summary;\n  }\n\n  private generateMigration(changes: SchemaChange[], name?: string): MigrationScript {\n    const timestamp = new Date()\n      .toISOString()\n      .replace(/[-:T.Z]/g, '')\n      .slice(0, 14);\n\n    const migrationName = name ?? 'schema_sync';\n    const version = `${timestamp}`;\n\n    const upSql = changes.map((c) => c.upSql);\n    const downSql = changes\n      .slice()\n      .reverse()\n      .map((c) => c.downSql);\n\n    const content = [...upSql, ...downSql].join('\\n');\n    const checksum = createHash('sha256').update(content).digest('hex');\n\n    return {\n      version,\n      name: migrationName,\n      upSql,\n      downSql,\n      checksum,\n    };\n  }\n\n  formatDiff(diff: SchemaSyncDiff, format: 'text' | 'json' | 'sql' = 'text'): string {\n    if (format === 'json') {\n      return JSON.stringify(diff, null, 2);\n    }\n\n    if (format === 'sql') {\n      if (!diff.migration) return '-- No changes';\n      return `-- Up\\n${diff.migration.upSql.join(';\\n')};\\n\\n-- Down\\n${diff.migration.downSql.join(';\\n')};`;\n    }\n\n    const lines: string[] = [];\n\n    lines.push('┌──────────────────────────────────────────────────────────────────┐');\n    lines.push('│                     Schema Diff: local ↔ remote                  │');\n    lines.push('├──────────────────────────────────────────────────────────────────┤');\n\n    if (!diff.hasDifferences) {\n      lines.push('│  No differences found                                            │');\n      lines.push('└──────────────────────────────────────────────────────────────────┘');\n      return lines.join('\\n');\n    }\n\n    lines.push('│ Summary:                                                          │');\n    if (diff.summary.tablesAdded > 0) {\n      lines.push(\n        `│   + ${diff.summary.tablesAdded} table(s) added                                             │`\n      );\n    }\n    if (diff.summary.tablesDropped > 0) {\n      lines.push(\n        `│   - ${diff.summary.tablesDropped} table(s) dropped (BREAKING)                               │`\n      );\n    }\n    if (diff.summary.columnsAdded > 0) {\n      lines.push(\n        `│   + ${diff.summary.columnsAdded} column(s) added                                            │`\n      );\n    }\n    if (diff.summary.columnsDropped > 0) {\n      lines.push(\n        `│   - ${diff.summary.columnsDropped} column(s) dropped (BREAKING)                              │`\n      );\n    }\n    if (diff.summary.columnsModified > 0) {\n      lines.push(\n        `│   ~ ${diff.summary.columnsModified} column(s) modified                                        │`\n      );\n    }\n    if (diff.summary.indexesAdded > 0) {\n      lines.push(\n        `│   + ${diff.summary.indexesAdded} index(es) added                                             │`\n      );\n    }\n    if (diff.summary.indexesDropped > 0) {\n      lines.push(\n        `│   - ${diff.summary.indexesDropped} index(es) dropped                                          │`\n      );\n    }\n\n    lines.push('├──────────────────────────────────────────────────────────────────┤');\n\n    for (const change of diff.changes) {\n      const prefix = change.type.includes('add') ? '+' : change.type.includes('drop') ? '-' : '~';\n      const breaking = change.isBreaking ? ' (BREAKING)' : '';\n      lines.push(`│ ${prefix} ${change.description}${breaking}`);\n    }\n\n    lines.push('└──────────────────────────────────────────────────────────────────┘');\n\n    if (diff.breakingChanges.length > 0) {\n      lines.push('');\n      lines.push(\n        `⚠️  ${diff.breakingChanges.length} breaking change(s) detected. Use --force to apply.`\n      );\n    }\n\n    return lines.join('\\n');\n  }\n}\n\nexport function createSchemaDiffEngine(dialect: Dialect): SchemaDiffEngine {\n  return new SchemaDiffEngine(dialect);\n}\n","import { createHash } from 'node:crypto';\nimport type { Driver } from '../driver/types.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { SchemaRemoteClient } from '../remote/client.js';\nimport type { SchemaDefinition } from '../types/index.js';\nimport { SchemaDiffEngine } from './diff.js';\nimport { SchemaIntrospector } from './introspect.js';\nimport { SyncMetadataManager } from './sync-metadata.js';\nimport {\n  BreakingChangeError,\n  type DiffOptions,\n  type PullOptions,\n  type PullResult,\n  type PushOptions,\n  type PushResult,\n  type SchemaSyncDiff,\n  type SyncStatus,\n  UserCancelledError,\n} from './types.js';\n\nexport interface SchemaSyncServiceOptions {\n  appId: string;\n  migrationsPath?: string;\n}\n\nexport interface Logger {\n  info(message: string): void;\n  warn(message: string): void;\n  error(message: string): void;\n}\n\nconst defaultLogger: Logger = {\n  info: (msg) => console.log(msg),\n  warn: (msg) => console.warn(msg),\n  error: (msg) => console.error(msg),\n};\n\nexport class SchemaSyncService {\n  private introspector: SchemaIntrospector;\n  private diffEngine: SchemaDiffEngine;\n  private syncMetadata: SyncMetadataManager;\n\n  constructor(\n    private driver: Driver,\n    private dialect: Dialect,\n    private remoteClient: SchemaRemoteClient,\n    private options: SchemaSyncServiceOptions,\n    private logger: Logger = defaultLogger\n  ) {\n    this.introspector = new SchemaIntrospector(driver, dialect);\n    this.diffEngine = new SchemaDiffEngine(dialect);\n    this.syncMetadata = new SyncMetadataManager(driver, dialect);\n  }\n\n  async pull(options: PullOptions = {}): Promise<PullResult> {\n    const environment = options.environment ?? 'production';\n    this.logger.info(`Fetching schema from ${environment}...`);\n\n    await this.syncMetadata.ensureSyncTable();\n\n    const remote = await this.remoteClient.fetchSchema(environment);\n\n    this.logger.info('Introspecting local database...');\n    const localIntrospection = await this.introspector.introspect();\n    const localSchema = this.introspector.toSchemaDefinition(localIntrospection);\n\n    const diff = this.diffEngine.computeDiff(localSchema, remote.schema, {\n      generateMigration: true,\n      migrationName: `sync_pull_${environment}`,\n    });\n\n    if (!diff.hasDifferences) {\n      this.logger.info('Local schema is up to date');\n      return { applied: false, diff };\n    }\n\n    this.logger.info(this.diffEngine.formatDiff(diff, 'text'));\n\n    if (options.dryRun) {\n      this.logger.info('(dry-run) No changes applied');\n      return { applied: false, diff };\n    }\n\n    if (diff.breakingChanges.length > 0 && !options.force) {\n      throw new BreakingChangeError(\n        `Pull would make ${diff.breakingChanges.length} breaking change(s). Use --force to apply anyway.`,\n        diff.breakingChanges\n      );\n    }\n\n    await this.applyMigration(diff);\n\n    const localChecksum = this.computeSchemaChecksum(localSchema);\n    await this.syncMetadata.updateSyncState(this.options.appId, 'pull', {\n      localChecksum,\n      localVersion: diff.migration?.version,\n      remoteChecksum: remote.checksum,\n      remoteVersion: remote.version,\n    });\n\n    this.logger.info('✓ Schema updated successfully');\n    return { applied: true, diff };\n  }\n\n  async push(options: PushOptions = {}): Promise<PushResult> {\n    const environment = options.environment ?? 'production';\n    this.logger.info('Introspecting local schema...');\n\n    await this.syncMetadata.ensureSyncTable();\n\n    const localIntrospection = await this.introspector.introspect();\n    const localSchema = this.introspector.toSchemaDefinition(localIntrospection);\n\n    this.logger.info(`Fetching remote schema from ${environment}...`);\n    const remote = await this.remoteClient.fetchSchema(environment);\n\n    const diff = this.diffEngine.computeDiff(remote.schema, localSchema, {\n      generateMigration: true,\n      migrationName: `sync_push_${environment}`,\n    });\n\n    if (!diff.hasDifferences) {\n      this.logger.info('Remote schema is up to date');\n      return { applied: false, diff };\n    }\n\n    this.logger.info(this.diffEngine.formatDiff(diff, 'text'));\n\n    if (options.dryRun) {\n      this.logger.info('(dry-run) No changes would be pushed');\n      return { applied: false, diff };\n    }\n\n    if (environment === 'production' && !options.force) {\n      this.logger.warn('⚠️  You are about to push schema changes to PRODUCTION');\n      this.logger.warn('This operation cannot be automatically undone.');\n      throw new UserCancelledError(\n        'Production push requires --force flag. Review changes carefully before proceeding.'\n      );\n    }\n\n    if (diff.breakingChanges.length > 0 && !options.force) {\n      throw new BreakingChangeError(\n        `Push would make ${diff.breakingChanges.length} breaking change(s). Use --force to apply anyway.`,\n        diff.breakingChanges\n      );\n    }\n\n    if (!diff.migration) {\n      return { applied: false, diff };\n    }\n\n    const remoteResult = await this.remoteClient.pushMigration(diff.migration, {\n      environment,\n      dryRun: false,\n      force: options.force,\n    });\n\n    if (remoteResult.success) {\n      const localChecksum = this.computeSchemaChecksum(localSchema);\n      await this.syncMetadata.updateSyncState(this.options.appId, 'push', {\n        localChecksum,\n        localVersion: diff.migration.version,\n        remoteChecksum: localChecksum,\n        remoteVersion: diff.migration.version,\n      });\n\n      this.logger.info('✓ Schema pushed successfully');\n    } else {\n      this.logger.error('✗ Push failed');\n      if (remoteResult.errors) {\n        for (const error of remoteResult.errors) {\n          this.logger.error(`  - ${error}`);\n        }\n      }\n    }\n\n    return { applied: remoteResult.success, diff, remoteResult };\n  }\n\n  async diff(options: DiffOptions = {}): Promise<SchemaSyncDiff> {\n    const environment = options.environment ?? 'production';\n\n    this.logger.info('Introspecting local schema...');\n    const localIntrospection = await this.introspector.introspect();\n    const localSchema = this.introspector.toSchemaDefinition(localIntrospection);\n\n    this.logger.info(`Fetching remote schema from ${environment}...`);\n    const remote = await this.remoteClient.fetchSchema(environment);\n\n    const diff = this.diffEngine.computeDiff(localSchema, remote.schema, {\n      generateMigration: true,\n      migrationName: `diff_${environment}`,\n    });\n\n    return diff;\n  }\n\n  async getSyncStatus(): Promise<SyncStatus | null> {\n    await this.syncMetadata.ensureSyncTable();\n    return this.syncMetadata.getSyncState(this.options.appId, '__global__');\n  }\n\n  async introspectLocal(): Promise<SchemaDefinition> {\n    const introspection = await this.introspector.introspect();\n    return this.introspector.toSchemaDefinition(introspection);\n  }\n\n  formatDiff(diff: SchemaSyncDiff, format: 'text' | 'json' | 'sql' = 'text'): string {\n    return this.diffEngine.formatDiff(diff, format);\n  }\n\n  private async applyMigration(diff: SchemaSyncDiff): Promise<void> {\n    if (!diff.migration) return;\n\n    if (this.dialect.supportsTransactionalDDL) {\n      await this.driver.transaction(async (trx) => {\n        for (const sql of diff.migration!.upSql) {\n          await trx.execute(sql);\n        }\n      });\n    } else {\n      for (const sql of diff.migration.upSql) {\n        await this.driver.execute(sql);\n      }\n    }\n  }\n\n  private computeSchemaChecksum(schema: SchemaDefinition): string {\n    const normalized = JSON.stringify(schema, Object.keys(schema).sort());\n    return createHash('sha256').update(normalized).digest('hex');\n  }\n}\n\nexport function createSchemaSyncService(\n  driver: Driver,\n  dialect: Dialect,\n  remoteClient: SchemaRemoteClient,\n  options: SchemaSyncServiceOptions,\n  logger?: Logger\n): SchemaSyncService {\n  return new SchemaSyncService(driver, dialect, remoteClient, options, logger);\n}\n","import type { Driver } from '../driver/types.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { SyncStatus } from './types.js';\n\nexport interface SyncMetadataOptions {\n  tableName?: string;\n}\n\nexport class SyncMetadataManager {\n  private tableName: string;\n\n  constructor(\n    private driver: Driver,\n    private dialect: Dialect,\n    options: SyncMetadataOptions = {}\n  ) {\n    this.tableName = options.tableName ?? 'lp_schema_sync';\n  }\n\n  async ensureSyncTable(): Promise<void> {\n    let sql: string;\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n          app_id TEXT NOT NULL,\n          table_name TEXT NOT NULL,\n          local_checksum TEXT,\n          local_version TEXT,\n          local_updated_at TIMESTAMPTZ,\n          remote_checksum TEXT,\n          remote_version TEXT,\n          remote_updated_at TIMESTAMPTZ,\n          sync_status TEXT NOT NULL DEFAULT 'unknown',\n          last_sync_at TIMESTAMPTZ,\n          last_sync_direction TEXT,\n          last_sync_by TEXT,\n          base_checksum TEXT,\n          conflict_details JSONB,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW(),\n          UNIQUE(app_id, table_name)\n        )\n      `;\n    } else if (this.dialect.name === 'mysql') {\n      sql = `\n        CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n          id CHAR(36) PRIMARY KEY,\n          app_id VARCHAR(255) NOT NULL,\n          table_name VARCHAR(255) NOT NULL,\n          local_checksum VARCHAR(64),\n          local_version VARCHAR(50),\n          local_updated_at DATETIME,\n          remote_checksum VARCHAR(64),\n          remote_version VARCHAR(50),\n          remote_updated_at DATETIME,\n          sync_status VARCHAR(20) NOT NULL DEFAULT 'unknown',\n          last_sync_at DATETIME,\n          last_sync_direction VARCHAR(10),\n          last_sync_by VARCHAR(255),\n          base_checksum VARCHAR(64),\n          conflict_details JSON,\n          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n          UNIQUE KEY unique_app_table (app_id, table_name)\n        )\n      `;\n    } else {\n      sql = `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          id TEXT PRIMARY KEY,\n          app_id TEXT NOT NULL,\n          table_name TEXT NOT NULL,\n          local_checksum TEXT,\n          local_version TEXT,\n          local_updated_at TEXT,\n          remote_checksum TEXT,\n          remote_version TEXT,\n          remote_updated_at TEXT,\n          sync_status TEXT NOT NULL DEFAULT 'unknown',\n          last_sync_at TEXT,\n          last_sync_direction TEXT,\n          last_sync_by TEXT,\n          base_checksum TEXT,\n          conflict_details TEXT,\n          created_at TEXT DEFAULT (datetime('now')),\n          updated_at TEXT DEFAULT (datetime('now')),\n          UNIQUE(app_id, table_name)\n        )\n      `;\n    }\n\n    await this.driver.execute(sql);\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver\n        .execute(`\n        CREATE INDEX IF NOT EXISTS idx_${this.tableName}_status\n        ON \"${this.tableName}\"(app_id, sync_status)\n      `)\n        .catch(() => {});\n    }\n  }\n\n  async getSyncState(appId: string, tableName: string): Promise<SyncStatus | null> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `SELECT * FROM \"${this.tableName}\" WHERE app_id = $1 AND table_name = $2`;\n      params = [appId, tableName];\n    } else {\n      sql = `SELECT * FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE app_id = ? AND table_name = ?`;\n      params = [appId, tableName];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      table_name: string;\n      local_checksum: string | null;\n      local_version: string | null;\n      local_updated_at: Date | string | null;\n      remote_checksum: string | null;\n      remote_version: string | null;\n      remote_updated_at: Date | string | null;\n      sync_status: string;\n      last_sync_at: Date | string | null;\n      last_sync_direction: string | null;\n      last_sync_by: string | null;\n      base_checksum: string | null;\n      conflict_details: Record<string, unknown> | string | null;\n    }>(sql, params);\n\n    if (!result.rows.length) return null;\n\n    const row = result.rows[0];\n\n    return {\n      appId: row.app_id,\n      tableName: row.table_name,\n      localChecksum: row.local_checksum,\n      localVersion: row.local_version,\n      localUpdatedAt: row.local_updated_at ? new Date(row.local_updated_at) : null,\n      remoteChecksum: row.remote_checksum,\n      remoteVersion: row.remote_version,\n      remoteUpdatedAt: row.remote_updated_at ? new Date(row.remote_updated_at) : null,\n      syncStatus: row.sync_status as SyncStatus['syncStatus'],\n      lastSyncAt: row.last_sync_at ? new Date(row.last_sync_at) : null,\n      lastSyncDirection: row.last_sync_direction as SyncStatus['lastSyncDirection'],\n      lastSyncBy: row.last_sync_by,\n      baseChecksum: row.base_checksum,\n      conflictDetails:\n        typeof row.conflict_details === 'string'\n          ? JSON.parse(row.conflict_details)\n          : row.conflict_details,\n    };\n  }\n\n  async getAllSyncStates(appId: string): Promise<SyncStatus[]> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `SELECT * FROM \"${this.tableName}\" WHERE app_id = $1 ORDER BY table_name`;\n      params = [appId];\n    } else {\n      sql = `SELECT * FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE app_id = ? ORDER BY table_name`;\n      params = [appId];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      table_name: string;\n      local_checksum: string | null;\n      local_version: string | null;\n      local_updated_at: Date | string | null;\n      remote_checksum: string | null;\n      remote_version: string | null;\n      remote_updated_at: Date | string | null;\n      sync_status: string;\n      last_sync_at: Date | string | null;\n      last_sync_direction: string | null;\n      last_sync_by: string | null;\n      base_checksum: string | null;\n      conflict_details: Record<string, unknown> | string | null;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      appId: row.app_id,\n      tableName: row.table_name,\n      localChecksum: row.local_checksum,\n      localVersion: row.local_version,\n      localUpdatedAt: row.local_updated_at ? new Date(row.local_updated_at) : null,\n      remoteChecksum: row.remote_checksum,\n      remoteVersion: row.remote_version,\n      remoteUpdatedAt: row.remote_updated_at ? new Date(row.remote_updated_at) : null,\n      syncStatus: row.sync_status as SyncStatus['syncStatus'],\n      lastSyncAt: row.last_sync_at ? new Date(row.last_sync_at) : null,\n      lastSyncDirection: row.last_sync_direction as SyncStatus['lastSyncDirection'],\n      lastSyncBy: row.last_sync_by,\n      baseChecksum: row.base_checksum,\n      conflictDetails:\n        typeof row.conflict_details === 'string'\n          ? JSON.parse(row.conflict_details)\n          : row.conflict_details,\n    }));\n  }\n\n  async updateSyncState(\n    appId: string,\n    direction: 'push' | 'pull',\n    data: {\n      localChecksum?: string;\n      localVersion?: string;\n      remoteChecksum?: string;\n      remoteVersion?: string;\n      syncBy?: string;\n    }\n  ): Promise<void> {\n    const now = new Date().toISOString();\n    const status = 'synced';\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (\n          app_id, table_name, local_checksum, local_version, local_updated_at,\n          remote_checksum, remote_version, remote_updated_at, sync_status,\n          last_sync_at, last_sync_direction, last_sync_by, base_checksum\n        )\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)\n        ON CONFLICT (app_id, table_name) DO UPDATE SET\n          local_checksum = COALESCE($3, \"${this.tableName}\".local_checksum),\n          local_version = COALESCE($4, \"${this.tableName}\".local_version),\n          local_updated_at = $5,\n          remote_checksum = COALESCE($6, \"${this.tableName}\".remote_checksum),\n          remote_version = COALESCE($7, \"${this.tableName}\".remote_version),\n          remote_updated_at = $8,\n          sync_status = $9,\n          last_sync_at = $10,\n          last_sync_direction = $11,\n          last_sync_by = $12,\n          base_checksum = COALESCE($13, \"${this.tableName}\".base_checksum),\n          updated_at = NOW()\n        `,\n        [\n          appId,\n          '__global__',\n          data.localChecksum ?? null,\n          data.localVersion ?? null,\n          now,\n          data.remoteChecksum ?? null,\n          data.remoteVersion ?? null,\n          now,\n          status,\n          now,\n          direction,\n          data.syncBy ?? null,\n          data.localChecksum ?? data.remoteChecksum ?? null,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      const id = this.generateUUID();\n      await this.driver.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (\n          id, app_id, table_name, local_checksum, local_version, local_updated_at,\n          remote_checksum, remote_version, remote_updated_at, sync_status,\n          last_sync_at, last_sync_direction, last_sync_by, base_checksum\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          local_checksum = COALESCE(VALUES(local_checksum), local_checksum),\n          local_version = COALESCE(VALUES(local_version), local_version),\n          local_updated_at = VALUES(local_updated_at),\n          remote_checksum = COALESCE(VALUES(remote_checksum), remote_checksum),\n          remote_version = COALESCE(VALUES(remote_version), remote_version),\n          remote_updated_at = VALUES(remote_updated_at),\n          sync_status = VALUES(sync_status),\n          last_sync_at = VALUES(last_sync_at),\n          last_sync_direction = VALUES(last_sync_direction),\n          last_sync_by = VALUES(last_sync_by),\n          base_checksum = COALESCE(VALUES(base_checksum), base_checksum)\n        `,\n        [\n          id,\n          appId,\n          '__global__',\n          data.localChecksum ?? null,\n          data.localVersion ?? null,\n          now,\n          data.remoteChecksum ?? null,\n          data.remoteVersion ?? null,\n          now,\n          status,\n          now,\n          direction,\n          data.syncBy ?? null,\n          data.localChecksum ?? data.remoteChecksum ?? null,\n        ]\n      );\n    } else {\n      const id = this.generateUUID();\n      await this.driver.execute(\n        `\n        INSERT OR REPLACE INTO \"${this.tableName}\" (\n          id, app_id, table_name, local_checksum, local_version, local_updated_at,\n          remote_checksum, remote_version, remote_updated_at, sync_status,\n          last_sync_at, last_sync_direction, last_sync_by, base_checksum,\n          created_at, updated_at\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))\n        `,\n        [\n          id,\n          appId,\n          '__global__',\n          data.localChecksum ?? null,\n          data.localVersion ?? null,\n          now,\n          data.remoteChecksum ?? null,\n          data.remoteVersion ?? null,\n          now,\n          status,\n          now,\n          direction,\n          data.syncBy ?? null,\n          data.localChecksum ?? data.remoteChecksum ?? null,\n        ]\n      );\n    }\n  }\n\n  async markConflict(\n    appId: string,\n    tableName: string,\n    conflictDetails: Record<string, unknown>\n  ): Promise<void> {\n    const detailsJson = JSON.stringify(conflictDetails);\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(\n        `\n        UPDATE \"${this.tableName}\"\n        SET sync_status = 'conflict', conflict_details = $1, updated_at = NOW()\n        WHERE app_id = $2 AND table_name = $3\n        `,\n        [detailsJson, appId, tableName]\n      );\n    } else {\n      const table = this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`;\n      await this.driver.execute(\n        `UPDATE ${table} SET sync_status = 'conflict', conflict_details = ? WHERE app_id = ? AND table_name = ?`,\n        [detailsJson, appId, tableName]\n      );\n    }\n  }\n\n  async detectConflicts(appId: string): Promise<SyncStatus[]> {\n    const states = await this.getAllSyncStates(appId);\n\n    return states.filter((state) => {\n      if (!state.localChecksum || !state.remoteChecksum || !state.baseChecksum) {\n        return false;\n      }\n\n      const localChanged = state.localChecksum !== state.baseChecksum;\n      const remoteChanged = state.remoteChecksum !== state.baseChecksum;\n\n      return localChanged && remoteChanged && state.localChecksum !== state.remoteChecksum;\n    });\n  }\n\n  private generateUUID(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n      const r = (Math.random() * 16) | 0;\n      const v = c === 'x' ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n}\n\nexport function createSyncMetadataManager(\n  driver: Driver,\n  dialect: Dialect,\n  options?: SyncMetadataOptions\n): SyncMetadataManager {\n  return new SyncMetadataManager(driver, dialect, options);\n}\n","import type { ColumnDefinition, ColumnType, SchemaDefinition } from './index.js';\n\nexport interface TypeGeneratorOptions {\n  includeInsertTypes?: boolean;\n  includeUpdateTypes?: boolean;\n  includeZodSchemas?: boolean;\n  omitTenantColumns?: boolean;\n  insertSuffix?: string;\n  updateSuffix?: string;\n}\n\nfunction pascalCase(str: string): string {\n  return str\n    .split(/[-_]/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\nfunction camelCase(str: string): string {\n  const pascal = pascalCase(str);\n  return pascal.charAt(0).toLowerCase() + pascal.slice(1);\n}\n\nfunction pgTypeToTs(type: ColumnType): string {\n  const map: Record<ColumnType, string> = {\n    uuid: 'string',\n    string: 'string',\n    text: 'string',\n    integer: 'number',\n    bigint: 'number',\n    float: 'number',\n    decimal: 'number',\n    boolean: 'boolean',\n    datetime: 'Date',\n    date: 'Date',\n    time: 'string',\n    json: 'Record<string, unknown>',\n    binary: 'Buffer',\n  };\n  return map[type] || 'unknown';\n}\n\nfunction pgTypeToZod(type: ColumnType): string {\n  const map: Record<ColumnType, string> = {\n    uuid: 'z.string().uuid()',\n    string: 'z.string()',\n    text: 'z.string()',\n    integer: 'z.number().int()',\n    bigint: 'z.number().int()',\n    float: 'z.number()',\n    decimal: 'z.number()',\n    boolean: 'z.boolean()',\n    datetime: 'z.coerce.date()',\n    date: 'z.coerce.date()',\n    time: 'z.string()',\n    json: 'z.record(z.unknown())',\n    binary: 'z.instanceof(Buffer)',\n  };\n  return map[type] || 'z.unknown()';\n}\n\nfunction isAutoGeneratedColumn(colName: string, col: ColumnDefinition): boolean {\n  if (colName === 'id' && col.default) return true;\n  if (colName === 'created_at' && col.default) return true;\n  if (colName === 'updated_at' && col.default) return true;\n  return false;\n}\n\nexport function generateTypes(\n  schemas: Map<string, SchemaDefinition>,\n  options: TypeGeneratorOptions = {}\n): string {\n  const {\n    includeInsertTypes = true,\n    includeUpdateTypes = true,\n    omitTenantColumns = true,\n    insertSuffix = 'Insert',\n    updateSuffix = 'Update',\n  } = options;\n\n  const lines: string[] = [\n    '// Auto-generated by @launchpad/db-engine',\n    '// Do not edit this file manually',\n    '',\n  ];\n\n  for (const [schemaName, schema] of schemas) {\n    const namespace = pascalCase(schemaName);\n    lines.push(`export namespace ${namespace} {`);\n\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      const typeName = pascalCase(tableName);\n\n      lines.push(`  /** Row type for ${tableName} table */`);\n      lines.push(`  export interface ${typeName} {`);\n\n      for (const [colName, col] of Object.entries(table.columns)) {\n        const tsType = pgTypeToTs(col.type);\n        const nullable = col.nullable ? ' | null' : '';\n        lines.push(`    ${colName}: ${tsType}${nullable};`);\n      }\n\n      lines.push('  }');\n      lines.push('');\n\n      if (includeInsertTypes) {\n        lines.push(`  /** Insert type for ${tableName} table (omits auto-generated fields) */`);\n        lines.push(`  export interface ${typeName}${insertSuffix} {`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (isAutoGeneratedColumn(colName, col)) continue;\n          if (omitTenantColumns && col.tenant) continue;\n\n          const tsType = pgTypeToTs(col.type);\n          const optional = col.nullable || col.default ? '?' : '';\n          lines.push(`    ${colName}${optional}: ${tsType};`);\n        }\n\n        lines.push('  }');\n        lines.push('');\n      }\n\n      if (includeUpdateTypes) {\n        lines.push(`  /** Update type for ${tableName} table (all fields optional) */`);\n        lines.push(`  export interface ${typeName}${updateSuffix} {`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (colName === 'id') continue;\n          if (colName === 'created_at') continue;\n\n          if (omitTenantColumns && col.tenant) continue;\n\n          const tsType = pgTypeToTs(col.type);\n          lines.push(`    ${colName}?: ${tsType} | null;`);\n        }\n\n        lines.push('  }');\n        lines.push('');\n      }\n    }\n\n    const tableNames = Object.keys(schema.tables)\n      .map((t) => `'${t}'`)\n      .join(' | ');\n    lines.push(`  export type TableName = ${tableNames};`);\n    lines.push('');\n\n    lines.push('  export interface Tables {');\n    for (const tableName of Object.keys(schema.tables)) {\n      const typeName = pascalCase(tableName);\n      lines.push(`    ${tableName}: ${typeName};`);\n    }\n    lines.push('  }');\n\n    lines.push('}');\n    lines.push('');\n  }\n\n  lines.push('export type AllSchemas = {');\n  for (const schemaName of schemas.keys()) {\n    const namespace = pascalCase(schemaName);\n    lines.push(`  ${schemaName}: typeof ${namespace};`);\n  }\n  lines.push('};');\n\n  return lines.join('\\n');\n}\n\nexport function generateZodSchemas(\n  schemas: Map<string, SchemaDefinition>,\n  options: TypeGeneratorOptions = {}\n): string {\n  const {\n    includeInsertTypes = true,\n    includeUpdateTypes = true,\n    omitTenantColumns = true,\n    insertSuffix = 'Insert',\n    updateSuffix = 'Update',\n  } = options;\n\n  const lines: string[] = [\n    '// Auto-generated by @launchpad/db-engine',\n    '// Do not edit this file manually',\n    '',\n    \"import { z } from 'zod';\",\n    '',\n  ];\n\n  for (const [schemaName, schema] of schemas) {\n    const schemaPrefix = camelCase(schemaName);\n    lines.push(`// ==================== ${pascalCase(schemaName)} Schema ====================`);\n    lines.push('');\n\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      const typeName = pascalCase(tableName);\n\n      lines.push(`/** Zod schema for ${tableName} row */`);\n      lines.push(`export const ${schemaPrefix}${typeName}Schema = z.object({`);\n\n      for (const [colName, col] of Object.entries(table.columns)) {\n        let zodType = pgTypeToZod(col.type);\n        if (col.nullable) {\n          zodType += '.nullable()';\n        }\n        lines.push(`  ${colName}: ${zodType},`);\n      }\n\n      lines.push('});');\n      lines.push('');\n\n      if (includeInsertTypes) {\n        lines.push(`/** Zod schema for ${tableName} insert (omits auto-generated fields) */`);\n        lines.push(`export const ${schemaPrefix}${typeName}${insertSuffix}Schema = z.object({`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (isAutoGeneratedColumn(colName, col)) continue;\n          if (omitTenantColumns && col.tenant) continue;\n\n          let zodType = pgTypeToZod(col.type);\n          if (col.nullable || col.default) {\n            zodType += '.optional()';\n          }\n          lines.push(`  ${colName}: ${zodType},`);\n        }\n\n        lines.push('});');\n        lines.push('');\n      }\n\n      if (includeUpdateTypes) {\n        lines.push(`/** Zod schema for ${tableName} update (all fields optional) */`);\n        lines.push(`export const ${schemaPrefix}${typeName}${updateSuffix}Schema = z.object({`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (colName === 'id') continue;\n          if (colName === 'created_at') continue;\n\n          if (omitTenantColumns && col.tenant) continue;\n\n          let zodType = pgTypeToZod(col.type);\n          zodType += '.nullable().optional()';\n          lines.push(`  ${colName}: ${zodType},`);\n        }\n\n        lines.push('});');\n        lines.push('');\n      }\n\n      lines.push('/** Inferred types from Zod schemas */');\n      lines.push(`export type ${typeName} = z.infer<typeof ${schemaPrefix}${typeName}Schema>;`);\n      if (includeInsertTypes) {\n        lines.push(\n          `export type ${typeName}${insertSuffix} = z.infer<typeof ${schemaPrefix}${typeName}${insertSuffix}Schema>;`\n        );\n      }\n      if (includeUpdateTypes) {\n        lines.push(\n          `export type ${typeName}${updateSuffix} = z.infer<typeof ${schemaPrefix}${typeName}${updateSuffix}Schema>;`\n        );\n      }\n      lines.push('');\n    }\n  }\n\n  return lines.join('\\n');\n}\n\nexport function generateSchemaFromDefinition(schema: SchemaDefinition): string {\n  const lines: string[] = [\n    \"import type { SchemaDefinition } from '@launchpad/db-engine';\",\n    '',\n    'export const schema: SchemaDefinition = {',\n    '  tables: {',\n  ];\n\n  for (const [tableName, table] of Object.entries(schema.tables)) {\n    lines.push(`    ${tableName}: {`);\n    lines.push('      columns: {');\n\n    for (const [colName, col] of Object.entries(table.columns)) {\n      const colDef: string[] = [];\n      colDef.push(`type: '${col.type}'`);\n\n      if (col.primaryKey) colDef.push('primaryKey: true');\n      if (col.nullable) colDef.push('nullable: true');\n      if (col.unique) colDef.push('unique: true');\n      if (col.default) colDef.push(`default: '${col.default}'`);\n      if (col.tenant) colDef.push('tenant: true');\n\n      if (col.references) {\n        colDef.push(\n          `references: { table: '${col.references.table}', column: '${col.references.column}'${col.references.onDelete ? `, onDelete: '${col.references.onDelete}'` : ''} }`\n        );\n      }\n\n      lines.push(`        ${colName}: { ${colDef.join(', ')} },`);\n    }\n\n    lines.push('      },');\n\n    if (table.indexes?.length) {\n      lines.push('      indexes: [');\n      for (const index of table.indexes) {\n        const indexDef: string[] = [];\n        indexDef.push(`columns: [${index.columns.map((c) => `'${c}'`).join(', ')}]`);\n        if (index.name) indexDef.push(`name: '${index.name}'`);\n        if (index.unique) indexDef.push('unique: true');\n        if (index.where) indexDef.push(`where: '${index.where}'`);\n        lines.push(`        { ${indexDef.join(', ')} },`);\n      }\n      lines.push('      ],');\n    }\n\n    lines.push('    },');\n  }\n\n  lines.push('  },');\n  lines.push('};');\n\n  return lines.join('\\n');\n}\n","import type { SchemaDefinition } from './index.js';\n\nexport interface HooksGeneratorOptions {\n  includeQueryHooks?: boolean;\n  includeMutationHooks?: boolean;\n  typesImportPath?: string;\n}\n\nfunction pascalCase(str: string): string {\n  return str\n    .split(/[-_]/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\nfunction singularize(word: string): string {\n  if (word.endsWith('ies')) {\n    return `${word.slice(0, -3)}y`;\n  }\n  if (\n    word.endsWith('ses') ||\n    word.endsWith('xes') ||\n    word.endsWith('zes') ||\n    word.endsWith('ches') ||\n    word.endsWith('shes')\n  ) {\n    return word.slice(0, -2);\n  }\n  if (word.endsWith('s') && !word.endsWith('ss')) {\n    return word.slice(0, -1);\n  }\n  return word;\n}\n\nfunction getHookNames(tableName: string): {\n  pluralName: string;\n  singularName: string;\n  listHook: string;\n  singleHook: string;\n  createHook: string;\n  updateHook: string;\n  deleteHook: string;\n} {\n  const pluralPascal = pascalCase(tableName);\n  const singularPascal = pascalCase(singularize(tableName));\n\n  return {\n    pluralName: pluralPascal,\n    singularName: singularPascal,\n    listHook: `use${pluralPascal}`,\n    singleHook: `use${singularPascal}`,\n    createHook: `useCreate${singularPascal}`,\n    updateHook: `useUpdate${singularPascal}`,\n    deleteHook: `useDelete${singularPascal}`,\n  };\n}\n\nfunction generateTableHooks(\n  tableName: string,\n  typeName: string,\n  options: HooksGeneratorOptions\n): string[] {\n  const lines: string[] = [];\n  const hooks = getHookNames(tableName);\n  const { includeQueryHooks = true, includeMutationHooks = true } = options;\n\n  lines.push(`// ==================== ${hooks.pluralName} ====================`);\n  lines.push('');\n\n  if (includeQueryHooks) {\n    lines.push(`/** Query hook for fetching all ${tableName} */`);\n    lines.push(\n      `export function ${hooks.listHook}(options?: Omit<UseQueryOptions<${typeName}>, 'table'>) {`\n    );\n    lines.push(`  return useQuery<${typeName}>({ ...options, table: '${tableName}' });`);\n    lines.push('}');\n    lines.push('');\n\n    lines.push(`/** Query hook for fetching a single ${singularize(tableName)} by ID */`);\n    lines.push(\n      `export function ${hooks.singleHook}(id: string, options?: Omit<UseQueryOptions<${typeName}>, 'table' | 'where'>) {`\n    );\n    lines.push(\n      `  return useQueryOne<${typeName}>({ ...options, table: '${tableName}', where: { id: { eq: id } } });`\n    );\n    lines.push('}');\n    lines.push('');\n  }\n\n  if (includeMutationHooks) {\n    lines.push(`/** Mutation hook for creating a ${singularize(tableName)} */`);\n    lines.push(\n      `export function ${hooks.createHook}(options?: UseMutationOptions<${typeName} | ${typeName}[], InsertVariables<${typeName}>>) {`\n    );\n    lines.push(`  const mutation = useInsert<${typeName}>(options);`);\n    lines.push('  return {');\n    lines.push('    ...mutation,');\n    lines.push(\n      `    mutate: (data: InsertVariables<${typeName}>['data']) => mutation.mutate({ table: '${tableName}', data }),`\n    );\n    lines.push(\n      `    mutateAsync: (data: InsertVariables<${typeName}>['data']) => mutation.mutateAsync({ table: '${tableName}', data }),`\n    );\n    lines.push('  };');\n    lines.push('}');\n    lines.push('');\n\n    lines.push(`/** Mutation hook for updating a ${singularize(tableName)} */`);\n    lines.push(\n      `export function ${hooks.updateHook}(options?: UseMutationOptions<${typeName}[], UpdateVariables<${typeName}>>) {`\n    );\n    lines.push(`  const mutation = useUpdate<${typeName}>(options);`);\n    lines.push('  return {');\n    lines.push('    ...mutation,');\n    lines.push(\n      `    mutate: (args: { where: UpdateVariables<${typeName}>['where']; data: UpdateVariables<${typeName}>['data'] }) =>`\n    );\n    lines.push(`      mutation.mutate({ table: '${tableName}', ...args }),`);\n    lines.push(\n      `    mutateAsync: (args: { where: UpdateVariables<${typeName}>['where']; data: UpdateVariables<${typeName}>['data'] }) =>`\n    );\n    lines.push(`      mutation.mutateAsync({ table: '${tableName}', ...args }),`);\n    lines.push('  };');\n    lines.push('}');\n    lines.push('');\n\n    lines.push(`/** Mutation hook for deleting a ${singularize(tableName)} */`);\n    lines.push(\n      `export function ${hooks.deleteHook}(options?: UseMutationOptions<{ deleted: number }, DeleteVariables<${typeName}>>) {`\n    );\n    lines.push(`  const mutation = useDelete<${typeName}>(options);`);\n    lines.push('  return {');\n    lines.push('    ...mutation,');\n    lines.push(\n      `    mutate: (where: DeleteVariables<${typeName}>['where']) => mutation.mutate({ table: '${tableName}', where }),`\n    );\n    lines.push(\n      `    mutateAsync: (where: DeleteVariables<${typeName}>['where']) => mutation.mutateAsync({ table: '${tableName}', where }),`\n    );\n    lines.push('  };');\n    lines.push('}');\n    lines.push('');\n  }\n\n  return lines;\n}\n\nexport function generateHooks(\n  schemas: Map<string, SchemaDefinition>,\n  options: HooksGeneratorOptions = {}\n): string {\n  const {\n    typesImportPath = './types',\n    includeQueryHooks = true,\n    includeMutationHooks = true,\n  } = options;\n\n  const lines: string[] = [\n    '// Auto-generated by @launchpad/db-engine',\n    '// Do not edit this file manually',\n    '',\n  ];\n\n  if (includeQueryHooks) {\n    lines.push(\"import { useQuery, useQueryOne } from '@launchpad/db/react';\");\n    lines.push(\"import type { UseQueryOptions } from '@launchpad/db/react';\");\n  }\n\n  if (includeMutationHooks) {\n    lines.push(\"import { useInsert, useUpdate, useDelete } from '@launchpad/db/react';\");\n    lines.push(\n      \"import type { UseMutationOptions, InsertVariables, UpdateVariables, DeleteVariables } from '@launchpad/db/react';\"\n    );\n  }\n\n  const typeImports: string[] = [];\n  for (const [schemaName, schema] of schemas) {\n    const namespace = pascalCase(schemaName);\n    for (const tableName of Object.keys(schema.tables)) {\n      const typeName = pascalCase(tableName);\n      typeImports.push(`${namespace}.${typeName}`);\n      if (includeMutationHooks) {\n        typeImports.push(`${namespace}.${typeName}Insert`);\n        typeImports.push(`${namespace}.${typeName}Update`);\n      }\n    }\n  }\n\n  if (typeImports.length > 0) {\n    const namespaces = new Set<string>();\n    for (const [schemaName] of schemas) {\n      namespaces.add(pascalCase(schemaName));\n    }\n    lines.push(`import type { ${Array.from(namespaces).join(', ')} } from '${typesImportPath}';`);\n  }\n\n  lines.push('');\n\n  for (const [schemaName, schema] of schemas) {\n    const namespace = pascalCase(schemaName);\n\n    for (const tableName of Object.keys(schema.tables)) {\n      const typeName = `${namespace}.${pascalCase(tableName)}`;\n      const tableHooks = generateTableHooks(tableName, typeName, {\n        includeQueryHooks,\n        includeMutationHooks,\n        typesImportPath,\n      });\n      lines.push(...tableHooks);\n    }\n  }\n\n  return lines.join('\\n');\n}\n"],"mappings":"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","names":["result","result","mkdir","readFile","writeFile","dirname","join","createMySQLDriver","createSQLiteDriver","createMongoDriver","trimmed","readFile","readdir","join","trimmed","readFile","join","join","readFile","createHash","createHash","result","fk","createHash","createHash","createHash","pascalCase","join","mkdir","writeFile","dirname","driver","registry","readFile"]}