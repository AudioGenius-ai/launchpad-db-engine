{"version":3,"sources":["../../src/driver/health.ts","../../src/driver/query-tracker.ts","../../src/driver/retry.ts","../../src/driver/mongodb.ts","../../src/driver/mysql.ts","../../src/driver/sqlite.ts","../../src/cli/index.ts","../../src/driver/postgresql.ts","../../src/driver/index.ts","../../src/migrations/runner.ts","../../src/migrations/dialects/mysql.ts","../../src/migrations/dialects/postgresql.ts","../../src/migrations/dialects/sqlite.ts","../../src/migrations/dialects/index.ts","../../src/modules/collector.ts","../../src/modules/registry.ts","../../src/schema/registry.ts","../../src/types/generator.ts"],"sourcesContent":["export interface PoolStats {\n  totalConnections: number;\n  activeConnections: number;\n  idleConnections: number;\n  waitingRequests: number;\n  maxConnections: number;\n}\n\nexport interface HealthCheckResult {\n  healthy: boolean;\n  latencyMs: number;\n  lastCheckedAt: Date;\n  error?: string;\n}\n\nexport interface HealthCheckConfig {\n  enabled?: boolean;\n  intervalMs?: number;\n  timeoutMs?: number;\n  onHealthChange?: (healthy: boolean, result: HealthCheckResult) => void;\n}\n\nexport function createHealthCheckResult(\n  healthy: boolean,\n  latencyMs: number,\n  error?: string\n): HealthCheckResult {\n  return {\n    healthy,\n    latencyMs,\n    lastCheckedAt: new Date(),\n    ...(error && { error }),\n  };\n}\n\nexport function getDefaultHealthCheckConfig(\n  overrides?: Partial<HealthCheckConfig>\n): HealthCheckConfig {\n  return {\n    enabled: overrides?.enabled ?? false,\n    intervalMs: overrides?.intervalMs ?? 30000,\n    timeoutMs: overrides?.timeoutMs ?? 5000,\n    onHealthChange: overrides?.onHealthChange,\n  };\n}\n","export interface QueryInfo {\n  id: string;\n  query: string;\n  startedAt: Date;\n  backendPid?: number;\n}\n\nexport class QueryTracker {\n  private activeQueries = new Map<string, QueryInfo>();\n  private completedCount = 0;\n  private cancelledCount = 0;\n  private draining = false;\n  private drainResolve: (() => void) | null = null;\n\n  trackQuery(id: string, query: string, backendPid?: number): void {\n    if (this.draining) {\n      throw new Error('Driver is draining - new queries are not accepted');\n    }\n    this.activeQueries.set(id, {\n      id,\n      query: query.slice(0, 200),\n      startedAt: new Date(),\n      backendPid,\n    });\n  }\n\n  untrackQuery(id: string): void {\n    if (this.activeQueries.delete(id)) {\n      this.completedCount++;\n      if (this.draining && this.activeQueries.size === 0 && this.drainResolve) {\n        this.drainResolve();\n      }\n    }\n  }\n\n  getActiveCount(): number {\n    return this.activeQueries.size;\n  }\n\n  getActiveQueries(): QueryInfo[] {\n    return Array.from(this.activeQueries.values());\n  }\n\n  async startDrain(timeoutMs: number): Promise<{ timedOut: boolean }> {\n    this.draining = true;\n\n    if (this.activeQueries.size === 0) {\n      return { timedOut: false };\n    }\n\n    const drainPromise = new Promise<void>((resolve) => {\n      this.drainResolve = resolve;\n    });\n\n    const timeoutPromise = new Promise<'timeout'>((resolve) => {\n      setTimeout(() => resolve('timeout'), timeoutMs);\n    });\n\n    const result = await Promise.race([\n      drainPromise.then(() => 'drained' as const),\n      timeoutPromise,\n    ]);\n\n    return { timedOut: result === 'timeout' };\n  }\n\n  markCancelled(id: string): void {\n    if (this.activeQueries.delete(id)) {\n      this.cancelledCount++;\n      if (this.draining && this.activeQueries.size === 0 && this.drainResolve) {\n        this.drainResolve();\n      }\n    }\n  }\n\n  getStats(): { completed: number; cancelled: number; active: number } {\n    return {\n      completed: this.completedCount,\n      cancelled: this.cancelledCount,\n      active: this.activeQueries.size,\n    };\n  }\n\n  isDraining(): boolean {\n    return this.draining;\n  }\n\n  reset(): void {\n    this.activeQueries.clear();\n    this.completedCount = 0;\n    this.cancelledCount = 0;\n    this.draining = false;\n    this.drainResolve = null;\n  }\n}\n","export interface RetryConfig {\n  maxRetries?: number;\n  baseDelayMs?: number;\n  maxDelayMs?: number;\n  retryableErrors?: string[];\n}\n\nconst DEFAULT_RETRYABLE_ERRORS = [\n  'ECONNREFUSED',\n  'ETIMEDOUT',\n  'ECONNRESET',\n  'EPIPE',\n  'ENOTCONN',\n  '57P01',\n  '57P02',\n  '57P03',\n  'PROTOCOL_CONNECTION_LOST',\n  'ER_CON_COUNT_ERROR',\n];\n\nexport function isRetryableError(error: unknown, customErrors: string[] = []): boolean {\n  const allErrors = [...DEFAULT_RETRYABLE_ERRORS, ...customErrors];\n\n  if (error instanceof Error) {\n    const errorCode = (error as Error & { code?: string }).code;\n    const errorMessage = error.message;\n\n    return allErrors.some((code) => errorCode === code || errorMessage.includes(code));\n  }\n  return false;\n}\n\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  config: RetryConfig = {}\n): Promise<T> {\n  const maxRetries = config.maxRetries ?? 3;\n  const baseDelayMs = config.baseDelayMs ?? 100;\n  const maxDelayMs = config.maxDelayMs ?? 5000;\n  const retryableErrors = config.retryableErrors ?? [];\n\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === maxRetries || !isRetryableError(error, retryableErrors)) {\n        throw error;\n      }\n\n      const delay = Math.min(baseDelayMs * 2 ** attempt, maxDelayMs);\n      const jitter = Math.random() * delay * 0.1;\n\n      console.warn(\n        `[db-engine] Connection error (attempt ${attempt + 1}/${maxRetries + 1}), retrying in ${Math.round(delay)}ms:`,\n        lastError.message\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, delay + jitter));\n    }\n  }\n\n  throw lastError;\n}\n\nexport function createTimeoutPromise<T>(timeoutMs: number): Promise<T> {\n  return new Promise((_, reject) =>\n    setTimeout(() => reject(new Error('Health check timeout')), timeoutMs)\n  );\n}\n","import type { MongoOperation, QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport type { Driver, DriverConfig, DrainOptions, DrainResult, TransactionClient } from './types.js';\n\nlet mongodbModule: typeof import('mongodb') | null = null;\n\nasync function getMongoDBModule(): Promise<typeof import('mongodb')> {\n  if (!mongodbModule) {\n    try {\n      mongodbModule = await import('mongodb');\n    } catch {\n      throw new Error(\n        'MongoDB driver not found. Please install mongodb package: npm install mongodb'\n      );\n    }\n  }\n  return mongodbModule;\n}\n\nexport interface MongoDriverConfig extends DriverConfig {\n  database?: string;\n}\n\nexport interface MongoDriver extends Driver {\n  executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>>;\n  getDb(): unknown;\n  collection(name: string): unknown;\n}\n\nexport async function createMongoDriver(config: MongoDriverConfig): Promise<MongoDriver> {\n  const mongodb = await getMongoDBModule();\n  const { MongoClient } = mongodb;\n\n  const maxConnections = config.max ?? 10;\n\n  const client = new MongoClient(config.connectionString, {\n    maxPoolSize: maxConnections,\n    serverSelectionTimeoutMS: config.connectTimeout ?? 5000,\n    maxIdleTimeMS: config.idleTimeout ?? 30000,\n  });\n\n  await client.connect();\n  const db = client.db(config.database);\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `mongo-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      await db.command({ ping: 1 });\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  async function executeOperation<T = Record<string, unknown>>(\n    op: MongoOperation\n  ): Promise<QueryResult<T>> {\n    const queryId = generateQueryId();\n    tracker.trackQuery(queryId, `${op.type}:${op.collection}`);\n\n    try {\n      const collection = db.collection(op.collection);\n\n      switch (op.type) {\n        case 'find': {\n          let cursor = collection.find(op.filter ?? {});\n          if (op.options?.sort) cursor = cursor.sort(op.options.sort);\n          if (op.options?.skip) cursor = cursor.skip(op.options.skip);\n          if (op.options?.limit) cursor = cursor.limit(op.options.limit);\n          if (op.options?.projection) cursor = cursor.project(op.options.projection);\n          const rows = await cursor.toArray();\n          return { rows: rows as T[], rowCount: rows.length };\n        }\n\n        case 'aggregate': {\n          const result = await collection.aggregate(op.pipeline!).toArray();\n          return { rows: result as T[], rowCount: result.length };\n        }\n\n        case 'insertOne': {\n          const result = await collection.insertOne(op.document!);\n          const doc = { ...op.document, _id: result.insertedId } as T;\n          return { rows: [doc], rowCount: 1 };\n        }\n\n        case 'insertMany': {\n          const result = await collection.insertMany(op.documents!);\n          return { rows: op.documents as T[], rowCount: result.insertedCount };\n        }\n\n        case 'updateOne': {\n          const result = await collection.updateOne(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'updateMany': {\n          const result = await collection.updateMany(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'deleteOne': {\n          const result = await collection.deleteOne(op.filter!);\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'deleteMany': {\n          const result = await collection.deleteMany(op.filter!);\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'findOneAndUpdate': {\n          const result = await collection.findOneAndUpdate(op.filter!, op.update!, {\n            returnDocument: op.options?.returnDocument ?? 'after',\n            upsert: op.options?.upsert,\n            projection: op.options?.projection,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'findOneAndDelete': {\n          const result = await collection.findOneAndDelete(op.filter!, {\n            projection: op.options?.projection,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'countDocuments': {\n          const count = await collection.countDocuments(op.filter ?? {});\n          return { rows: [{ count } as T], rowCount: 1 };\n        }\n\n        default:\n          throw new Error(`Unsupported MongoDB operation: ${(op as MongoOperation).type}`);\n      }\n    } finally {\n      tracker.untrackQuery(queryId);\n    }\n  }\n\n  async function executeOperationWithSession<T = Record<string, unknown>>(\n    op: MongoOperation,\n    session: import('mongodb').ClientSession\n  ): Promise<QueryResult<T>> {\n    const queryId = generateQueryId();\n    tracker.trackQuery(queryId, `${op.type}:${op.collection}`);\n\n    try {\n      const collection = db.collection(op.collection);\n\n      switch (op.type) {\n        case 'find': {\n          let cursor = collection.find(op.filter ?? {}, { session });\n          if (op.options?.sort) cursor = cursor.sort(op.options.sort);\n          if (op.options?.skip) cursor = cursor.skip(op.options.skip);\n          if (op.options?.limit) cursor = cursor.limit(op.options.limit);\n          if (op.options?.projection) cursor = cursor.project(op.options.projection);\n          const rows = await cursor.toArray();\n          return { rows: rows as T[], rowCount: rows.length };\n        }\n\n        case 'aggregate': {\n          const result = await collection.aggregate(op.pipeline!, { session }).toArray();\n          return { rows: result as T[], rowCount: result.length };\n        }\n\n        case 'insertOne': {\n          const result = await collection.insertOne(op.document!, { session });\n          const doc = { ...op.document, _id: result.insertedId } as T;\n          return { rows: [doc], rowCount: 1 };\n        }\n\n        case 'insertMany': {\n          const result = await collection.insertMany(op.documents!, { session });\n          return { rows: op.documents as T[], rowCount: result.insertedCount };\n        }\n\n        case 'updateOne': {\n          const result = await collection.updateOne(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n            session,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'updateMany': {\n          const result = await collection.updateMany(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n            session,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'deleteOne': {\n          const result = await collection.deleteOne(op.filter!, { session });\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'deleteMany': {\n          const result = await collection.deleteMany(op.filter!, { session });\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'findOneAndUpdate': {\n          const result = await collection.findOneAndUpdate(op.filter!, op.update!, {\n            returnDocument: op.options?.returnDocument ?? 'after',\n            upsert: op.options?.upsert,\n            projection: op.options?.projection,\n            session,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'findOneAndDelete': {\n          const result = await collection.findOneAndDelete(op.filter!, {\n            projection: op.options?.projection,\n            session,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'countDocuments': {\n          const count = await collection.countDocuments(op.filter ?? {}, { session });\n          return { rows: [{ count } as T], rowCount: 1 };\n        }\n\n        default:\n          throw new Error(`Unsupported MongoDB operation: ${(op as MongoOperation).type}`);\n      }\n    } finally {\n      tracker.untrackQuery(queryId);\n    }\n  }\n\n  const driver: MongoDriver = {\n    dialect: 'mongodb',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      _sql: string,\n      _params?: unknown[]\n    ): Promise<QueryResult<T>> {\n      throw new Error(\n        'MongoDriver does not support SQL queries. Use executeOperation() with MongoOperation instead.'\n      );\n    },\n\n    async execute(_sql: string, _params?: unknown[]): Promise<{ rowCount: number }> {\n      throw new Error(\n        'MongoDriver does not support SQL execution. Use executeOperation() with MongoOperation instead.'\n      );\n    },\n\n    async transaction<T>(fn: (trx: MongoTransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const session = client.startSession();\n      try {\n        session.startTransaction();\n        const trxClient = new MongoTransactionClientImpl(session, executeOperationWithSession);\n        const result = await fn(trxClient);\n        await session.commitTransaction();\n        return result;\n      } catch (error) {\n        await session.abortTransaction();\n        throw error;\n      } finally {\n        await session.endSession();\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, ${activeQueries.length} queries still active`);\n        cancelledQueries = activeQueries.length;\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          tracker.markCancelled(query.id);\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connection');\n      await client.close(true);\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await client.close();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: maxConnections,\n        activeConnections: 0,\n        idleConnections: maxConnections,\n        waitingRequests: 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n\n    executeOperation,\n\n    getDb() {\n      return db;\n    },\n\n    collection(name: string) {\n      return db.collection(name);\n    },\n  };\n\n  return driver;\n}\n\nexport interface MongoTransactionClient extends TransactionClient {\n  executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>>;\n}\n\nclass MongoTransactionClientImpl implements MongoTransactionClient {\n  constructor(\n    private session: import('mongodb').ClientSession,\n    private execWithSession: <T>(\n      op: MongoOperation,\n      session: import('mongodb').ClientSession\n    ) => Promise<QueryResult<T>>\n  ) {}\n\n  async query<T = Record<string, unknown>>(\n    _sql: string,\n    _params?: unknown[]\n  ): Promise<QueryResult<T>> {\n    throw new Error('MongoTransactionClient does not support SQL queries.');\n  }\n\n  async execute(_sql: string, _params?: unknown[]): Promise<{ rowCount: number }> {\n    throw new Error('MongoTransactionClient does not support SQL execution.');\n  }\n\n  async executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>> {\n    return this.execWithSession<T>(op, this.session);\n  }\n}\n\nexport function isMongoDriver(driver: Driver): driver is MongoDriver {\n  return driver.dialect === 'mongodb' && 'executeOperation' in driver;\n}\n","import type { PoolConnection } from 'mysql2/promise';\nimport type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport { createTimeoutPromise } from './retry.js';\nimport type { Driver, DriverConfig, DrainOptions, DrainResult, TransactionClient } from './types.js';\n\nexport async function createMySQLDriver(config: DriverConfig): Promise<Driver> {\n  const mysql = await import('mysql2/promise');\n\n  const pool = mysql.createPool({\n    uri: config.connectionString,\n    waitForConnections: true,\n    connectionLimit: config.max ?? 20,\n    idleTimeout: (config.idleTimeout ?? 30) * 1000,\n    connectTimeout: (config.connectTimeout ?? 10) * 1000,\n  });\n\n  const maxConnections = config.max ?? 20;\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `mysql-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      const connection = (await Promise.race([\n        pool.getConnection(),\n        createTimeoutPromise<never>(healthCheckConfig.timeoutMs ?? 5000),\n      ])) as PoolConnection;\n\n      await connection.ping();\n      connection.release();\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'mysql',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const [rows] = await pool.execute(queryText, params);\n        const resultRows = Array.isArray(rows) ? rows : [];\n        return {\n          rows: resultRows as T[],\n          rowCount: resultRows.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const [result] = await pool.execute(queryText, params);\n        const affectedRows = (result as { affectedRows?: number }).affectedRows ?? 0;\n        return { rowCount: affectedRows };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const connection = await pool.getConnection();\n      await connection.beginTransaction();\n\n      try {\n        const client: TransactionClient = {\n          async query<R = Record<string, unknown>>(\n            queryText: string,\n            params: unknown[] = []\n          ): Promise<QueryResult<R>> {\n            const [rows] = await connection.execute(queryText, params);\n            const resultRows = Array.isArray(rows) ? rows : [];\n            return {\n              rows: resultRows as R[],\n              rowCount: resultRows.length,\n            };\n          },\n\n          async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n            const [result] = await connection.execute(queryText, params);\n            const affectedRows = (result as { affectedRows?: number }).affectedRows ?? 0;\n            return { rowCount: affectedRows };\n          },\n        };\n\n        const result = await fn(client);\n        await connection.commit();\n        return result;\n      } catch (error) {\n        await connection.rollback();\n        throw error;\n      } finally {\n        connection.release();\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n      const forceCancelOnTimeout = options.forceCancelOnTimeout ?? true;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut && forceCancelOnTimeout) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, cancelling ${activeQueries.length} queries`);\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          if (query.backendPid) {\n            try {\n              await pool.execute(`KILL QUERY ${query.backendPid}`);\n              tracker.markCancelled(query.id);\n              cancelledQueries++;\n            } catch (e) {\n              console.warn(`[db-engine] Failed to cancel query ${query.id}:`, e);\n            }\n          } else {\n            tracker.markCancelled(query.id);\n            cancelledQueries++;\n          }\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connections');\n      await pool.end();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await pool.end();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      const poolState = (pool as unknown as { pool?: MySQLPoolState }).pool;\n      return {\n        totalConnections: poolState?._allConnections?.length ?? 0,\n        activeConnections: poolState?._acquiringConnections?.length ?? 0,\n        idleConnections: poolState?._freeConnections?.length ?? 0,\n        waitingRequests: poolState?._connectionQueue?.length ?? 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n\ninterface MySQLPoolState {\n  _allConnections?: unknown[];\n  _acquiringConnections?: unknown[];\n  _freeConnections?: unknown[];\n  _connectionQueue?: unknown[];\n}\n","import type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport type { Driver, DriverConfig, DrainOptions, DrainResult, TransactionClient } from './types.js';\n\nexport async function createSQLiteDriver(config: DriverConfig): Promise<Driver> {\n  const Database = (await import('better-sqlite3')).default;\n\n  const dbPath = config.connectionString.replace('sqlite://', '').replace('file://', '');\n  const db = new Database(dbPath);\n\n  db.pragma('journal_mode = WAL');\n  db.pragma('foreign_keys = ON');\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `sqlite-${++queryIdCounter}`;\n\n  function performHealthCheck(): HealthCheckResult {\n    const startTime = Date.now();\n    try {\n      db.prepare('SELECT 1').get();\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'sqlite',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const stmt = db.prepare(queryText);\n        const rows = stmt.all(...params) as T[];\n        return {\n          rows,\n          rowCount: rows.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const stmt = db.prepare(queryText);\n        const result = stmt.run(...params);\n        return { rowCount: result.changes };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const client: TransactionClient = {\n        async query<R = Record<string, unknown>>(\n          queryText: string,\n          params: unknown[] = []\n        ): Promise<QueryResult<R>> {\n          const stmt = db.prepare(queryText);\n          const rows = stmt.all(...params) as R[];\n          return {\n            rows,\n            rowCount: rows.length,\n          };\n        },\n\n        async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n          const stmt = db.prepare(queryText);\n          const result = stmt.run(...params);\n          return { rowCount: result.changes };\n        },\n      };\n\n      let result: T;\n      let committed = false;\n\n      db.prepare('BEGIN IMMEDIATE').run();\n      try {\n        result = await fn(client);\n        db.prepare('COMMIT').run();\n        committed = true;\n        return result;\n      } catch (error) {\n        if (!committed) {\n          db.prepare('ROLLBACK').run();\n        }\n        throw error;\n      } finally {\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries: 0,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connection');\n      db.close();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries: 0,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      db.close();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: 1,\n        activeConnections: lastHealthCheck.healthy ? 1 : 0,\n        idleConnections: 0,\n        waitingRequests: 0,\n        maxConnections: 1,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n","import { mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport { createDriver } from '../driver/index.js';\nimport { MigrationRunner } from '../migrations/runner.js';\nimport { MigrationCollector } from '../modules/collector.js';\nimport { ModuleRegistry } from '../modules/registry.js';\nimport type { ModuleDefinition } from '../modules/types.js';\nimport { SchemaRegistry } from '../schema/registry.js';\nimport { generateTypes } from '../types/generator.js';\nimport type { SchemaDefinition } from '../types/index.js';\n\nexport interface CliConfig {\n  databaseUrl: string;\n  migrationsPath: string;\n  typesOutputPath?: string;\n}\n\nexport async function runMigrations(\n  config: CliConfig,\n  options: {\n    scope?: 'core' | 'template';\n    templateKey?: string;\n    steps?: number;\n    toVersion?: number;\n    dryRun?: boolean;\n    direction: 'up' | 'down';\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const runner = new MigrationRunner(driver, { migrationsPath: config.migrationsPath });\n\n  try {\n    const results =\n      options.direction === 'up' ? await runner.up(options) : await runner.down(options);\n\n    for (const result of results) {\n      if (result.success) {\n        console.log(`✓ ${result.version}__${result.name} (${result.duration}ms)`);\n      } else {\n        console.error(`✗ ${result.version}__${result.name}: ${result.error}`);\n      }\n    }\n\n    if (results.length === 0) {\n      console.log('No migrations to run');\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function getMigrationStatus(\n  config: CliConfig,\n  options: {\n    scope?: 'core' | 'template';\n    templateKey?: string;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const runner = new MigrationRunner(driver, { migrationsPath: config.migrationsPath });\n\n  try {\n    const status = await runner.status(options);\n\n    console.log('\\n=== Migration Status ===\\n');\n\n    if (status.current !== null) {\n      console.log(`Current version: ${status.current}`);\n    } else {\n      console.log('Current version: (none)');\n    }\n\n    console.log(`\\nApplied (${status.applied.length}):`);\n    for (const m of status.applied) {\n      console.log(`  ✓ ${m.version}__${m.name} (${m.appliedAt.toISOString()})`);\n    }\n\n    console.log(`\\nPending (${status.pending.length}):`);\n    for (const m of status.pending) {\n      console.log(`  ○ ${m.version}__${m.name}`);\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function verifyMigrations(\n  config: CliConfig,\n  options: {\n    scope?: 'core' | 'template';\n    templateKey?: string;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const runner = new MigrationRunner(driver, { migrationsPath: config.migrationsPath });\n\n  try {\n    const result = await runner.verify(options);\n\n    if (result.valid) {\n      console.log('✓ All migrations are valid');\n    } else {\n      console.error('✗ Migration verification failed:');\n      for (const issue of result.issues) {\n        console.error(`  - ${issue}`);\n      }\n      process.exit(1);\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function createMigration(\n  config: CliConfig,\n  options: {\n    name: string;\n    scope: 'core' | 'template';\n    templateKey?: string;\n  }\n): Promise<void> {\n  const timestamp = new Date()\n    .toISOString()\n    .replace(/[-:T.Z]/g, '')\n    .slice(0, 14);\n  const filename = `${timestamp}__${options.name}.sql`;\n\n  const dirPath =\n    options.scope === 'template' && options.templateKey\n      ? join(config.migrationsPath, 'templates', options.templateKey)\n      : join(config.migrationsPath, 'core');\n\n  await mkdir(dirPath, { recursive: true });\n\n  const filePath = join(dirPath, filename);\n  const content = `-- ${filename}\n-- Created: ${new Date().toISOString()}\n\n-- up\n\n\n-- down\n\n`;\n\n  await writeFile(filePath, content, 'utf-8');\n  console.log(`Created migration: ${filePath}`);\n}\n\nexport async function generateTypesFromRegistry(\n  config: CliConfig,\n  options: {\n    appId?: string;\n    outputPath?: string;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new SchemaRegistry(driver);\n\n  try {\n    const schemas = await registry.listSchemas(options.appId);\n\n    if (schemas.length === 0) {\n      console.log('No schemas registered');\n      return;\n    }\n\n    const schemaMap = new Map<string, SchemaDefinition>();\n    for (const record of schemas) {\n      schemaMap.set(record.schema_name, record.schema);\n    }\n\n    const types = generateTypes(schemaMap);\n    const outputPath = options.outputPath ?? config.typesOutputPath ?? './generated/types.ts';\n\n    await mkdir(dirname(outputPath), { recursive: true });\n    await writeFile(outputPath, types, 'utf-8');\n\n    console.log(`Generated types: ${outputPath}`);\n    console.log(`  Schemas: ${Array.from(schemaMap.keys()).join(', ')}`);\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function registerSchema(\n  config: CliConfig,\n  options: {\n    appId: string;\n    schemaName: string;\n    version: string;\n    schemaPath: string;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new SchemaRegistry(driver);\n\n  try {\n    // Verify file exists by reading it\n    await readFile(options.schemaPath, 'utf-8');\n    const schemaModule = await import(options.schemaPath);\n    const schema: SchemaDefinition = schemaModule.schema || schemaModule.default;\n\n    if (!schema?.tables) {\n      throw new Error('Invalid schema file. Must export a SchemaDefinition with tables property.');\n    }\n\n    const results = await registry.register({\n      appId: options.appId,\n      schemaName: options.schemaName,\n      version: options.version,\n      schema,\n    });\n\n    if (results.length === 0) {\n      console.log('Schema is up to date');\n    } else {\n      console.log(`Applied ${results.length} schema changes:`);\n      for (const result of results) {\n        if (result.success) {\n          console.log(`  ✓ ${result.name}`);\n        } else {\n          console.error(`  ✗ ${result.name}: ${result.error}`);\n        }\n      }\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function listModules(config: CliConfig): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new ModuleRegistry(driver);\n\n  try {\n    const modules = await registry.list();\n\n    console.log('\\n=== Registered Modules ===\\n');\n\n    if (modules.length === 0) {\n      console.log('No modules registered');\n      return;\n    }\n\n    for (const mod of modules) {\n      console.log(`${mod.name} (v${mod.version})`);\n      console.log(`  Display name: ${mod.displayName}`);\n      if (mod.description) {\n        console.log(`  Description: ${mod.description}`);\n      }\n      console.log(`  Migration prefix: ${mod.migrationPrefix}`);\n      if (mod.dependencies?.length) {\n        console.log(`  Dependencies: ${mod.dependencies.join(', ')}`);\n      }\n      console.log();\n    }\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function registerModule(\n  config: CliConfig,\n  options: {\n    name: string;\n    displayName: string;\n    version: string;\n    migrationPrefix: string;\n    description?: string;\n    dependencies?: string[];\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const registry = new ModuleRegistry(driver);\n\n  try {\n    const module: ModuleDefinition = {\n      name: options.name,\n      displayName: options.displayName,\n      version: options.version,\n      migrationPrefix: options.migrationPrefix,\n      description: options.description,\n      dependencies: options.dependencies,\n    };\n\n    await registry.register(module);\n    console.log(`✓ Registered module: ${options.name} (v${options.version})`);\n  } finally {\n    await driver.close();\n  }\n}\n\nexport async function runModuleMigrations(\n  config: CliConfig,\n  options: {\n    modulesPath: string;\n    dryRun?: boolean;\n    direction?: 'up' | 'down';\n    steps?: number;\n  }\n): Promise<void> {\n  const driver = await createDriver({ connectionString: config.databaseUrl });\n  const runner = new MigrationRunner(driver, { migrationsPath: config.migrationsPath });\n  const collector = new MigrationCollector();\n\n  try {\n    const sources = await collector.discoverFromDirectory(options.modulesPath);\n\n    if (sources.length === 0) {\n      console.log('No module migrations found');\n      return;\n    }\n\n    console.log(`Found ${sources.length} module(s):`);\n    for (const source of sources) {\n      console.log(`  - ${source.moduleName}`);\n    }\n    console.log();\n\n    const migrations = await collector.collect(sources);\n\n    if (migrations.length === 0) {\n      console.log('No migrations to run');\n      return;\n    }\n\n    await runner.ensureMigrationsTable();\n\n    const direction = options.direction ?? 'up';\n    let migrationsToRun = migrations;\n\n    if (options.steps) {\n      migrationsToRun =\n        direction === 'up'\n          ? migrations.slice(0, options.steps)\n          : migrations.slice(-options.steps).reverse();\n    }\n\n    for (const migration of migrationsToRun) {\n      if (options.dryRun) {\n        console.log(\n          `[DRY RUN] Would ${direction === 'up' ? 'apply' : 'rollback'}: ${migration.version}__${migration.name} (module: ${migration.moduleName})`\n        );\n        continue;\n      }\n\n      const startTime = Date.now();\n      try {\n        const statements = direction === 'up' ? migration.up : migration.down;\n        for (const sql of statements) {\n          await driver.execute(sql);\n        }\n        console.log(\n          `✓ ${migration.version}__${migration.name} (module: ${migration.moduleName}) (${Date.now() - startTime}ms)`\n        );\n      } catch (error) {\n        console.error(\n          `✗ ${migration.version}__${migration.name} (module: ${migration.moduleName}): ${error instanceof Error ? error.message : error}`\n        );\n        break;\n      }\n    }\n  } finally {\n    await driver.close();\n  }\n}\n","import postgres, { type ParameterOrJSON } from 'postgres';\nimport type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport { createTimeoutPromise } from './retry.js';\nimport type { Driver, DriverConfig, DrainOptions, DrainResult, TransactionClient } from './types.js';\n\nexport function createPostgresDriver(config: DriverConfig): Driver {\n  const sql = postgres(config.connectionString, {\n    max: config.max ?? 20,\n    idle_timeout: config.idleTimeout ?? 30,\n    connect_timeout: config.connectTimeout ?? 10,\n    prepare: true,\n  });\n\n  const maxConnections = config.max ?? 20;\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `pg-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      await Promise.race([\n        sql`SELECT 1`,\n        createTimeoutPromise<never>(healthCheckConfig.timeoutMs ?? 5000),\n      ]);\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'postgresql',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const result = await sql.unsafe<T[]>(queryText, params as ParameterOrJSON<never>[]);\n        return {\n          rows: result as T[],\n          rowCount: result.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const result = await sql.unsafe(queryText, params as ParameterOrJSON<never>[]);\n        return { rowCount: result.count ?? 0 };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      try {\n        const result = await sql.begin(async (tx) => {\n          const client: TransactionClient = {\n            async query<R = Record<string, unknown>>(\n              queryText: string,\n              params: unknown[] = []\n            ): Promise<QueryResult<R>> {\n              const txResult = await tx.unsafe<R[]>(queryText, params as ParameterOrJSON<never>[]);\n              return {\n                rows: txResult as R[],\n                rowCount: txResult.length,\n              };\n            },\n\n            async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n              const txResult = await tx.unsafe(queryText, params as ParameterOrJSON<never>[]);\n              return { rowCount: txResult.count ?? 0 };\n            },\n          };\n\n          return fn(client);\n        });\n        return result as T;\n      } finally {\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n      const forceCancelOnTimeout = options.forceCancelOnTimeout ?? true;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut && forceCancelOnTimeout) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, cancelling ${activeQueries.length} queries`);\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          try {\n            await sql.unsafe(\n              `SELECT pg_cancel_backend(pid) FROM pg_stat_activity\n               WHERE state = 'active' AND query LIKE $1`,\n              [`%${query.query.slice(0, 50)}%`]\n            );\n            tracker.markCancelled(query.id);\n            cancelledQueries++;\n          } catch (e) {\n            console.warn(`[db-engine] Failed to cancel query ${query.id}:`, e);\n          }\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connections');\n      await sql.end();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await sql.end();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: maxConnections,\n        activeConnections: (sql as unknown as { connections?: number }).connections ?? 0,\n        idleConnections:\n          maxConnections - ((sql as unknown as { connections?: number }).connections ?? 0),\n        waitingRequests: 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n","import type { DialectName } from '../types/index.js';\nimport { createPostgresDriver } from './postgresql.js';\nimport type { Driver, DriverConfig } from './types.js';\n\nexport type {\n  Driver,\n  DriverConfig,\n  TransactionClient,\n  DrainOptions,\n  DrainProgress,\n  DrainResult,\n  DrainPhase,\n} from './types.js';\nexport type { MongoDriver, MongoDriverConfig, MongoTransactionClient } from './mongodb.js';\nexport { createMongoDriver, isMongoDriver } from './mongodb.js';\nexport { QueryTracker, type QueryInfo } from './query-tracker.js';\nexport { registerSignalHandlers, type SignalHandlerOptions } from './signal-handler.js';\n\nexport type {\n  PoolStats,\n  HealthCheckResult,\n  HealthCheckConfig,\n} from './health.js';\nexport {\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\n\nexport type { PoolMonitorConfig, PoolMonitor } from './pool-monitor.js';\nexport { createPoolMonitor } from './pool-monitor.js';\n\nexport type { RetryConfig } from './retry.js';\nexport { isRetryableError, withRetry, createTimeoutPromise } from './retry.js';\n\nexport interface CreateDriverOptions extends DriverConfig {\n  dialect?: DialectName;\n  database?: string;\n}\n\nexport function detectDialect(connectionString: string): DialectName {\n  if (connectionString.startsWith('mongodb://') || connectionString.startsWith('mongodb+srv://')) {\n    return 'mongodb';\n  }\n  if (connectionString.startsWith('postgres://') || connectionString.startsWith('postgresql://')) {\n    return 'postgresql';\n  }\n  if (connectionString.startsWith('mysql://') || connectionString.startsWith('mariadb://')) {\n    return 'mysql';\n  }\n  if (\n    connectionString.startsWith('sqlite://') ||\n    connectionString.startsWith('file://') ||\n    connectionString.endsWith('.db') ||\n    connectionString.endsWith('.sqlite') ||\n    connectionString.endsWith('.sqlite3')\n  ) {\n    return 'sqlite';\n  }\n  throw new Error(`Unable to detect database dialect from connection string: ${connectionString}`);\n}\n\nexport async function createDriver(options: CreateDriverOptions): Promise<Driver> {\n  const dialect = options.dialect ?? detectDialect(options.connectionString);\n\n  switch (dialect) {\n    case 'postgresql':\n      return createPostgresDriver(options);\n\n    case 'mysql': {\n      const { createMySQLDriver } = await import('./mysql.js');\n      return createMySQLDriver(options);\n    }\n\n    case 'sqlite': {\n      const { createSQLiteDriver } = await import('./sqlite.js');\n      return createSQLiteDriver(options);\n    }\n\n    case 'mongodb': {\n      const { createMongoDriver } = await import('./mongodb.js');\n      return createMongoDriver(options);\n    }\n\n    default:\n      throw new Error(`Unsupported dialect: ${dialect}`);\n  }\n}\n","import { createHash } from 'node:crypto';\nimport { readFile, readdir } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { Driver } from '../driver/types.js';\nimport type {\n  MigrationFile,\n  MigrationRecord,\n  MigrationResult,\n  MigrationStatus,\n} from '../types/index.js';\nimport { getDialect } from './dialects/index.js';\nimport type { Dialect } from './dialects/types.js';\n\nexport interface MigrationRunnerOptions {\n  migrationsPath: string;\n  tableName?: string;\n}\n\nexport interface MigrationRunOptions {\n  scope?: 'core' | 'template';\n  templateKey?: string;\n  moduleName?: string;\n  steps?: number;\n  toVersion?: number;\n  dryRun?: boolean;\n}\n\nexport class MigrationRunner {\n  private driver: Driver;\n  private dialect: Dialect;\n  private migrationsPath: string;\n  private tableName: string;\n\n  constructor(driver: Driver, options: MigrationRunnerOptions) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.migrationsPath = options.migrationsPath;\n    this.tableName = options.tableName ?? 'lp_migrations';\n  }\n\n  async ensureMigrationsTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          version BIGINT PRIMARY KEY,\n          name TEXT NOT NULL,\n          scope TEXT NOT NULL CHECK (scope IN ('core', 'template')),\n          template_key TEXT,\n          module_name TEXT,\n          checksum TEXT NOT NULL,\n          up_sql TEXT[] NOT NULL,\n          down_sql TEXT[],\n          applied_at TIMESTAMPTZ DEFAULT NOW(),\n          executed_by TEXT\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            version BIGINT PRIMARY KEY,\n            name VARCHAR(255) NOT NULL,\n            scope VARCHAR(20) NOT NULL,\n            template_key VARCHAR(255),\n            module_name VARCHAR(255),\n            checksum VARCHAR(64) NOT NULL,\n            up_sql JSON NOT NULL,\n            down_sql JSON,\n            applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            executed_by VARCHAR(255)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            version INTEGER PRIMARY KEY,\n            name TEXT NOT NULL,\n            scope TEXT NOT NULL CHECK (scope IN ('core', 'template')),\n            template_key TEXT,\n            module_name TEXT,\n            checksum TEXT NOT NULL,\n            up_sql TEXT NOT NULL,\n            down_sql TEXT,\n            applied_at TEXT DEFAULT (datetime('now')),\n            executed_by TEXT\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(`\n        CREATE UNIQUE INDEX IF NOT EXISTS idx_${this.tableName}_scope_version\n        ON \"${this.tableName}\" (scope, COALESCE(template_key, ''), version)\n      `);\n    }\n  }\n\n  async up(options: MigrationRunOptions = {}): Promise<MigrationResult[]> {\n    await this.ensureMigrationsTable();\n\n    const pending = await this.getPendingMigrations(options);\n    const results: MigrationResult[] = [];\n\n    let migrationsToRun = pending;\n    if (options.steps) {\n      migrationsToRun = pending.slice(0, options.steps);\n    }\n    if (options.toVersion) {\n      migrationsToRun = pending.filter((m) => m.version <= options.toVersion!);\n    }\n\n    for (const migration of migrationsToRun) {\n      const startTime = Date.now();\n\n      if (options.dryRun) {\n        console.log(`[DRY RUN] Would apply migration: ${migration.version}__${migration.name}`);\n        console.log(migration.up.join('\\n'));\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: 0,\n        });\n        continue;\n      }\n\n      try {\n        if (this.dialect.supportsTransactionalDDL) {\n          await this.driver.transaction(async (trx) => {\n            for (const sql of migration.up) {\n              await trx.execute(sql);\n            }\n            await this.recordMigration(trx, migration);\n          });\n        } else {\n          for (const sql of migration.up) {\n            await this.driver.execute(sql);\n          }\n          await this.recordMigration(this.driver, migration);\n        }\n\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: Date.now() - startTime,\n        });\n      } catch (error) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n        break;\n      }\n    }\n\n    return results;\n  }\n\n  async down(options: MigrationRunOptions = {}): Promise<MigrationResult[]> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const results: MigrationResult[] = [];\n\n    let migrationsToRollback = applied.reverse();\n    if (options.steps) {\n      migrationsToRollback = migrationsToRollback.slice(0, options.steps);\n    }\n    if (options.toVersion) {\n      migrationsToRollback = migrationsToRollback.filter((m) => m.version > options.toVersion!);\n    }\n\n    for (const migration of migrationsToRollback) {\n      if (!migration.downSql?.length) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: 'No down migration available',\n          duration: 0,\n        });\n        break;\n      }\n\n      const startTime = Date.now();\n\n      if (options.dryRun) {\n        console.log(`[DRY RUN] Would rollback migration: ${migration.version}__${migration.name}`);\n        console.log(migration.downSql.join('\\n'));\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: 0,\n        });\n        continue;\n      }\n\n      try {\n        if (this.dialect.supportsTransactionalDDL) {\n          await this.driver.transaction(async (trx) => {\n            for (const sql of migration.downSql) {\n              await trx.execute(sql);\n            }\n            await this.removeMigrationRecord(trx, migration.version);\n          });\n        } else {\n          for (const sql of migration.downSql) {\n            await this.driver.execute(sql);\n          }\n          await this.removeMigrationRecord(this.driver, migration.version);\n        }\n\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: Date.now() - startTime,\n        });\n      } catch (error) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n        break;\n      }\n    }\n\n    return results;\n  }\n\n  async status(options: MigrationRunOptions = {}): Promise<MigrationStatus> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const pending = await this.getPendingMigrations(options);\n    const current = applied.length ? applied[applied.length - 1].version : null;\n\n    return { applied, pending, current };\n  }\n\n  async verify(options: MigrationRunOptions = {}): Promise<{ valid: boolean; issues: string[] }> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const files = await this.loadMigrationFiles(options);\n    const issues: string[] = [];\n\n    for (const record of applied) {\n      const file = files.find((f) => f.version === record.version);\n      if (!file) {\n        issues.push(`Migration ${record.version}__${record.name} was applied but file is missing`);\n        continue;\n      }\n\n      const fileChecksum = this.computeChecksum(file.up);\n      if (fileChecksum !== record.checksum) {\n        issues.push(\n          `Migration ${record.version}__${record.name} checksum mismatch. File has been modified after being applied.`\n        );\n      }\n    }\n\n    return { valid: issues.length === 0, issues };\n  }\n\n  private sanitizeTemplateKey(templateKey: string): string {\n    if (!/^[a-zA-Z0-9_-]+$/.test(templateKey)) {\n      throw new Error(\n        `Invalid templateKey: \"${templateKey}\". Only alphanumeric characters, hyphens, and underscores are allowed.`\n      );\n    }\n    return templateKey;\n  }\n\n  private async loadMigrationFiles(options: MigrationRunOptions = {}): Promise<MigrationFile[]> {\n    const scope = options.scope ?? 'core';\n    let dirPath: string;\n\n    if (scope === 'template' && options.templateKey) {\n      const sanitizedKey = this.sanitizeTemplateKey(options.templateKey);\n      dirPath = join(this.migrationsPath, 'templates', sanitizedKey);\n    } else {\n      dirPath = join(this.migrationsPath, 'core');\n    }\n\n    try {\n      const files = await readdir(dirPath);\n      const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();\n\n      const migrations: MigrationFile[] = [];\n\n      for (const file of sqlFiles) {\n        const content = await readFile(join(dirPath, file), 'utf-8');\n        const parsed = this.parseMigrationFile(file, content, scope, options.templateKey);\n        if (parsed) {\n          migrations.push(parsed);\n        }\n      }\n\n      return migrations;\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  private parseMigrationFile(\n    filename: string,\n    content: string,\n    scope: 'core' | 'template',\n    templateKey?: string\n  ): MigrationFile | null {\n    const match = filename.match(/^(\\d+)__(.+)\\.sql$/);\n    if (!match) return null;\n\n    const [, versionStr, name] = match;\n    const version = Number.parseInt(versionStr, 10);\n\n    const upMatch = content.match(/--\\s*up\\s*\\n([\\s\\S]*?)(?=--\\s*down|$)/i);\n    const downMatch = content.match(/--\\s*down\\s*\\n([\\s\\S]*?)$/i);\n\n    const up = upMatch ? this.splitSqlStatements(upMatch[1]) : [];\n    const down = downMatch ? this.splitSqlStatements(downMatch[1]) : [];\n\n    if (!up.length) return null;\n\n    return {\n      version,\n      name,\n      up,\n      down,\n      scope,\n      templateKey,\n    };\n  }\n\n  private async getAppliedMigrations(\n    options: MigrationRunOptions = {}\n  ): Promise<MigrationRecord[]> {\n    const scope = options.scope ?? 'core';\n    const templateKey = options.templateKey ?? null;\n    const moduleName = options.moduleName ?? null;\n\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT version, name, scope, template_key, module_name, checksum, up_sql, down_sql, applied_at, executed_by\n        FROM \"${this.tableName}\"\n        WHERE scope = $1 AND (template_key = $2 OR (template_key IS NULL AND $2 IS NULL))\n          AND (module_name = $3 OR (module_name IS NULL AND $3 IS NULL))\n        ORDER BY version ASC\n      `;\n      params = [scope, templateKey, moduleName];\n    } else {\n      sql = `\n        SELECT version, name, scope, template_key, module_name, checksum, up_sql, down_sql, applied_at, executed_by\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE scope = ? AND (template_key = ? OR (template_key IS NULL AND ? IS NULL))\n          AND (module_name = ? OR (module_name IS NULL AND ? IS NULL))\n        ORDER BY version ASC\n      `;\n      params = [scope, templateKey, templateKey, moduleName, moduleName];\n    }\n\n    const result = await this.driver.query<{\n      version: number;\n      name: string;\n      scope: 'core' | 'template';\n      template_key: string | null;\n      module_name: string | null;\n      checksum: string;\n      up_sql: string[] | string;\n      down_sql: string[] | string | null;\n      applied_at: Date | string;\n      executed_by: string | null;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      version: Number(row.version),\n      name: row.name,\n      scope: row.scope,\n      templateKey: row.template_key,\n      moduleName: row.module_name,\n      checksum: row.checksum,\n      upSql: typeof row.up_sql === 'string' ? JSON.parse(row.up_sql) : row.up_sql,\n      downSql: row.down_sql\n        ? typeof row.down_sql === 'string'\n          ? JSON.parse(row.down_sql)\n          : row.down_sql\n        : [],\n      appliedAt: new Date(row.applied_at),\n      executedBy: row.executed_by,\n    }));\n  }\n\n  private async getPendingMigrations(options: MigrationRunOptions = {}): Promise<MigrationFile[]> {\n    const files = await this.loadMigrationFiles(options);\n    const applied = await this.getAppliedMigrations(options);\n    const appliedVersions = new Set(applied.map((m) => m.version));\n\n    return files.filter((f) => !appliedVersions.has(f.version));\n  }\n\n  private async recordMigration(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    migration: MigrationFile\n  ): Promise<void> {\n    const checksum = this.computeChecksum(migration.up);\n\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          migration.up,\n          migration.down.length ? migration.down : null,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await client.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          JSON.stringify(migration.up),\n          migration.down.length ? JSON.stringify(migration.down) : null,\n        ]\n      );\n    } else {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          JSON.stringify(migration.up),\n          migration.down.length ? JSON.stringify(migration.down) : null,\n        ]\n      );\n    }\n  }\n\n  private async removeMigrationRecord(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    version: number\n  ): Promise<void> {\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(`DELETE FROM \"${this.tableName}\" WHERE version = $1`, [version]);\n    } else {\n      await client.execute(\n        `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE version = ?`,\n        [version]\n      );\n    }\n  }\n\n  private computeChecksum(statements: string[]): string {\n    return createHash('sha256').update(statements.join('\\n')).digest('hex');\n  }\n\n  private splitSqlStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inSingleQuote) {\n        current += char;\n        if (char === \"'\" && next !== \"'\") {\n          inSingleQuote = false;\n        } else if (char === \"'\" && next === \"'\") {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (inDoubleQuote) {\n        current += char;\n        if (char === '\"' && next !== '\"') {\n          inDoubleQuote = false;\n        } else if (char === '\"' && next === '\"') {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\") {\n        inSingleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '\"') {\n        inDoubleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n\nexport function createMigrationRunner(\n  driver: Driver,\n  options: MigrationRunnerOptions\n): MigrationRunner {\n  return new MigrationRunner(driver, options);\n}\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nfunction compileMysqlDefault(colDef: ColumnDefinition): string {\n  if (!colDef.default) return '';\n  const defaultVal = colDef.default === 'gen_random_uuid()' ? '(UUID())' : colDef.default;\n  return ` DEFAULT ${defaultVal}`;\n}\n\nfunction compileMysqlConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  sql += compileMysqlDefault(colDef);\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compileMysqlForeignKeys(\n  tableName: string,\n  columns: Record<string, ColumnDefinition>\n): string[] {\n  const fkDefs: string[] = [];\n  for (const [colName, colDef] of Object.entries(columns)) {\n    if (colDef.references) {\n      const fkName = `fk_${tableName}_${colName}`;\n      let fk = `  CONSTRAINT \\`${fkName}\\` FOREIGN KEY (\\`${colName}\\`) `;\n      fk += `REFERENCES \\`${colDef.references.table}\\`(\\`${colDef.references.column}\\`)`;\n      if (colDef.references.onDelete) {\n        fk += ` ON DELETE ${colDef.references.onDelete}`;\n      }\n      fkDefs.push(fk);\n    }\n  }\n  return fkDefs;\n}\n\nexport const mysqlDialect: Dialect = {\n  name: 'mysql',\n  supportsTransactionalDDL: false,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'CHAR(36)',\n      string: 'VARCHAR(255)',\n      text: 'TEXT',\n      integer: 'INT',\n      bigint: 'BIGINT',\n      float: 'DOUBLE',\n      decimal: 'DECIMAL(10,2)',\n      boolean: 'TINYINT(1)',\n      datetime: 'DATETIME',\n      date: 'DATE',\n      time: 'TIME',\n      json: 'JSON',\n      binary: 'BLOB',\n    };\n    return map[type] || 'VARCHAR(255)';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \\`${colName}\\` ${this.mapType(colDef.type)}`;\n      return typeSql + compileMysqlConstraints(colDef);\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\\`${c}\\``).join(', ')})`);\n    }\n\n    const foreignKeys = compileMysqlForeignKeys(name, def.columns);\n    columnDefs.push(...foreignKeys);\n\n    return `CREATE TABLE \\`${name}\\` (\\n${columnDefs.join(',\\n')}\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \\`${name}\\``;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \\`${table}\\` ADD COLUMN \\`${column}\\` ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    if (def.unique) {\n      sql += ' UNIQUE';\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \\`${table}\\` DROP COLUMN \\`${column}\\``;\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \\`${table}\\` MODIFY COLUMN \\`${column}\\` ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    return sql;\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\\`${c}\\``).join(', ');\n    return `CREATE ${unique}INDEX \\`${indexName}\\` ON \\`${table}\\` (${columns})`;\n  },\n\n  dropIndex(name: string, table?: string): string {\n    if (!table) {\n      throw new Error('MySQL requires table name for DROP INDEX');\n    }\n    return `DROP INDEX \\`${name}\\` ON \\`${table}\\``;\n  },\n\n  addForeignKey(\n    table: string,\n    column: string,\n    refTable: string,\n    refColumn: string,\n    onDelete?: string\n  ): string {\n    const constraintName = `fk_${table}_${column}_${refTable}`;\n    let sql = `ALTER TABLE \\`${table}\\` ADD CONSTRAINT \\`${constraintName}\\` `;\n    sql += `FOREIGN KEY (\\`${column}\\`) REFERENCES \\`${refTable}\\`(\\`${refColumn}\\`)`;\n    if (onDelete) {\n      sql += ` ON DELETE ${onDelete}`;\n    }\n    return sql;\n  },\n\n  dropForeignKey(table: string, constraintName: string): string {\n    return `ALTER TABLE \\`${table}\\` DROP FOREIGN KEY \\`${constraintName}\\``;\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT table_name\n      FROM information_schema.tables\n      WHERE table_schema = DATABASE()\n        AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `\n      SELECT\n        column_name,\n        data_type,\n        is_nullable,\n        column_default,\n        character_maximum_length\n      FROM information_schema.columns\n      WHERE table_schema = DATABASE() AND table_name = '${table}'\n      ORDER BY ordinal_position\n    `;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `\n      SELECT\n        index_name,\n        column_name,\n        non_unique\n      FROM information_schema.statistics\n      WHERE table_schema = DATABASE() AND table_name = '${table}'\n      ORDER BY index_name, seq_in_index\n    `;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nfunction compilePostgresConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  if (colDef.default) {\n    sql += ` DEFAULT ${colDef.default}`;\n  }\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compilePostgresReferences(colDef: ColumnDefinition): string {\n  if (!colDef.references) return '';\n  let sql = ` REFERENCES \"${colDef.references.table}\"(\"${colDef.references.column}\")`;\n  if (colDef.references.onDelete) {\n    sql += ` ON DELETE ${colDef.references.onDelete}`;\n  }\n  if (colDef.references.onUpdate) {\n    sql += ` ON UPDATE ${colDef.references.onUpdate}`;\n  }\n  return sql;\n}\n\nexport const postgresDialect: Dialect = {\n  name: 'postgresql',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'UUID',\n      string: 'TEXT',\n      text: 'TEXT',\n      integer: 'INTEGER',\n      bigint: 'BIGINT',\n      float: 'DOUBLE PRECISION',\n      decimal: 'NUMERIC',\n      boolean: 'BOOLEAN',\n      datetime: 'TIMESTAMPTZ',\n      date: 'DATE',\n      time: 'TIME',\n      json: 'JSONB',\n      binary: 'BYTEA',\n    };\n    return map[type] || 'TEXT';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \"${colName}\" ${this.mapType(colDef.type)}`;\n      const constraints = compilePostgresConstraints(colDef);\n      const references = compilePostgresReferences(colDef);\n      return typeSql + constraints + references;\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\"${c}\"`).join(', ')})`);\n    }\n\n    return `CREATE TABLE \"${name}\" (\\n${columnDefs.join(',\\n')}\\n)`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \"${name}\" CASCADE`;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \"${table}\" ADD COLUMN \"${column}\" ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    if (def.unique) {\n      sql += ' UNIQUE';\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \"${table}\" DROP COLUMN \"${column}\"`;\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): string {\n    const statements: string[] = [];\n\n    statements.push(\n      `ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" TYPE ${this.mapType(def.type)}`\n    );\n\n    if (def.nullable === false) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" SET NOT NULL`);\n    } else if (def.nullable === true) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" DROP NOT NULL`);\n    }\n\n    if (def.default !== undefined) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" SET DEFAULT ${def.default}`);\n    }\n\n    return statements.join(';\\n');\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\"${c}\"`).join(', ');\n    let sql = `CREATE ${unique}INDEX \"${indexName}\" ON \"${table}\" (${columns})`;\n\n    if (index.where) {\n      sql += ` WHERE ${index.where}`;\n    }\n\n    return sql;\n  },\n\n  dropIndex(name: string): string {\n    return `DROP INDEX IF EXISTS \"${name}\"`;\n  },\n\n  addForeignKey(\n    table: string,\n    column: string,\n    refTable: string,\n    refColumn: string,\n    onDelete?: string\n  ): string {\n    const constraintName = `fk_${table}_${column}_${refTable}`;\n    let sql = `ALTER TABLE \"${table}\" ADD CONSTRAINT \"${constraintName}\" `;\n    sql += `FOREIGN KEY (\"${column}\") REFERENCES \"${refTable}\"(\"${refColumn}\")`;\n    if (onDelete) {\n      sql += ` ON DELETE ${onDelete}`;\n    }\n    return sql;\n  },\n\n  dropForeignKey(table: string, constraintName: string): string {\n    return `ALTER TABLE \"${table}\" DROP CONSTRAINT \"${constraintName}\"`;\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT table_name\n      FROM information_schema.tables\n      WHERE table_schema = 'public'\n        AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `\n      SELECT\n        column_name,\n        data_type,\n        is_nullable,\n        column_default,\n        character_maximum_length\n      FROM information_schema.columns\n      WHERE table_schema = 'public' AND table_name = '${table}'\n      ORDER BY ordinal_position\n    `;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `\n      SELECT\n        i.relname as index_name,\n        a.attname as column_name,\n        ix.indisunique as is_unique,\n        ix.indisprimary as is_primary\n      FROM pg_class t\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE t.relname = '${table}'\n      ORDER BY i.relname, a.attnum\n    `;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nconst SQLITE_UUID_DEFAULT =\n  \"(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))\";\n\nfunction compileSqliteDefault(colDef: ColumnDefinition): string {\n  if (!colDef.default) return '';\n  let defaultVal = colDef.default;\n  if (colDef.default === 'gen_random_uuid()') {\n    defaultVal = SQLITE_UUID_DEFAULT;\n  } else if (colDef.default === 'now()' || colDef.default === 'NOW()') {\n    defaultVal = \"datetime('now')\";\n  }\n  return ` DEFAULT ${defaultVal}`;\n}\n\nfunction compileSqliteConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  sql += compileSqliteDefault(colDef);\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compileSqliteReferences(colDef: ColumnDefinition): string {\n  if (!colDef.references) return '';\n  let sql = ` REFERENCES \"${colDef.references.table}\"(\"${colDef.references.column}\")`;\n  if (colDef.references.onDelete) {\n    sql += ` ON DELETE ${colDef.references.onDelete}`;\n  }\n  return sql;\n}\n\nexport const sqliteDialect: Dialect = {\n  name: 'sqlite',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'TEXT',\n      string: 'TEXT',\n      text: 'TEXT',\n      integer: 'INTEGER',\n      bigint: 'INTEGER',\n      float: 'REAL',\n      decimal: 'REAL',\n      boolean: 'INTEGER',\n      datetime: 'TEXT',\n      date: 'TEXT',\n      time: 'TEXT',\n      json: 'TEXT',\n      binary: 'BLOB',\n    };\n    return map[type] || 'TEXT';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \"${colName}\" ${this.mapType(colDef.type)}`;\n      const constraints = compileSqliteConstraints(colDef);\n      const references = compileSqliteReferences(colDef);\n      return typeSql + constraints + references;\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\"${c}\"`).join(', ')})`);\n    }\n\n    return `CREATE TABLE \"${name}\" (\\n${columnDefs.join(',\\n')}\\n)`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \"${name}\"`;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \"${table}\" ADD COLUMN \"${column}\" ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \"${table}\" DROP COLUMN \"${column}\"`;\n  },\n\n  alterColumn(_table: string, _column: string, _def: ColumnDefinition): string {\n    throw new Error(\n      'SQLite does not support ALTER COLUMN. Use table recreation instead: ' +\n        '1. Create new table with desired schema, 2. Copy data, 3. Drop old table, 4. Rename new table'\n    );\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\"${c}\"`).join(', ');\n    let sql = `CREATE ${unique}INDEX \"${indexName}\" ON \"${table}\" (${columns})`;\n\n    if (index.where) {\n      sql += ` WHERE ${index.where}`;\n    }\n\n    return sql;\n  },\n\n  dropIndex(name: string): string {\n    return `DROP INDEX IF EXISTS \"${name}\"`;\n  },\n\n  addForeignKey(\n    _table: string,\n    _column: string,\n    _refTable: string,\n    _refColumn: string,\n    _onDelete?: string\n  ): string {\n    throw new Error(\n      'SQLite does not support adding foreign keys after table creation. ' +\n        'Define foreign keys in CREATE TABLE or use table recreation.'\n    );\n  },\n\n  dropForeignKey(_table: string, _constraintName: string): string {\n    throw new Error('SQLite does not support dropping foreign keys. Use table recreation instead.');\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT name as table_name\n      FROM sqlite_master\n      WHERE type = 'table' AND name NOT LIKE 'sqlite_%'\n      ORDER BY name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `PRAGMA table_info(\"${table}\")`;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `PRAGMA index_list(\"${table}\")`;\n  },\n};\n","import type { DialectName } from '../../types/index.js';\nimport { mysqlDialect } from './mysql.js';\nimport { postgresDialect } from './postgresql.js';\nimport { sqliteDialect } from './sqlite.js';\nimport type { Dialect } from './types.js';\n\nexport type { Dialect } from './types.js';\nexport { mongoDialect, executeMongoMigration } from './mongodb.js';\nexport type { MongoDialect, MongoMigrationOperation } from './mongodb.js';\n\nexport function getDialect(name: DialectName): Dialect {\n  switch (name) {\n    case 'postgresql':\n      return postgresDialect;\n    case 'mysql':\n      return mysqlDialect;\n    case 'sqlite':\n      return sqliteDialect;\n    case 'mongodb':\n      throw new Error(\n        'MongoDB uses a different dialect interface. Use mongoDialect and executeMongoMigration instead.'\n      );\n    default:\n      throw new Error(`Unsupported dialect: ${name}`);\n  }\n}\n\nexport { postgresDialect, mysqlDialect, sqliteDialect };\n","import { readFile, readdir, stat } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { MigrationFile } from '../types/index.js';\nimport type { ModuleMigrationSource } from './types.js';\n\nexport interface MigrationCollectorOptions {\n  scope?: 'core' | 'template';\n}\n\nexport class MigrationCollector {\n  async discoverFromDirectory(basePath: string): Promise<ModuleMigrationSource[]> {\n    const sources: ModuleMigrationSource[] = [];\n\n    try {\n      const entries = await readdir(basePath);\n\n      for (const entry of entries) {\n        const entryPath = join(basePath, entry);\n        const entryStat = await stat(entryPath);\n\n        if (entryStat.isDirectory()) {\n          sources.push({\n            moduleName: entry,\n            migrationsPath: entryPath,\n          });\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n\n    return sources.sort((a, b) => a.moduleName.localeCompare(b.moduleName));\n  }\n\n  async collect(\n    sources: ModuleMigrationSource[],\n    options: MigrationCollectorOptions = {}\n  ): Promise<MigrationFile[]> {\n    const migrations: MigrationFile[] = [];\n\n    for (const source of sources) {\n      const sourceMigrations = await this.loadMigrationsFromSource(source, options);\n      migrations.push(...sourceMigrations);\n    }\n\n    return this.orderMigrations(migrations);\n  }\n\n  private async loadMigrationsFromSource(\n    source: ModuleMigrationSource,\n    options: MigrationCollectorOptions = {}\n  ): Promise<MigrationFile[]> {\n    const scope = options.scope ?? 'core';\n    const migrations: MigrationFile[] = [];\n\n    try {\n      const files = await readdir(source.migrationsPath);\n      const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();\n\n      for (const file of sqlFiles) {\n        const content = await readFile(join(source.migrationsPath, file), 'utf-8');\n        const parsed = this.parseMigrationFile(file, content, scope, source.moduleName);\n        if (parsed) {\n          migrations.push(parsed);\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n\n    return migrations;\n  }\n\n  private parseMigrationFile(\n    filename: string,\n    content: string,\n    scope: 'core' | 'template',\n    moduleName: string\n  ): MigrationFile | null {\n    const match = filename.match(/^(\\d+)__(.+)\\.sql$/);\n    if (!match) return null;\n\n    const [, versionStr, name] = match;\n    const version = Number.parseInt(versionStr, 10);\n\n    const upMatch = content.match(/--\\s*up\\s*\\n([\\s\\S]*?)(?=--\\s*down|$)/i);\n    const downMatch = content.match(/--\\s*down\\s*\\n([\\s\\S]*?)$/i);\n\n    const up = upMatch ? this.splitSqlStatements(upMatch[1]) : [];\n    const down = downMatch ? this.splitSqlStatements(downMatch[1]) : [];\n\n    if (!up.length) return null;\n\n    return {\n      version,\n      name,\n      up,\n      down,\n      scope,\n      moduleName,\n    };\n  }\n\n  private orderMigrations(migrations: MigrationFile[]): MigrationFile[] {\n    return migrations.sort((a, b) => {\n      if (a.version !== b.version) {\n        return a.version - b.version;\n      }\n      const moduleA = a.moduleName ?? '';\n      const moduleB = b.moduleName ?? '';\n      return moduleA.localeCompare(moduleB);\n    });\n  }\n\n  private splitSqlStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inSingleQuote) {\n        current += char;\n        if (char === \"'\" && next !== \"'\") {\n          inSingleQuote = false;\n        } else if (char === \"'\" && next === \"'\") {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (inDoubleQuote) {\n        current += char;\n        if (char === '\"' && next !== '\"') {\n          inDoubleQuote = false;\n        } else if (char === '\"' && next === '\"') {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\") {\n        inSingleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '\"') {\n        inDoubleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n\nexport function createMigrationCollector(): MigrationCollector {\n  return new MigrationCollector();\n}\n","import type { Driver } from '../driver/types.js';\nimport { getDialect } from '../migrations/dialects/index.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { ModuleDefinition } from './types.js';\n\nexport interface ModuleRegistryOptions {\n  tableName?: string;\n}\n\nexport class ModuleRegistry {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: ModuleRegistryOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_module_registry';\n  }\n\n  async ensureTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          name TEXT PRIMARY KEY,\n          display_name TEXT NOT NULL,\n          description TEXT,\n          version TEXT NOT NULL,\n          dependencies TEXT[] DEFAULT '{}',\n          migration_prefix TEXT NOT NULL UNIQUE,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW()\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            name VARCHAR(255) PRIMARY KEY,\n            display_name VARCHAR(255) NOT NULL,\n            description TEXT,\n            version VARCHAR(50) NOT NULL,\n            dependencies JSON DEFAULT ('[]'),\n            migration_prefix VARCHAR(255) NOT NULL UNIQUE,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            name TEXT PRIMARY KEY,\n            display_name TEXT NOT NULL,\n            description TEXT,\n            version TEXT NOT NULL,\n            dependencies TEXT DEFAULT '[]',\n            migration_prefix TEXT NOT NULL UNIQUE,\n            created_at TEXT DEFAULT (datetime('now')),\n            updated_at TEXT DEFAULT (datetime('now'))\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n  }\n\n  async register(module: ModuleDefinition): Promise<void> {\n    await this.ensureTable();\n\n    const dependencies = module.dependencies ?? [];\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES ($1, $2, $3, $4, $5, $6)\n        ON CONFLICT (name) DO UPDATE SET\n          display_name = EXCLUDED.display_name,\n          description = EXCLUDED.description,\n          version = EXCLUDED.version,\n          dependencies = EXCLUDED.dependencies,\n          migration_prefix = EXCLUDED.migration_prefix,\n          updated_at = NOW()\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          dependencies,\n          module.migrationPrefix,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES (?, ?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          display_name = VALUES(display_name),\n          description = VALUES(description),\n          version = VALUES(version),\n          dependencies = VALUES(dependencies),\n          migration_prefix = VALUES(migration_prefix)\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          JSON.stringify(dependencies),\n          module.migrationPrefix,\n        ]\n      );\n    } else {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES (?, ?, ?, ?, ?, ?)\n        ON CONFLICT (name) DO UPDATE SET\n          display_name = excluded.display_name,\n          description = excluded.description,\n          version = excluded.version,\n          dependencies = excluded.dependencies,\n          migration_prefix = excluded.migration_prefix,\n          updated_at = datetime('now')\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          JSON.stringify(dependencies),\n          module.migrationPrefix,\n        ]\n      );\n    }\n  }\n\n  async get(name: string): Promise<ModuleDefinition | null> {\n    await this.ensureTable();\n\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM \"${this.tableName}\"\n        WHERE name = $1\n      `;\n      params = [name];\n    } else {\n      sql = `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE name = ?\n      `;\n      params = [name];\n    }\n\n    const result = await this.driver.query<{\n      name: string;\n      display_name: string;\n      description: string | null;\n      version: string;\n      dependencies: string[] | string;\n      migration_prefix: string;\n    }>(sql, params);\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0];\n    return {\n      name: row.name,\n      displayName: row.display_name,\n      description: row.description ?? undefined,\n      version: row.version,\n      dependencies:\n        typeof row.dependencies === 'string' ? JSON.parse(row.dependencies) : row.dependencies,\n      migrationPrefix: row.migration_prefix,\n    };\n  }\n\n  async list(): Promise<ModuleDefinition[]> {\n    await this.ensureTable();\n\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM \"${this.tableName}\"\n        ORDER BY name ASC\n      `\n        : `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        ORDER BY name ASC\n      `;\n\n    const result = await this.driver.query<{\n      name: string;\n      display_name: string;\n      description: string | null;\n      version: string;\n      dependencies: string[] | string;\n      migration_prefix: string;\n    }>(sql);\n\n    return result.rows.map((row) => ({\n      name: row.name,\n      displayName: row.display_name,\n      description: row.description ?? undefined,\n      version: row.version,\n      dependencies:\n        typeof row.dependencies === 'string' ? JSON.parse(row.dependencies) : row.dependencies,\n      migrationPrefix: row.migration_prefix,\n    }));\n  }\n\n  async unregister(name: string): Promise<void> {\n    await this.ensureTable();\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(`DELETE FROM \"${this.tableName}\" WHERE name = $1`, [name]);\n    } else {\n      await this.driver.execute(\n        `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE name = ?`,\n        [name]\n      );\n    }\n  }\n}\n\nexport function createModuleRegistry(\n  driver: Driver,\n  options: ModuleRegistryOptions = {}\n): ModuleRegistry {\n  return new ModuleRegistry(driver, options);\n}\n","import { createHash } from 'node:crypto';\nimport type { Driver } from '../driver/types.js';\nimport { type Dialect, getDialect } from '../migrations/dialects/index.js';\nimport type { MigrationResult, SchemaDefinition, TableDefinition } from '../types/index.js';\n\nexport interface SchemaRegistryOptions {\n  tableName?: string;\n}\n\nexport interface RegisterSchemaOptions {\n  appId: string;\n  schemaName: string;\n  version: string;\n  schema: SchemaDefinition;\n}\n\nexport interface SchemaRecord {\n  app_id: string;\n  schema_name: string;\n  version: string;\n  schema: SchemaDefinition;\n  checksum: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport class SchemaRegistry {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: SchemaRegistryOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_schema_registry';\n  }\n\n  async ensureRegistryTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          app_id TEXT NOT NULL,\n          schema_name TEXT NOT NULL,\n          version TEXT NOT NULL,\n          schema JSONB NOT NULL,\n          checksum TEXT NOT NULL,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW(),\n          PRIMARY KEY (app_id, schema_name)\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            app_id VARCHAR(255) NOT NULL,\n            schema_name VARCHAR(255) NOT NULL,\n            version VARCHAR(50) NOT NULL,\n            schema JSON NOT NULL,\n            checksum VARCHAR(64) NOT NULL,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            PRIMARY KEY (app_id, schema_name)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            app_id TEXT NOT NULL,\n            schema_name TEXT NOT NULL,\n            version TEXT NOT NULL,\n            schema TEXT NOT NULL,\n            checksum TEXT NOT NULL,\n            created_at TEXT DEFAULT (datetime('now')),\n            updated_at TEXT DEFAULT (datetime('now')),\n            PRIMARY KEY (app_id, schema_name)\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n  }\n\n  async register(options: RegisterSchemaOptions): Promise<MigrationResult[]> {\n    await this.ensureRegistryTable();\n\n    this.validateSchema(options.schema);\n\n    const current = await this.getCurrentSchema(options.appId, options.schemaName);\n    const diff = this.computeDiff(current?.schema ?? null, options.schema);\n\n    if (diff.length === 0) {\n      return [];\n    }\n\n    const results: MigrationResult[] = [];\n    const checksum = this.computeChecksum(options.schema);\n\n    if (this.dialect.supportsTransactionalDDL) {\n      await this.driver.transaction(async (trx) => {\n        for (const change of diff) {\n          const startTime = Date.now();\n          try {\n            await trx.execute(change.sql);\n            results.push({\n              version: Date.now(),\n              name: change.description,\n              success: true,\n              duration: Date.now() - startTime,\n            });\n          } catch (error) {\n            results.push({\n              version: Date.now(),\n              name: change.description,\n              success: false,\n              error: error instanceof Error ? error.message : String(error),\n              duration: Date.now() - startTime,\n            });\n            throw error;\n          }\n        }\n\n        await this.upsertSchemaRecord(trx, {\n          appId: options.appId,\n          schemaName: options.schemaName,\n          version: options.version,\n          schema: options.schema,\n          checksum,\n        });\n      });\n    } else {\n      for (const change of diff) {\n        const startTime = Date.now();\n        try {\n          await this.driver.execute(change.sql);\n          results.push({\n            version: Date.now(),\n            name: change.description,\n            success: true,\n            duration: Date.now() - startTime,\n          });\n        } catch (error) {\n          results.push({\n            version: Date.now(),\n            name: change.description,\n            success: false,\n            error: error instanceof Error ? error.message : String(error),\n            duration: Date.now() - startTime,\n          });\n          throw error;\n        }\n      }\n\n      await this.upsertSchemaRecord(this.driver, {\n        appId: options.appId,\n        schemaName: options.schemaName,\n        version: options.version,\n        schema: options.schema,\n        checksum,\n      });\n    }\n\n    return results;\n  }\n\n  async getCurrentSchema(appId: string, schemaName: string): Promise<SchemaRecord | null> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT app_id, schema_name, version, schema, checksum, created_at, updated_at\n        FROM \"${this.tableName}\"\n        WHERE app_id = $1 AND schema_name = $2\n      `;\n      params = [appId, schemaName];\n    } else {\n      sql = `\n        SELECT app_id, schema_name, version, schema, checksum, created_at, updated_at\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE app_id = ? AND schema_name = ?\n      `;\n      params = [appId, schemaName];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      schema_name: string;\n      version: string;\n      schema: SchemaDefinition | string;\n      checksum: string;\n      created_at: Date | string;\n      updated_at: Date | string;\n    }>(sql, params);\n\n    if (!result.rows.length) return null;\n\n    const row = result.rows[0];\n    return {\n      app_id: row.app_id,\n      schema_name: row.schema_name,\n      version: row.version,\n      schema: typeof row.schema === 'string' ? JSON.parse(row.schema) : row.schema,\n      checksum: row.checksum,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    };\n  }\n\n  async listSchemas(appId?: string): Promise<SchemaRecord[]> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = appId\n        ? `SELECT * FROM \"${this.tableName}\" WHERE app_id = $1 ORDER BY schema_name`\n        : `SELECT * FROM \"${this.tableName}\" ORDER BY app_id, schema_name`;\n      params = appId ? [appId] : [];\n    } else {\n      const table = this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`;\n      sql = appId\n        ? `SELECT * FROM ${table} WHERE app_id = ? ORDER BY schema_name`\n        : `SELECT * FROM ${table} ORDER BY app_id, schema_name`;\n      params = appId ? [appId] : [];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      schema_name: string;\n      version: string;\n      schema: SchemaDefinition | string;\n      checksum: string;\n      created_at: Date | string;\n      updated_at: Date | string;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      app_id: row.app_id,\n      schema_name: row.schema_name,\n      version: row.version,\n      schema: typeof row.schema === 'string' ? JSON.parse(row.schema) : row.schema,\n      checksum: row.checksum,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n  }\n\n  private validateSchema(schema: SchemaDefinition): void {\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      if (!table.columns.app_id) {\n        throw new Error(`Table \"${tableName}\" must have an \"app_id\" column for multi-tenancy`);\n      }\n      if (!table.columns.organization_id) {\n        throw new Error(\n          `Table \"${tableName}\" must have an \"organization_id\" column for multi-tenancy`\n        );\n      }\n      if (!table.columns.id) {\n        throw new Error(`Table \"${tableName}\" must have an \"id\" column`);\n      }\n\n      const appIdCol = table.columns.app_id;\n      const orgIdCol = table.columns.organization_id;\n\n      if (!appIdCol.tenant) {\n        throw new Error(`Column \"app_id\" in table \"${tableName}\" must be marked as tenant column`);\n      }\n      if (!orgIdCol.tenant) {\n        throw new Error(\n          `Column \"organization_id\" in table \"${tableName}\" must be marked as tenant column`\n        );\n      }\n    }\n  }\n\n  private computeDiff(\n    current: SchemaDefinition | null,\n    desired: SchemaDefinition\n  ): Array<{ sql: string; description: string }> {\n    const changes: Array<{ sql: string; description: string }> = [];\n\n    for (const [tableName, desiredTable] of Object.entries(desired.tables)) {\n      const currentTable = current?.tables[tableName];\n\n      if (!currentTable) {\n        const sql = this.dialect.createTable(tableName, desiredTable);\n        changes.push({ sql, description: `Create table ${tableName}` });\n\n        if (desiredTable.indexes) {\n          for (const index of desiredTable.indexes) {\n            const indexSql = this.dialect.createIndex(tableName, index);\n            changes.push({\n              sql: indexSql,\n              description: `Create index on ${tableName}(${index.columns.join(', ')})`,\n            });\n          }\n        }\n\n        continue;\n      }\n\n      for (const [colName, desiredCol] of Object.entries(desiredTable.columns)) {\n        const currentCol = currentTable.columns[colName];\n\n        if (!currentCol) {\n          const sql = this.dialect.addColumn(tableName, colName, desiredCol);\n          changes.push({ sql, description: `Add column ${tableName}.${colName}` });\n        } else if (!this.columnsEqual(currentCol, desiredCol)) {\n          try {\n            const sql = this.dialect.alterColumn(tableName, colName, desiredCol);\n            changes.push({ sql, description: `Alter column ${tableName}.${colName}` });\n          } catch (error) {\n            console.warn(`Cannot alter column ${tableName}.${colName}: ${error}`);\n          }\n        }\n      }\n\n      for (const colName of Object.keys(currentTable.columns)) {\n        if (!desiredTable.columns[colName]) {\n          try {\n            const sql = this.dialect.dropColumn(tableName, colName);\n            changes.push({ sql, description: `Drop column ${tableName}.${colName}` });\n          } catch (error) {\n            console.warn(`Cannot drop column ${tableName}.${colName}: ${error}`);\n          }\n        }\n      }\n    }\n\n    if (current) {\n      for (const tableName of Object.keys(current.tables)) {\n        if (!desired.tables[tableName]) {\n          const sql = this.dialect.dropTable(tableName);\n          changes.push({ sql, description: `Drop table ${tableName}` });\n        }\n      }\n    }\n\n    return changes;\n  }\n\n  private columnsEqual(\n    a: TableDefinition['columns'][string],\n    b: TableDefinition['columns'][string]\n  ): boolean {\n    return (\n      a.type === b.type &&\n      a.nullable === b.nullable &&\n      a.unique === b.unique &&\n      a.default === b.default &&\n      JSON.stringify(a.references) === JSON.stringify(b.references)\n    );\n  }\n\n  private async upsertSchemaRecord(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    data: {\n      appId: string;\n      schemaName: string;\n      version: string;\n      schema: SchemaDefinition;\n      checksum: string;\n    }\n  ): Promise<void> {\n    const schemaJson = JSON.stringify(data.schema);\n\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (app_id, schema_name, version, schema, checksum)\n        VALUES ($1, $2, $3, $4, $5)\n        ON CONFLICT (app_id, schema_name) DO UPDATE SET\n          version = EXCLUDED.version,\n          schema = EXCLUDED.schema,\n          checksum = EXCLUDED.checksum,\n          updated_at = NOW()\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await client.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (app_id, schema_name, version, schema, checksum)\n        VALUES (?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          version = VALUES(version),\n          schema = VALUES(schema),\n          checksum = VALUES(checksum)\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    } else {\n      await client.execute(\n        `\n        INSERT OR REPLACE INTO \"${this.tableName}\" (app_id, schema_name, version, schema, checksum, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, datetime('now'), datetime('now'))\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    }\n  }\n\n  private computeChecksum(schema: SchemaDefinition): string {\n    return createHash('sha256').update(JSON.stringify(schema)).digest('hex');\n  }\n}\n\nexport function createSchemaRegistry(\n  driver: Driver,\n  options?: SchemaRegistryOptions\n): SchemaRegistry {\n  return new SchemaRegistry(driver, options);\n}\n","import type { ColumnType, SchemaDefinition } from './index.js';\n\nexport interface TypeGeneratorOptions {\n  includeInsertTypes?: boolean;\n  includeUpdateTypes?: boolean;\n  omitTenantColumns?: boolean;\n}\n\nfunction pascalCase(str: string): string {\n  return str\n    .split(/[-_]/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\nfunction pgTypeToTs(type: ColumnType): string {\n  const map: Record<ColumnType, string> = {\n    uuid: 'string',\n    string: 'string',\n    text: 'string',\n    integer: 'number',\n    bigint: 'number',\n    float: 'number',\n    decimal: 'number',\n    boolean: 'boolean',\n    datetime: 'Date',\n    date: 'Date',\n    time: 'string',\n    json: 'Record<string, unknown>',\n    binary: 'Buffer',\n  };\n  return map[type] || 'unknown';\n}\n\nexport function generateTypes(\n  schemas: Map<string, SchemaDefinition>,\n  options: TypeGeneratorOptions = {}\n): string {\n  const {\n    includeInsertTypes = true,\n    includeUpdateTypes = true,\n    omitTenantColumns = true,\n  } = options;\n\n  const lines: string[] = [\n    '// Auto-generated by @launchpad/db-engine',\n    '// Do not edit this file manually',\n    '',\n  ];\n\n  for (const [schemaName, schema] of schemas) {\n    const namespace = pascalCase(schemaName);\n    lines.push(`export namespace ${namespace} {`);\n\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      const typeName = pascalCase(tableName);\n\n      lines.push(`  /** Row type for ${tableName} table */`);\n      lines.push(`  export interface ${typeName} {`);\n\n      for (const [colName, col] of Object.entries(table.columns)) {\n        const tsType = pgTypeToTs(col.type);\n        const nullable = col.nullable ? ' | null' : '';\n        lines.push(`    ${colName}: ${tsType}${nullable};`);\n      }\n\n      lines.push('  }');\n      lines.push('');\n\n      if (includeInsertTypes) {\n        lines.push(`  /** Insert type for ${tableName} table */`);\n        lines.push(`  export interface ${typeName}Insert {`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (colName === 'id' && col.default) continue;\n          if (colName === 'created_at' && col.default) continue;\n          if (colName === 'updated_at' && col.default) continue;\n\n          if (omitTenantColumns && col.tenant) continue;\n\n          const tsType = pgTypeToTs(col.type);\n          const optional = col.nullable || col.default ? '?' : '';\n          lines.push(`    ${colName}${optional}: ${tsType};`);\n        }\n\n        lines.push('  }');\n        lines.push('');\n      }\n\n      if (includeUpdateTypes) {\n        lines.push(`  /** Update type for ${tableName} table */`);\n        lines.push(`  export interface ${typeName}Update {`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (colName === 'id') continue;\n          if (colName === 'created_at') continue;\n\n          if (omitTenantColumns && col.tenant) continue;\n\n          const tsType = pgTypeToTs(col.type);\n          lines.push(`    ${colName}?: ${tsType} | null;`);\n        }\n\n        lines.push('  }');\n        lines.push('');\n      }\n    }\n\n    const tableNames = Object.keys(schema.tables)\n      .map((t) => `'${t}'`)\n      .join(' | ');\n    lines.push(`  export type TableName = ${tableNames};`);\n    lines.push('');\n\n    lines.push('  export interface Tables {');\n    for (const tableName of Object.keys(schema.tables)) {\n      const typeName = pascalCase(tableName);\n      lines.push(`    ${tableName}: ${typeName};`);\n    }\n    lines.push('  }');\n\n    lines.push('}');\n    lines.push('');\n  }\n\n  lines.push('export type AllSchemas = {');\n  for (const schemaName of schemas.keys()) {\n    const namespace = pascalCase(schemaName);\n    lines.push(`  ${schemaName}: typeof ${namespace};`);\n  }\n  lines.push('};');\n\n  return lines.join('\\n');\n}\n\nexport function generateSchemaFromDefinition(schema: SchemaDefinition): string {\n  const lines: string[] = [\n    \"import type { SchemaDefinition } from '@launchpad/db-engine';\",\n    '',\n    'export const schema: SchemaDefinition = {',\n    '  tables: {',\n  ];\n\n  for (const [tableName, table] of Object.entries(schema.tables)) {\n    lines.push(`    ${tableName}: {`);\n    lines.push('      columns: {');\n\n    for (const [colName, col] of Object.entries(table.columns)) {\n      const colDef: string[] = [];\n      colDef.push(`type: '${col.type}'`);\n\n      if (col.primaryKey) colDef.push('primaryKey: true');\n      if (col.nullable) colDef.push('nullable: true');\n      if (col.unique) colDef.push('unique: true');\n      if (col.default) colDef.push(`default: '${col.default}'`);\n      if (col.tenant) colDef.push('tenant: true');\n\n      if (col.references) {\n        colDef.push(\n          `references: { table: '${col.references.table}', column: '${col.references.column}'${col.references.onDelete ? `, onDelete: '${col.references.onDelete}'` : ''} }`\n        );\n      }\n\n      lines.push(`        ${colName}: { ${colDef.join(', ')} },`);\n    }\n\n    lines.push('      },');\n\n    if (table.indexes?.length) {\n      lines.push('      indexes: [');\n      for (const index of table.indexes) {\n        const indexDef: string[] = [];\n        indexDef.push(`columns: [${index.columns.map((c) => `'${c}'`).join(', ')}]`);\n        if (index.name) indexDef.push(`name: '${index.name}'`);\n        if (index.unique) indexDef.push('unique: true');\n        if (index.where) indexDef.push(`where: '${index.where}'`);\n        lines.push(`        { ${indexDef.join(', ')} },`);\n      }\n      lines.push('      ],');\n    }\n\n    lines.push('    },');\n  }\n\n  lines.push('  },');\n  lines.push('};');\n\n  return lines.join('\\n');\n}\n"],"mappings":"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","names":["result","result","readFile","join","createMySQLDriver","createSQLiteDriver","createMongoDriver","trimmed","readFile","readdir","join","trimmed","createHash","createHash","join","readFile"]}