{"version":3,"sources":["../src/driver/postgresql.ts","../src/driver/mysql.ts","../src/driver/sqlite.ts","../src/driver/index.ts","../src/compiler/index.ts","../src/utils/tenant-validation.ts","../src/query-builder/index.ts","../src/migrations/dialects/mysql.ts","../src/migrations/dialects/postgresql.ts","../src/migrations/dialects/sqlite.ts","../src/migrations/dialects/index.ts","../src/migrations/runner.ts","../src/schema/registry.ts","../src/client.ts","../src/orm/metadata.ts","../src/orm/decorators.ts","../src/orm/entity.ts","../src/orm/schema-extractor.ts","../src/orm/repository.ts","../src/index.ts","../src/migrations/index.ts","../src/modules/registry.ts","../src/modules/collector.ts","../src/schema/index.ts","../src/types/generator.ts","../src/branch/schema-differ.ts","../src/branch/migration-merger.ts","../src/branch/branch-manager.ts","../src/branch/connection-manager.ts","../src/branch/cleanup-scheduler.ts"],"sourcesContent":["import postgres, { type ParameterOrJSON } from 'postgres';\nimport type { QueryResult } from '../types/index.js';\nimport type { Driver, DriverConfig, TransactionClient } from './types.js';\n\nexport function createPostgresDriver(config: DriverConfig): Driver {\n  const sql = postgres(config.connectionString, {\n    max: config.max ?? 20,\n    idle_timeout: config.idleTimeout ?? 30,\n    connect_timeout: config.connectTimeout ?? 10,\n    prepare: true,\n  });\n\n  return {\n    dialect: 'postgresql',\n    connectionString: config.connectionString,\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const result = await sql.unsafe<T[]>(queryText, params as ParameterOrJSON<never>[]);\n      return {\n        rows: result as T[],\n        rowCount: result.length,\n      };\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const result = await sql.unsafe(queryText, params as ParameterOrJSON<never>[]);\n      return { rowCount: result.count ?? 0 };\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const result = await sql.begin(async (tx) => {\n        const client: TransactionClient = {\n          async query<R = Record<string, unknown>>(\n            queryText: string,\n            params: unknown[] = []\n          ): Promise<QueryResult<R>> {\n            const txResult = await tx.unsafe<R[]>(queryText, params as ParameterOrJSON<never>[]);\n            return {\n              rows: txResult as R[],\n              rowCount: txResult.length,\n            };\n          },\n\n          async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n            const txResult = await tx.unsafe(queryText, params as ParameterOrJSON<never>[]);\n            return { rowCount: txResult.count ?? 0 };\n          },\n        };\n\n        return fn(client);\n      });\n      return result as T;\n    },\n\n    async close(): Promise<void> {\n      await sql.end();\n    },\n  };\n}\n","import type { QueryResult } from '../types/index.js';\nimport type { Driver, DriverConfig, TransactionClient } from './types.js';\n\nexport async function createMySQLDriver(config: DriverConfig): Promise<Driver> {\n  const mysql = await import('mysql2/promise');\n\n  const pool = mysql.createPool({\n    uri: config.connectionString,\n    waitForConnections: true,\n    connectionLimit: config.max ?? 20,\n    idleTimeout: (config.idleTimeout ?? 30) * 1000,\n    connectTimeout: (config.connectTimeout ?? 10) * 1000,\n  });\n\n  return {\n    dialect: 'mysql',\n    connectionString: config.connectionString,\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const [rows] = await pool.execute(queryText, params);\n      const resultRows = Array.isArray(rows) ? rows : [];\n      return {\n        rows: resultRows as T[],\n        rowCount: resultRows.length,\n      };\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const [result] = await pool.execute(queryText, params);\n      const affectedRows = (result as { affectedRows?: number }).affectedRows ?? 0;\n      return { rowCount: affectedRows };\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const connection = await pool.getConnection();\n      await connection.beginTransaction();\n\n      try {\n        const client: TransactionClient = {\n          async query<R = Record<string, unknown>>(\n            queryText: string,\n            params: unknown[] = []\n          ): Promise<QueryResult<R>> {\n            const [rows] = await connection.execute(queryText, params);\n            const resultRows = Array.isArray(rows) ? rows : [];\n            return {\n              rows: resultRows as R[],\n              rowCount: resultRows.length,\n            };\n          },\n\n          async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n            const [result] = await connection.execute(queryText, params);\n            const affectedRows = (result as { affectedRows?: number }).affectedRows ?? 0;\n            return { rowCount: affectedRows };\n          },\n        };\n\n        const result = await fn(client);\n        await connection.commit();\n        return result;\n      } catch (error) {\n        await connection.rollback();\n        throw error;\n      } finally {\n        connection.release();\n      }\n    },\n\n    async close(): Promise<void> {\n      await pool.end();\n    },\n  };\n}\n","import type { QueryResult } from '../types/index.js';\nimport type { Driver, DriverConfig, TransactionClient } from './types.js';\n\nexport async function createSQLiteDriver(config: DriverConfig): Promise<Driver> {\n  const Database = (await import('better-sqlite3')).default;\n\n  const dbPath = config.connectionString.replace('sqlite://', '').replace('file://', '');\n  const db = new Database(dbPath);\n\n  db.pragma('journal_mode = WAL');\n  db.pragma('foreign_keys = ON');\n\n  return {\n    dialect: 'sqlite',\n    connectionString: config.connectionString,\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const stmt = db.prepare(queryText);\n      const rows = stmt.all(...params) as T[];\n      return {\n        rows,\n        rowCount: rows.length,\n      };\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const stmt = db.prepare(queryText);\n      const result = stmt.run(...params);\n      return { rowCount: result.changes };\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const client: TransactionClient = {\n        async query<R = Record<string, unknown>>(\n          queryText: string,\n          params: unknown[] = []\n        ): Promise<QueryResult<R>> {\n          const stmt = db.prepare(queryText);\n          const rows = stmt.all(...params) as R[];\n          return {\n            rows,\n            rowCount: rows.length,\n          };\n        },\n\n        async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n          const stmt = db.prepare(queryText);\n          const result = stmt.run(...params);\n          return { rowCount: result.changes };\n        },\n      };\n\n      let result: T;\n      let committed = false;\n\n      db.prepare('BEGIN IMMEDIATE').run();\n      try {\n        result = await fn(client);\n        db.prepare('COMMIT').run();\n        committed = true;\n        return result;\n      } catch (error) {\n        if (!committed) {\n          db.prepare('ROLLBACK').run();\n        }\n        throw error;\n      }\n    },\n\n    async close(): Promise<void> {\n      db.close();\n    },\n  };\n}\n","import type { DialectName } from '../types/index.js';\nimport { createPostgresDriver } from './postgresql.js';\nimport type { Driver, DriverConfig } from './types.js';\n\nexport type { Driver, DriverConfig, TransactionClient } from './types.js';\n\nexport interface CreateDriverOptions extends DriverConfig {\n  dialect?: DialectName;\n}\n\nexport function detectDialect(connectionString: string): DialectName {\n  if (connectionString.startsWith('postgres://') || connectionString.startsWith('postgresql://')) {\n    return 'postgresql';\n  }\n  if (connectionString.startsWith('mysql://') || connectionString.startsWith('mariadb://')) {\n    return 'mysql';\n  }\n  if (\n    connectionString.startsWith('sqlite://') ||\n    connectionString.startsWith('file://') ||\n    connectionString.endsWith('.db') ||\n    connectionString.endsWith('.sqlite') ||\n    connectionString.endsWith('.sqlite3')\n  ) {\n    return 'sqlite';\n  }\n  throw new Error(`Unable to detect database dialect from connection string: ${connectionString}`);\n}\n\nexport async function createDriver(options: CreateDriverOptions): Promise<Driver> {\n  const dialect = options.dialect ?? detectDialect(options.connectionString);\n\n  switch (dialect) {\n    case 'postgresql':\n      return createPostgresDriver(options);\n\n    case 'mysql': {\n      const { createMySQLDriver } = await import('./mysql.js');\n      return createMySQLDriver(options);\n    }\n\n    case 'sqlite': {\n      const { createSQLiteDriver } = await import('./sqlite.js');\n      return createSQLiteDriver(options);\n    }\n\n    default:\n      throw new Error(`Unsupported dialect: ${dialect}`);\n  }\n}\n","import type {\n  CompiledQuery,\n  DialectName,\n  HavingClause,\n  QueryAST,\n  TenantContext,\n  WhereClause,\n} from '../types/index.js';\n\nexport interface CompilerOptions {\n  dialect: DialectName;\n  injectTenant?: boolean;\n  tenantColumns?: {\n    appId: string;\n    organizationId: string;\n  };\n}\n\ninterface CompilationState {\n  params: unknown[];\n  paramIndex: number;\n}\n\nconst DEFAULT_TENANT_COLUMNS = {\n  appId: 'app_id',\n  organizationId: 'organization_id',\n};\n\nexport class SQLCompiler {\n  private dialect: DialectName;\n  private injectTenant: boolean;\n  private tenantColumns: { appId: string; organizationId: string };\n\n  constructor(options: CompilerOptions) {\n    this.dialect = options.dialect;\n    this.injectTenant = options.injectTenant ?? true;\n    this.tenantColumns = options.tenantColumns ?? DEFAULT_TENANT_COLUMNS;\n  }\n\n  compile(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    switch (ast.type) {\n      case 'select':\n        return this.compileSelect(ast, ctx);\n      case 'insert':\n        return this.compileInsert(ast, ctx);\n      case 'update':\n        return this.compileUpdate(ast, ctx);\n      case 'delete':\n        return this.compileDelete(ast, ctx);\n      default:\n        throw new Error(`Unsupported query type: ${(ast as QueryAST).type}`);\n    }\n  }\n\n  private getParamPlaceholder(index: number): string {\n    switch (this.dialect) {\n      case 'postgresql':\n        return `$${index}`;\n      case 'mysql':\n      case 'sqlite':\n        return '?';\n      default:\n        return `$${index}`;\n    }\n  }\n\n  private compileSelect(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    const state: CompilationState = { params: [], paramIndex: 1 };\n\n    let sql = this.compileSelectFrom(ast);\n    sql += this.compileSelectJoins(ast);\n    sql += this.compileSelectWhere(ast, ctx, state);\n    sql += this.compileSelectGroupBy(ast);\n    sql += this.compileSelectHaving(ast, state);\n    sql += this.compileSelectOrderBy(ast);\n    sql += this.compileSelectLimitOffset(ast);\n\n    return { sql, params: state.params };\n  }\n\n  private compileSelectFrom(ast: QueryAST): string {\n    const columns = ast.columns?.length\n      ? ast.columns.map((c) => this.quoteIdentifier(c)).join(', ')\n      : '*';\n    return `SELECT ${columns} FROM ${this.quoteIdentifier(ast.table)}`;\n  }\n\n  private compileSelectJoins(ast: QueryAST): string {\n    if (!ast.joins?.length) return '';\n\n    return ast.joins\n      .map((join) => {\n        const alias = join.alias ? ` AS ${this.quoteIdentifier(join.alias)}` : '';\n        return ` ${join.type} JOIN ${this.quoteIdentifier(join.table)}${alias} ON ${this.quoteIdentifier(join.on.leftColumn)} = ${this.quoteIdentifier(join.on.rightColumn)}`;\n      })\n      .join('');\n  }\n\n  private compileSelectWhere(\n    ast: QueryAST,\n    ctx: TenantContext | undefined,\n    state: CompilationState\n  ): string {\n    const predicates = this.buildWherePredicates(ast, ctx, state);\n    if (predicates.length === 0) return '';\n    return ` WHERE ${this.joinPredicates(predicates, ast.where || [])}`;\n  }\n\n  private buildWherePredicates(\n    ast: QueryAST,\n    ctx: TenantContext | undefined,\n    state: CompilationState\n  ): string[] {\n    const predicates: string[] = [];\n\n    if (this.injectTenant && ctx) {\n      const tablePrefix = ast.joins?.length ? `${ast.table}.` : '';\n      predicates.push(\n        `${this.quoteIdentifier(`${tablePrefix}${this.tenantColumns.appId}`)} = ${this.getParamPlaceholder(state.paramIndex++)}`\n      );\n      state.params.push(ctx.appId);\n      predicates.push(\n        `${this.quoteIdentifier(`${tablePrefix}${this.tenantColumns.organizationId}`)} = ${this.getParamPlaceholder(state.paramIndex++)}`\n      );\n      state.params.push(ctx.organizationId);\n    }\n\n    if (ast.where?.length) {\n      for (const w of ast.where) {\n        const { predicate, values, paramCount } = this.compileWhere(w, state.paramIndex);\n        predicates.push(predicate);\n        state.params.push(...values);\n        state.paramIndex += paramCount;\n      }\n    }\n\n    return predicates;\n  }\n\n  private compileSelectGroupBy(ast: QueryAST): string {\n    if (!ast.groupBy?.columns.length) return '';\n    return ` GROUP BY ${ast.groupBy.columns.map((c) => this.quoteIdentifier(c)).join(', ')}`;\n  }\n\n  private compileSelectHaving(ast: QueryAST, state: CompilationState): string {\n    if (!ast.having?.length) return '';\n\n    const havingClauses: string[] = [];\n    for (const h of ast.having) {\n      const { predicate, values, paramCount } = this.compileHaving(h, state.paramIndex);\n      havingClauses.push(predicate);\n      state.params.push(...values);\n      state.paramIndex += paramCount;\n    }\n    return ` HAVING ${havingClauses.join(' AND ')}`;\n  }\n\n  private compileSelectOrderBy(ast: QueryAST): string {\n    if (!ast.orderBy) return '';\n\n    const direction = ast.orderBy.direction.toUpperCase();\n    if (direction !== 'ASC' && direction !== 'DESC') {\n      throw new Error(\n        `Invalid ORDER BY direction: ${ast.orderBy.direction}. Must be 'ASC' or 'DESC'.`\n      );\n    }\n    return ` ORDER BY ${this.quoteIdentifier(ast.orderBy.column)} ${direction}`;\n  }\n\n  private compileSelectLimitOffset(ast: QueryAST): string {\n    let sql = '';\n    if (ast.limit !== undefined) {\n      sql += ` LIMIT ${ast.limit}`;\n    }\n    if (ast.offset !== undefined) {\n      sql += ` OFFSET ${ast.offset}`;\n    }\n    return sql;\n  }\n\n  private compileInsert(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    const params: unknown[] = [];\n    let paramIndex = 1;\n\n    if (ast.dataRows !== undefined) {\n      return this.compileInsertMany(ast, ctx, params, paramIndex);\n    }\n\n    const data = { ...ast.data };\n\n    if (this.injectTenant && ctx) {\n      data[this.tenantColumns.appId] = ctx.appId;\n      data[this.tenantColumns.organizationId] = ctx.organizationId;\n    }\n\n    const columns = Object.keys(data!);\n    const values: string[] = [];\n\n    for (const col of columns) {\n      values.push(this.getParamPlaceholder(paramIndex++));\n      params.push(data![col]);\n    }\n\n    let sql = `INSERT INTO ${this.quoteIdentifier(ast.table)} (${columns.map((c) => this.quoteIdentifier(c)).join(', ')}) VALUES (${values.join(', ')})`;\n\n    if (ast.onConflict) {\n      sql += this.compileOnConflict(ast.onConflict, columns, paramIndex, params);\n    }\n\n    if (ast.returning?.length) {\n      sql += this.compileReturning(ast.returning);\n    }\n\n    return { sql, params };\n  }\n\n  private compileInsertMany(\n    ast: QueryAST,\n    ctx: TenantContext | undefined,\n    params: unknown[],\n    startParamIndex: number\n  ): CompiledQuery {\n    const rows = ast.dataRows!.map((row) => {\n      const data = { ...row };\n      if (this.injectTenant && ctx) {\n        data[this.tenantColumns.appId] = ctx.appId;\n        data[this.tenantColumns.organizationId] = ctx.organizationId;\n      }\n      return data;\n    });\n\n    if (rows.length === 0) {\n      throw new Error('Cannot insert empty array of rows');\n    }\n\n    const columns = Object.keys(rows[0]);\n    const valueGroups: string[] = [];\n    let currentParamIndex = startParamIndex;\n\n    for (const row of rows) {\n      const values: string[] = [];\n      for (const col of columns) {\n        values.push(this.getParamPlaceholder(currentParamIndex++));\n        params.push(row[col]);\n      }\n      valueGroups.push(`(${values.join(', ')})`);\n    }\n\n    let sql = `INSERT INTO ${this.quoteIdentifier(ast.table)} (${columns.map((c) => this.quoteIdentifier(c)).join(', ')}) VALUES ${valueGroups.join(', ')}`;\n\n    if (ast.onConflict) {\n      sql += this.compileOnConflict(ast.onConflict, columns, currentParamIndex, params);\n    }\n\n    if (ast.returning?.length) {\n      sql += this.compileReturning(ast.returning);\n    }\n\n    return { sql, params };\n  }\n\n  private compileOnConflict(\n    conflict: QueryAST['onConflict'],\n    columns: string[],\n    _paramIndex: number,\n    _params: unknown[]\n  ): string {\n    if (!conflict) return '';\n\n    const conflictCols = conflict.columns.map((c) => this.quoteIdentifier(c)).join(', ');\n\n    switch (this.dialect) {\n      case 'postgresql':\n      case 'sqlite': {\n        if (conflict.action === 'nothing') {\n          return ` ON CONFLICT (${conflictCols}) DO NOTHING`;\n        }\n        const updateCols =\n          conflict.updateColumns || columns.filter((c) => !conflict.columns.includes(c));\n        const setClauses = updateCols.map(\n          (c) => `${this.quoteIdentifier(c)} = EXCLUDED.${this.quoteIdentifier(c)}`\n        );\n        return ` ON CONFLICT (${conflictCols}) DO UPDATE SET ${setClauses.join(', ')}`;\n      }\n      case 'mysql': {\n        if (conflict.action === 'nothing') {\n          return ' ON DUPLICATE KEY UPDATE id = id';\n        }\n        const updateCols =\n          conflict.updateColumns || columns.filter((c) => !conflict.columns.includes(c));\n        const setClauses = updateCols.map(\n          (c) => `${this.quoteIdentifier(c)} = VALUES(${this.quoteIdentifier(c)})`\n        );\n        return ` ON DUPLICATE KEY UPDATE ${setClauses.join(', ')}`;\n      }\n      default:\n        throw new Error(`Unsupported dialect for ON CONFLICT: ${this.dialect}`);\n    }\n  }\n\n  private compileUpdate(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    const params: unknown[] = [];\n    let paramIndex = 1;\n\n    const setClauses: string[] = [];\n    for (const [key, value] of Object.entries(ast.data!)) {\n      setClauses.push(`${this.quoteIdentifier(key)} = ${this.getParamPlaceholder(paramIndex++)}`);\n      params.push(value);\n    }\n\n    let sql = `UPDATE ${this.quoteIdentifier(ast.table)} SET ${setClauses.join(', ')}`;\n\n    const predicates: string[] = [];\n\n    if (this.injectTenant && ctx) {\n      predicates.push(\n        `${this.quoteIdentifier(this.tenantColumns.appId)} = ${this.getParamPlaceholder(paramIndex++)}`\n      );\n      params.push(ctx.appId);\n      predicates.push(\n        `${this.quoteIdentifier(this.tenantColumns.organizationId)} = ${this.getParamPlaceholder(paramIndex++)}`\n      );\n      params.push(ctx.organizationId);\n    }\n\n    if (ast.where?.length) {\n      for (const w of ast.where) {\n        const { predicate, values, paramCount } = this.compileWhere(w, paramIndex);\n        predicates.push(predicate);\n        params.push(...values);\n        paramIndex += paramCount;\n      }\n    }\n\n    if (predicates.length) {\n      sql += ` WHERE ${predicates.join(' AND ')}`;\n    }\n\n    if (ast.returning?.length) {\n      sql += this.compileReturning(ast.returning);\n    }\n\n    return { sql, params };\n  }\n\n  private compileDelete(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    const params: unknown[] = [];\n    let paramIndex = 1;\n\n    let sql = `DELETE FROM ${this.quoteIdentifier(ast.table)}`;\n\n    const predicates: string[] = [];\n\n    if (this.injectTenant && ctx) {\n      predicates.push(\n        `${this.quoteIdentifier(this.tenantColumns.appId)} = ${this.getParamPlaceholder(paramIndex++)}`\n      );\n      params.push(ctx.appId);\n      predicates.push(\n        `${this.quoteIdentifier(this.tenantColumns.organizationId)} = ${this.getParamPlaceholder(paramIndex++)}`\n      );\n      params.push(ctx.organizationId);\n    }\n\n    if (ast.where?.length) {\n      for (const w of ast.where) {\n        const { predicate, values, paramCount } = this.compileWhere(w, paramIndex);\n        predicates.push(predicate);\n        params.push(...values);\n        paramIndex += paramCount;\n      }\n    }\n\n    if (predicates.length) {\n      sql += ` WHERE ${predicates.join(' AND ')}`;\n    }\n\n    if (ast.returning?.length) {\n      sql += this.compileReturning(ast.returning);\n    }\n\n    return { sql, params };\n  }\n\n  private compileReturning(columns: string[]): string {\n    switch (this.dialect) {\n      case 'postgresql':\n      case 'sqlite':\n        return ` RETURNING ${columns.map((c) => this.quoteIdentifier(c)).join(', ')}`;\n      case 'mysql':\n        throw new Error(\n          'MySQL does not support RETURNING clause. Use separate SELECT query after INSERT/UPDATE/DELETE.'\n        );\n      default:\n        throw new Error(`Unsupported dialect for RETURNING: ${this.dialect}`);\n    }\n  }\n\n  private compileWhere(\n    w: WhereClause,\n    paramIndex: number\n  ): { predicate: string; values: unknown[]; paramCount: number } {\n    const col = this.quoteIdentifier(w.column);\n\n    switch (w.op) {\n      case 'IS NULL':\n        return { predicate: `${col} IS NULL`, values: [], paramCount: 0 };\n      case 'IS NOT NULL':\n        return { predicate: `${col} IS NOT NULL`, values: [], paramCount: 0 };\n      case 'IN':\n      case 'NOT IN': {\n        const inValues = w.value as unknown[];\n        if (inValues.length === 0) {\n          return {\n            predicate: w.op === 'IN' ? '1 = 0' : '1 = 1',\n            values: [],\n            paramCount: 0,\n          };\n        }\n        const placeholders = inValues\n          .map((_, i) => this.getParamPlaceholder(paramIndex + i))\n          .join(', ');\n        return {\n          predicate: `${col} ${w.op} (${placeholders})`,\n          values: inValues,\n          paramCount: inValues.length,\n        };\n      }\n      default:\n        return {\n          predicate: `${col} ${w.op} ${this.getParamPlaceholder(paramIndex)}`,\n          values: w.value !== undefined ? [w.value] : [],\n          paramCount: w.value !== undefined ? 1 : 0,\n        };\n    }\n  }\n\n  private joinPredicates(predicates: string[], whereClauses: WhereClause[]): string {\n    if (predicates.length === 0) return '';\n\n    const tenantPredicateCount = this.injectTenant ? 2 : 0;\n    const result = predicates.map((predicate, i) => {\n      if (i < tenantPredicateCount) return predicate;\n      const clause = whereClauses[i - tenantPredicateCount];\n      return clause?.connector === 'OR' ? `OR ${predicate}` : predicate;\n    });\n\n    return result.reduce((sql, part, i) => {\n      if (i === 0) return part;\n      return part.startsWith('OR ') ? `${sql} ${part}` : `${sql} AND ${part}`;\n    }, '');\n  }\n\n  private compileHaving(\n    h: HavingClause,\n    paramIndex: number\n  ): { predicate: string; values: unknown[]; paramCount: number } {\n    const col = this.quoteIdentifier(h.column);\n    return {\n      predicate: `${col} ${h.op} ${this.getParamPlaceholder(paramIndex)}`,\n      values: [h.value],\n      paramCount: 1,\n    };\n  }\n\n  private quoteIdentifier(identifier: string): string {\n    if (identifier === '*') return identifier;\n    // Don't quote SQL expressions (functions, aliases, etc.)\n    if (identifier.includes('(') || identifier.toLowerCase().includes(' as ')) {\n      return identifier;\n    }\n    if (identifier.includes('.')) {\n      return identifier\n        .split('.')\n        .map((part) => this.quoteIdentifier(part))\n        .join('.');\n    }\n\n    switch (this.dialect) {\n      case 'postgresql':\n        return `\"${identifier}\"`;\n      case 'mysql':\n        return `\\`${identifier}\\``;\n      case 'sqlite':\n        return `\"${identifier}\"`;\n      default:\n        return `\"${identifier}\"`;\n    }\n  }\n}\n\nexport function createCompiler(options: CompilerOptions): SQLCompiler {\n  return new SQLCompiler(options);\n}\n","import type { TenantContext } from '../types/index.js';\n\nexport class TenantContextError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'TenantContextError';\n  }\n}\n\nexport function validateTenantContext(ctx: TenantContext | undefined, tableName: string): void {\n  if (!ctx) {\n    throw new TenantContextError(\n      `Missing tenant context for table \"${tableName}\". Provide a valid TenantContext with appId and organizationId, or use tableWithoutTenant() for system tables.`\n    );\n  }\n\n  if (typeof ctx.appId !== 'string' || ctx.appId.trim() === '') {\n    throw new TenantContextError(\n      `Invalid tenant context for table \"${tableName}\": appId must be a non-empty string.`\n    );\n  }\n\n  if (typeof ctx.organizationId !== 'string' || ctx.organizationId.trim() === '') {\n    throw new TenantContextError(\n      `Invalid tenant context for table \"${tableName}\": organizationId must be a non-empty string.`\n    );\n  }\n}\n\nexport function validateTenantContextOrWarn(\n  ctx: TenantContext | undefined,\n  tableName: string\n): void {\n  if (!ctx) {\n    console.warn(\n      `[WARNING] Missing tenant context for table \"${tableName}\". This query will not be filtered by tenant. Use tableWithoutTenant() explicitly if this is intended.`\n    );\n    return;\n  }\n\n  if (typeof ctx.appId !== 'string' || ctx.appId.trim() === '') {\n    console.warn(\n      `[WARNING] Invalid appId in tenant context for table \"${tableName}\". This may result in unfiltered queries.`\n    );\n  }\n\n  if (typeof ctx.organizationId !== 'string' || ctx.organizationId.trim() === '') {\n    console.warn(\n      `[WARNING] Invalid organizationId in tenant context for table \"${tableName}\". This may result in unfiltered queries.`\n    );\n  }\n}\n","import type { SQLCompiler } from '../compiler/index.js';\nimport type { Driver, TransactionClient } from '../driver/types.js';\nimport type { Operator, QueryAST, TenantContext } from '../types/index.js';\nimport { validateTenantContextOrWarn } from '../utils/tenant-validation.js';\n\nexport class SelectBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'select',\n      table,\n      columns: ['*'],\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  select<K extends keyof T>(...columns: K[]): this {\n    this.ast.columns = columns as string[];\n    return this;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  whereNull(column: keyof T): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IS NULL', value: null });\n    return this;\n  }\n\n  whereNotNull(column: keyof T): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IS NOT NULL', value: null });\n    return this;\n  }\n\n  whereIn(column: keyof T, values: unknown[]): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IN', value: values });\n    return this;\n  }\n\n  whereNotIn(column: keyof T, values: unknown[]): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'NOT IN', value: values });\n    return this;\n  }\n\n  whereLike(column: keyof T, pattern: string): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'LIKE', value: pattern });\n    return this;\n  }\n\n  whereILike(column: keyof T, pattern: string): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'ILIKE', value: pattern });\n    return this;\n  }\n\n  orWhere(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value, connector: 'OR' });\n    return this;\n  }\n\n  groupBy(...columns: (keyof T)[]): this {\n    this.ast.groupBy = { columns: columns as string[] };\n    return this;\n  }\n\n  having(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.having = this.ast.having ?? [];\n    this.ast.having.push({ column: column as string, op, value });\n    return this;\n  }\n\n  orderBy(column: keyof T, direction: 'asc' | 'desc' = 'asc'): this {\n    this.ast.orderBy = { column: column as string, direction };\n    return this;\n  }\n\n  limit(n: number): this {\n    this.ast.limit = n;\n    return this;\n  }\n\n  offset(n: number): this {\n    this.ast.offset = n;\n    return this;\n  }\n\n  join(\n    type: 'INNER' | 'LEFT' | 'RIGHT' | 'FULL',\n    table: string,\n    leftColumn: string,\n    rightColumn: string,\n    alias?: string\n  ): this {\n    this.ast.joins = this.ast.joins ?? [];\n    this.ast.joins.push({\n      type,\n      table,\n      alias,\n      on: { leftColumn, rightColumn },\n    });\n    return this;\n  }\n\n  innerJoin(table: string, leftColumn: string, rightColumn: string, alias?: string): this {\n    return this.join('INNER', table, leftColumn, rightColumn, alias);\n  }\n\n  leftJoin(table: string, leftColumn: string, rightColumn: string, alias?: string): this {\n    return this.join('LEFT', table, leftColumn, rightColumn, alias);\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.query<T>(sql, params);\n    return result.rows;\n  }\n\n  async first(): Promise<T | null> {\n    this.validateTenantOnce();\n    this.limit(1);\n    const rows = await this.execute();\n    return rows[0] ?? null;\n  }\n\n  async count(): Promise<number> {\n    this.validateTenantOnce();\n    const originalColumns = this.ast.columns;\n    this.ast.columns = ['COUNT(*) as count'];\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.query<{ count: number | string }>(sql, params);\n    this.ast.columns = originalColumns;\n    return Number(result.rows[0]?.count ?? 0);\n  }\n\n  toSQL(): { sql: string; params: unknown[] } {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class InsertBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'insert',\n      table,\n      data: {},\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  values(data: Partial<Omit<T, 'app_id' | 'organization_id'>>): this {\n    this.ast.data = data as Record<string, unknown>;\n    return this;\n  }\n\n  valuesMany(rows: Partial<Omit<T, 'app_id' | 'organization_id'>>[]): this {\n    this.ast.dataRows = rows as Record<string, unknown>[];\n    return this;\n  }\n\n  onConflict(\n    columns: (keyof T)[],\n    action: 'update' | 'nothing',\n    updateColumns?: (keyof T)[]\n  ): this {\n    this.ast.onConflict = {\n      columns: columns as string[],\n      action,\n      updateColumns: updateColumns as string[],\n    };\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    if (this.ast.returning?.length) {\n      const result = await this.driver.query<T>(sql, params);\n      return result.rows;\n    }\n    await this.driver.execute(sql, params);\n    return [];\n  }\n\n  toSQL(): { sql: string; params: unknown[] } {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class UpdateBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'update',\n      table,\n      data: {},\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  set(data: Partial<Omit<T, 'app_id' | 'organization_id' | 'id' | 'created_at'>>): this {\n    this.ast.data = data as Record<string, unknown>;\n    return this;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    if (this.ast.returning?.length) {\n      const result = await this.driver.query<T>(sql, params);\n      return result.rows;\n    }\n    await this.driver.execute(sql, params);\n    return [];\n  }\n\n  toSQL(): { sql: string; params: unknown[] } {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class DeleteBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'delete',\n      table,\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    if (this.ast.returning?.length) {\n      const result = await this.driver.query<T>(sql, params);\n      return result.rows;\n    }\n    await this.driver.execute(sql, params);\n    return [];\n  }\n\n  toSQL(): { sql: string; params: unknown[] } {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class TableBuilder<T = Record<string, unknown>> {\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private tableName: string;\n  private ctx?: TenantContext;\n  private shouldValidateTenant: boolean;\n  private whereConditions: Array<{ column: string; op: Operator; value: unknown }> = [];\n  private orderByClause?: { column: string; direction: 'asc' | 'desc' };\n  private limitValue?: number;\n  private offsetValue?: number;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.tableName = table;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.whereConditions.push({ column: column as string, op, value });\n    return this;\n  }\n\n  whereNull(column: keyof T): this {\n    this.whereConditions.push({ column: column as string, op: 'IS NULL', value: null });\n    return this;\n  }\n\n  whereNotNull(column: keyof T): this {\n    this.whereConditions.push({ column: column as string, op: 'IS NOT NULL', value: null });\n    return this;\n  }\n\n  whereIn(column: keyof T, values: unknown[]): this {\n    this.whereConditions.push({ column: column as string, op: 'IN', value: values });\n    return this;\n  }\n\n  whereNotIn(column: keyof T, values: unknown[]): this {\n    this.whereConditions.push({ column: column as string, op: 'NOT IN', value: values });\n    return this;\n  }\n\n  whereLike(column: keyof T, pattern: string): this {\n    this.whereConditions.push({ column: column as string, op: 'LIKE', value: pattern });\n    return this;\n  }\n\n  whereILike(column: keyof T, pattern: string): this {\n    this.whereConditions.push({ column: column as string, op: 'ILIKE', value: pattern });\n    return this;\n  }\n\n  orderBy(column: keyof T, direction: 'asc' | 'desc' = 'asc'): this {\n    this.orderByClause = { column: column as string, direction };\n    return this;\n  }\n\n  limit(n: number): this {\n    this.limitValue = n;\n    return this;\n  }\n\n  offset(n: number): this {\n    this.offsetValue = n;\n    return this;\n  }\n\n  select<K extends keyof T>(...columns: K[]): SelectBuilder<T> {\n    const builder = new SelectBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    if (columns.length) {\n      builder.select(...columns);\n    }\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    if (this.orderByClause) {\n      builder.orderBy(this.orderByClause.column as keyof T, this.orderByClause.direction);\n    }\n    if (this.limitValue !== undefined) {\n      builder.limit(this.limitValue);\n    }\n    if (this.offsetValue !== undefined) {\n      builder.offset(this.offsetValue);\n    }\n    return builder;\n  }\n\n  insert(): InsertBuilder<T> {\n    return new InsertBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n  }\n\n  update(\n    data?: Partial<Omit<T, 'app_id' | 'organization_id' | 'id' | 'created_at'>>\n  ): UpdateBuilder<T> {\n    const builder = new UpdateBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    if (data) {\n      builder.set(data);\n    }\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    return builder;\n  }\n\n  delete(): DeleteBuilder<T> {\n    const builder = new DeleteBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    return builder;\n  }\n\n  async findById(id: string | number): Promise<T | null> {\n    return this.select()\n      .where('id' as keyof T, '=', id)\n      .first();\n  }\n\n  async findMany(options?: {\n    where?: Array<{ column: keyof T; op: Operator; value: unknown }>;\n    orderBy?: { column: keyof T; direction: 'asc' | 'desc' };\n    limit?: number;\n    offset?: number;\n  }): Promise<T[]> {\n    let builder = this.select();\n\n    if (options?.where) {\n      for (const w of options.where) {\n        builder = builder.where(w.column, w.op, w.value);\n      }\n    }\n\n    if (options?.orderBy) {\n      builder = builder.orderBy(options.orderBy.column, options.orderBy.direction);\n    }\n\n    if (options?.limit !== undefined) {\n      builder = builder.limit(options.limit);\n    }\n\n    if (options?.offset !== undefined) {\n      builder = builder.offset(options.offset);\n    }\n\n    return builder.execute();\n  }\n}\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nfunction compileMysqlDefault(colDef: ColumnDefinition): string {\n  if (!colDef.default) return '';\n  const defaultVal = colDef.default === 'gen_random_uuid()' ? '(UUID())' : colDef.default;\n  return ` DEFAULT ${defaultVal}`;\n}\n\nfunction compileMysqlConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  sql += compileMysqlDefault(colDef);\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compileMysqlForeignKeys(\n  tableName: string,\n  columns: Record<string, ColumnDefinition>\n): string[] {\n  const fkDefs: string[] = [];\n  for (const [colName, colDef] of Object.entries(columns)) {\n    if (colDef.references) {\n      const fkName = `fk_${tableName}_${colName}`;\n      let fk = `  CONSTRAINT \\`${fkName}\\` FOREIGN KEY (\\`${colName}\\`) `;\n      fk += `REFERENCES \\`${colDef.references.table}\\`(\\`${colDef.references.column}\\`)`;\n      if (colDef.references.onDelete) {\n        fk += ` ON DELETE ${colDef.references.onDelete}`;\n      }\n      fkDefs.push(fk);\n    }\n  }\n  return fkDefs;\n}\n\nexport const mysqlDialect: Dialect = {\n  name: 'mysql',\n  supportsTransactionalDDL: false,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'CHAR(36)',\n      string: 'VARCHAR(255)',\n      text: 'TEXT',\n      integer: 'INT',\n      bigint: 'BIGINT',\n      float: 'DOUBLE',\n      decimal: 'DECIMAL(10,2)',\n      boolean: 'TINYINT(1)',\n      datetime: 'DATETIME',\n      date: 'DATE',\n      time: 'TIME',\n      json: 'JSON',\n      binary: 'BLOB',\n    };\n    return map[type] || 'VARCHAR(255)';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \\`${colName}\\` ${this.mapType(colDef.type)}`;\n      return typeSql + compileMysqlConstraints(colDef);\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\\`${c}\\``).join(', ')})`);\n    }\n\n    const foreignKeys = compileMysqlForeignKeys(name, def.columns);\n    columnDefs.push(...foreignKeys);\n\n    return `CREATE TABLE \\`${name}\\` (\\n${columnDefs.join(',\\n')}\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \\`${name}\\``;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \\`${table}\\` ADD COLUMN \\`${column}\\` ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    if (def.unique) {\n      sql += ' UNIQUE';\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \\`${table}\\` DROP COLUMN \\`${column}\\``;\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \\`${table}\\` MODIFY COLUMN \\`${column}\\` ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    return sql;\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\\`${c}\\``).join(', ');\n    return `CREATE ${unique}INDEX \\`${indexName}\\` ON \\`${table}\\` (${columns})`;\n  },\n\n  dropIndex(name: string, table?: string): string {\n    if (!table) {\n      throw new Error('MySQL requires table name for DROP INDEX');\n    }\n    return `DROP INDEX \\`${name}\\` ON \\`${table}\\``;\n  },\n\n  addForeignKey(\n    table: string,\n    column: string,\n    refTable: string,\n    refColumn: string,\n    onDelete?: string\n  ): string {\n    const constraintName = `fk_${table}_${column}_${refTable}`;\n    let sql = `ALTER TABLE \\`${table}\\` ADD CONSTRAINT \\`${constraintName}\\` `;\n    sql += `FOREIGN KEY (\\`${column}\\`) REFERENCES \\`${refTable}\\`(\\`${refColumn}\\`)`;\n    if (onDelete) {\n      sql += ` ON DELETE ${onDelete}`;\n    }\n    return sql;\n  },\n\n  dropForeignKey(table: string, constraintName: string): string {\n    return `ALTER TABLE \\`${table}\\` DROP FOREIGN KEY \\`${constraintName}\\``;\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT table_name\n      FROM information_schema.tables\n      WHERE table_schema = DATABASE()\n        AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `\n      SELECT\n        column_name,\n        data_type,\n        is_nullable,\n        column_default,\n        character_maximum_length\n      FROM information_schema.columns\n      WHERE table_schema = DATABASE() AND table_name = '${table}'\n      ORDER BY ordinal_position\n    `;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `\n      SELECT\n        index_name,\n        column_name,\n        non_unique\n      FROM information_schema.statistics\n      WHERE table_schema = DATABASE() AND table_name = '${table}'\n      ORDER BY index_name, seq_in_index\n    `;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nfunction compilePostgresConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  if (colDef.default) {\n    sql += ` DEFAULT ${colDef.default}`;\n  }\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compilePostgresReferences(colDef: ColumnDefinition): string {\n  if (!colDef.references) return '';\n  let sql = ` REFERENCES \"${colDef.references.table}\"(\"${colDef.references.column}\")`;\n  if (colDef.references.onDelete) {\n    sql += ` ON DELETE ${colDef.references.onDelete}`;\n  }\n  if (colDef.references.onUpdate) {\n    sql += ` ON UPDATE ${colDef.references.onUpdate}`;\n  }\n  return sql;\n}\n\nexport const postgresDialect: Dialect = {\n  name: 'postgresql',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'UUID',\n      string: 'TEXT',\n      text: 'TEXT',\n      integer: 'INTEGER',\n      bigint: 'BIGINT',\n      float: 'DOUBLE PRECISION',\n      decimal: 'NUMERIC',\n      boolean: 'BOOLEAN',\n      datetime: 'TIMESTAMPTZ',\n      date: 'DATE',\n      time: 'TIME',\n      json: 'JSONB',\n      binary: 'BYTEA',\n    };\n    return map[type] || 'TEXT';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \"${colName}\" ${this.mapType(colDef.type)}`;\n      const constraints = compilePostgresConstraints(colDef);\n      const references = compilePostgresReferences(colDef);\n      return typeSql + constraints + references;\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\"${c}\"`).join(', ')})`);\n    }\n\n    return `CREATE TABLE \"${name}\" (\\n${columnDefs.join(',\\n')}\\n)`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \"${name}\" CASCADE`;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \"${table}\" ADD COLUMN \"${column}\" ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    if (def.unique) {\n      sql += ' UNIQUE';\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \"${table}\" DROP COLUMN \"${column}\"`;\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): string {\n    const statements: string[] = [];\n\n    statements.push(\n      `ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" TYPE ${this.mapType(def.type)}`\n    );\n\n    if (def.nullable === false) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" SET NOT NULL`);\n    } else if (def.nullable === true) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" DROP NOT NULL`);\n    }\n\n    if (def.default !== undefined) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" SET DEFAULT ${def.default}`);\n    }\n\n    return statements.join(';\\n');\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\"${c}\"`).join(', ');\n    let sql = `CREATE ${unique}INDEX \"${indexName}\" ON \"${table}\" (${columns})`;\n\n    if (index.where) {\n      sql += ` WHERE ${index.where}`;\n    }\n\n    return sql;\n  },\n\n  dropIndex(name: string): string {\n    return `DROP INDEX IF EXISTS \"${name}\"`;\n  },\n\n  addForeignKey(\n    table: string,\n    column: string,\n    refTable: string,\n    refColumn: string,\n    onDelete?: string\n  ): string {\n    const constraintName = `fk_${table}_${column}_${refTable}`;\n    let sql = `ALTER TABLE \"${table}\" ADD CONSTRAINT \"${constraintName}\" `;\n    sql += `FOREIGN KEY (\"${column}\") REFERENCES \"${refTable}\"(\"${refColumn}\")`;\n    if (onDelete) {\n      sql += ` ON DELETE ${onDelete}`;\n    }\n    return sql;\n  },\n\n  dropForeignKey(table: string, constraintName: string): string {\n    return `ALTER TABLE \"${table}\" DROP CONSTRAINT \"${constraintName}\"`;\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT table_name\n      FROM information_schema.tables\n      WHERE table_schema = 'public'\n        AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `\n      SELECT\n        column_name,\n        data_type,\n        is_nullable,\n        column_default,\n        character_maximum_length\n      FROM information_schema.columns\n      WHERE table_schema = 'public' AND table_name = '${table}'\n      ORDER BY ordinal_position\n    `;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `\n      SELECT\n        i.relname as index_name,\n        a.attname as column_name,\n        ix.indisunique as is_unique,\n        ix.indisprimary as is_primary\n      FROM pg_class t\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE t.relname = '${table}'\n      ORDER BY i.relname, a.attnum\n    `;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nconst SQLITE_UUID_DEFAULT =\n  \"(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))\";\n\nfunction compileSqliteDefault(colDef: ColumnDefinition): string {\n  if (!colDef.default) return '';\n  let defaultVal = colDef.default;\n  if (colDef.default === 'gen_random_uuid()') {\n    defaultVal = SQLITE_UUID_DEFAULT;\n  } else if (colDef.default === 'now()' || colDef.default === 'NOW()') {\n    defaultVal = \"datetime('now')\";\n  }\n  return ` DEFAULT ${defaultVal}`;\n}\n\nfunction compileSqliteConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  sql += compileSqliteDefault(colDef);\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compileSqliteReferences(colDef: ColumnDefinition): string {\n  if (!colDef.references) return '';\n  let sql = ` REFERENCES \"${colDef.references.table}\"(\"${colDef.references.column}\")`;\n  if (colDef.references.onDelete) {\n    sql += ` ON DELETE ${colDef.references.onDelete}`;\n  }\n  return sql;\n}\n\nexport const sqliteDialect: Dialect = {\n  name: 'sqlite',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'TEXT',\n      string: 'TEXT',\n      text: 'TEXT',\n      integer: 'INTEGER',\n      bigint: 'INTEGER',\n      float: 'REAL',\n      decimal: 'REAL',\n      boolean: 'INTEGER',\n      datetime: 'TEXT',\n      date: 'TEXT',\n      time: 'TEXT',\n      json: 'TEXT',\n      binary: 'BLOB',\n    };\n    return map[type] || 'TEXT';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \"${colName}\" ${this.mapType(colDef.type)}`;\n      const constraints = compileSqliteConstraints(colDef);\n      const references = compileSqliteReferences(colDef);\n      return typeSql + constraints + references;\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\"${c}\"`).join(', ')})`);\n    }\n\n    return `CREATE TABLE \"${name}\" (\\n${columnDefs.join(',\\n')}\\n)`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \"${name}\"`;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \"${table}\" ADD COLUMN \"${column}\" ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \"${table}\" DROP COLUMN \"${column}\"`;\n  },\n\n  alterColumn(_table: string, _column: string, _def: ColumnDefinition): string {\n    throw new Error(\n      'SQLite does not support ALTER COLUMN. Use table recreation instead: ' +\n        '1. Create new table with desired schema, 2. Copy data, 3. Drop old table, 4. Rename new table'\n    );\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\"${c}\"`).join(', ');\n    let sql = `CREATE ${unique}INDEX \"${indexName}\" ON \"${table}\" (${columns})`;\n\n    if (index.where) {\n      sql += ` WHERE ${index.where}`;\n    }\n\n    return sql;\n  },\n\n  dropIndex(name: string): string {\n    return `DROP INDEX IF EXISTS \"${name}\"`;\n  },\n\n  addForeignKey(\n    _table: string,\n    _column: string,\n    _refTable: string,\n    _refColumn: string,\n    _onDelete?: string\n  ): string {\n    throw new Error(\n      'SQLite does not support adding foreign keys after table creation. ' +\n        'Define foreign keys in CREATE TABLE or use table recreation.'\n    );\n  },\n\n  dropForeignKey(_table: string, _constraintName: string): string {\n    throw new Error('SQLite does not support dropping foreign keys. Use table recreation instead.');\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT name as table_name\n      FROM sqlite_master\n      WHERE type = 'table' AND name NOT LIKE 'sqlite_%'\n      ORDER BY name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `PRAGMA table_info(\"${table}\")`;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `PRAGMA index_list(\"${table}\")`;\n  },\n};\n","import type { DialectName } from '../../types/index.js';\nimport { mysqlDialect } from './mysql.js';\nimport { postgresDialect } from './postgresql.js';\nimport { sqliteDialect } from './sqlite.js';\nimport type { Dialect } from './types.js';\n\nexport type { Dialect } from './types.js';\n\nexport function getDialect(name: DialectName): Dialect {\n  switch (name) {\n    case 'postgresql':\n      return postgresDialect;\n    case 'mysql':\n      return mysqlDialect;\n    case 'sqlite':\n      return sqliteDialect;\n    default:\n      throw new Error(`Unsupported dialect: ${name}`);\n  }\n}\n\nexport { postgresDialect, mysqlDialect, sqliteDialect };\n","import { createHash } from 'node:crypto';\nimport { readFile, readdir } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { Driver } from '../driver/types.js';\nimport type {\n  MigrationFile,\n  MigrationRecord,\n  MigrationResult,\n  MigrationStatus,\n} from '../types/index.js';\nimport { getDialect } from './dialects/index.js';\nimport type { Dialect } from './dialects/types.js';\n\nexport interface MigrationRunnerOptions {\n  migrationsPath: string;\n  tableName?: string;\n}\n\nexport interface MigrationRunOptions {\n  scope?: 'core' | 'template';\n  templateKey?: string;\n  moduleName?: string;\n  steps?: number;\n  toVersion?: number;\n  dryRun?: boolean;\n}\n\nexport class MigrationRunner {\n  private driver: Driver;\n  private dialect: Dialect;\n  private migrationsPath: string;\n  private tableName: string;\n\n  constructor(driver: Driver, options: MigrationRunnerOptions) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.migrationsPath = options.migrationsPath;\n    this.tableName = options.tableName ?? 'lp_migrations';\n  }\n\n  async ensureMigrationsTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          version BIGINT PRIMARY KEY,\n          name TEXT NOT NULL,\n          scope TEXT NOT NULL CHECK (scope IN ('core', 'template')),\n          template_key TEXT,\n          module_name TEXT,\n          checksum TEXT NOT NULL,\n          up_sql TEXT[] NOT NULL,\n          down_sql TEXT[],\n          applied_at TIMESTAMPTZ DEFAULT NOW(),\n          executed_by TEXT\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            version BIGINT PRIMARY KEY,\n            name VARCHAR(255) NOT NULL,\n            scope VARCHAR(20) NOT NULL,\n            template_key VARCHAR(255),\n            module_name VARCHAR(255),\n            checksum VARCHAR(64) NOT NULL,\n            up_sql JSON NOT NULL,\n            down_sql JSON,\n            applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            executed_by VARCHAR(255)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            version INTEGER PRIMARY KEY,\n            name TEXT NOT NULL,\n            scope TEXT NOT NULL CHECK (scope IN ('core', 'template')),\n            template_key TEXT,\n            module_name TEXT,\n            checksum TEXT NOT NULL,\n            up_sql TEXT NOT NULL,\n            down_sql TEXT,\n            applied_at TEXT DEFAULT (datetime('now')),\n            executed_by TEXT\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(`\n        CREATE UNIQUE INDEX IF NOT EXISTS idx_${this.tableName}_scope_version\n        ON \"${this.tableName}\" (scope, COALESCE(template_key, ''), version)\n      `);\n    }\n  }\n\n  async up(options: MigrationRunOptions = {}): Promise<MigrationResult[]> {\n    await this.ensureMigrationsTable();\n\n    const pending = await this.getPendingMigrations(options);\n    const results: MigrationResult[] = [];\n\n    let migrationsToRun = pending;\n    if (options.steps) {\n      migrationsToRun = pending.slice(0, options.steps);\n    }\n    if (options.toVersion) {\n      migrationsToRun = pending.filter((m) => m.version <= options.toVersion!);\n    }\n\n    for (const migration of migrationsToRun) {\n      const startTime = Date.now();\n\n      if (options.dryRun) {\n        console.log(`[DRY RUN] Would apply migration: ${migration.version}__${migration.name}`);\n        console.log(migration.up.join('\\n'));\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: 0,\n        });\n        continue;\n      }\n\n      try {\n        if (this.dialect.supportsTransactionalDDL) {\n          await this.driver.transaction(async (trx) => {\n            for (const sql of migration.up) {\n              await trx.execute(sql);\n            }\n            await this.recordMigration(trx, migration);\n          });\n        } else {\n          for (const sql of migration.up) {\n            await this.driver.execute(sql);\n          }\n          await this.recordMigration(this.driver, migration);\n        }\n\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: Date.now() - startTime,\n        });\n      } catch (error) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n        break;\n      }\n    }\n\n    return results;\n  }\n\n  async down(options: MigrationRunOptions = {}): Promise<MigrationResult[]> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const results: MigrationResult[] = [];\n\n    let migrationsToRollback = applied.reverse();\n    if (options.steps) {\n      migrationsToRollback = migrationsToRollback.slice(0, options.steps);\n    }\n    if (options.toVersion) {\n      migrationsToRollback = migrationsToRollback.filter((m) => m.version > options.toVersion!);\n    }\n\n    for (const migration of migrationsToRollback) {\n      if (!migration.downSql?.length) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: 'No down migration available',\n          duration: 0,\n        });\n        break;\n      }\n\n      const startTime = Date.now();\n\n      if (options.dryRun) {\n        console.log(`[DRY RUN] Would rollback migration: ${migration.version}__${migration.name}`);\n        console.log(migration.downSql.join('\\n'));\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: 0,\n        });\n        continue;\n      }\n\n      try {\n        if (this.dialect.supportsTransactionalDDL) {\n          await this.driver.transaction(async (trx) => {\n            for (const sql of migration.downSql) {\n              await trx.execute(sql);\n            }\n            await this.removeMigrationRecord(trx, migration.version);\n          });\n        } else {\n          for (const sql of migration.downSql) {\n            await this.driver.execute(sql);\n          }\n          await this.removeMigrationRecord(this.driver, migration.version);\n        }\n\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: Date.now() - startTime,\n        });\n      } catch (error) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n        break;\n      }\n    }\n\n    return results;\n  }\n\n  async status(options: MigrationRunOptions = {}): Promise<MigrationStatus> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const pending = await this.getPendingMigrations(options);\n    const current = applied.length ? applied[applied.length - 1].version : null;\n\n    return { applied, pending, current };\n  }\n\n  async verify(options: MigrationRunOptions = {}): Promise<{ valid: boolean; issues: string[] }> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const files = await this.loadMigrationFiles(options);\n    const issues: string[] = [];\n\n    for (const record of applied) {\n      const file = files.find((f) => f.version === record.version);\n      if (!file) {\n        issues.push(`Migration ${record.version}__${record.name} was applied but file is missing`);\n        continue;\n      }\n\n      const fileChecksum = this.computeChecksum(file.up);\n      if (fileChecksum !== record.checksum) {\n        issues.push(\n          `Migration ${record.version}__${record.name} checksum mismatch. File has been modified after being applied.`\n        );\n      }\n    }\n\n    return { valid: issues.length === 0, issues };\n  }\n\n  private sanitizeTemplateKey(templateKey: string): string {\n    if (!/^[a-zA-Z0-9_-]+$/.test(templateKey)) {\n      throw new Error(\n        `Invalid templateKey: \"${templateKey}\". Only alphanumeric characters, hyphens, and underscores are allowed.`\n      );\n    }\n    return templateKey;\n  }\n\n  private async loadMigrationFiles(options: MigrationRunOptions = {}): Promise<MigrationFile[]> {\n    const scope = options.scope ?? 'core';\n    let dirPath: string;\n\n    if (scope === 'template' && options.templateKey) {\n      const sanitizedKey = this.sanitizeTemplateKey(options.templateKey);\n      dirPath = join(this.migrationsPath, 'templates', sanitizedKey);\n    } else {\n      dirPath = join(this.migrationsPath, 'core');\n    }\n\n    try {\n      const files = await readdir(dirPath);\n      const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();\n\n      const migrations: MigrationFile[] = [];\n\n      for (const file of sqlFiles) {\n        const content = await readFile(join(dirPath, file), 'utf-8');\n        const parsed = this.parseMigrationFile(file, content, scope, options.templateKey);\n        if (parsed) {\n          migrations.push(parsed);\n        }\n      }\n\n      return migrations;\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  private parseMigrationFile(\n    filename: string,\n    content: string,\n    scope: 'core' | 'template',\n    templateKey?: string\n  ): MigrationFile | null {\n    const match = filename.match(/^(\\d+)__(.+)\\.sql$/);\n    if (!match) return null;\n\n    const [, versionStr, name] = match;\n    const version = Number.parseInt(versionStr, 10);\n\n    const upMatch = content.match(/--\\s*up\\s*\\n([\\s\\S]*?)(?=--\\s*down|$)/i);\n    const downMatch = content.match(/--\\s*down\\s*\\n([\\s\\S]*?)$/i);\n\n    const up = upMatch ? this.splitSqlStatements(upMatch[1]) : [];\n    const down = downMatch ? this.splitSqlStatements(downMatch[1]) : [];\n\n    if (!up.length) return null;\n\n    return {\n      version,\n      name,\n      up,\n      down,\n      scope,\n      templateKey,\n    };\n  }\n\n  private async getAppliedMigrations(\n    options: MigrationRunOptions = {}\n  ): Promise<MigrationRecord[]> {\n    const scope = options.scope ?? 'core';\n    const templateKey = options.templateKey ?? null;\n    const moduleName = options.moduleName ?? null;\n\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT version, name, scope, template_key, module_name, checksum, up_sql, down_sql, applied_at, executed_by\n        FROM \"${this.tableName}\"\n        WHERE scope = $1 AND (template_key = $2 OR (template_key IS NULL AND $2 IS NULL))\n          AND (module_name = $3 OR (module_name IS NULL AND $3 IS NULL))\n        ORDER BY version ASC\n      `;\n      params = [scope, templateKey, moduleName];\n    } else {\n      sql = `\n        SELECT version, name, scope, template_key, module_name, checksum, up_sql, down_sql, applied_at, executed_by\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE scope = ? AND (template_key = ? OR (template_key IS NULL AND ? IS NULL))\n          AND (module_name = ? OR (module_name IS NULL AND ? IS NULL))\n        ORDER BY version ASC\n      `;\n      params = [scope, templateKey, templateKey, moduleName, moduleName];\n    }\n\n    const result = await this.driver.query<{\n      version: number;\n      name: string;\n      scope: 'core' | 'template';\n      template_key: string | null;\n      module_name: string | null;\n      checksum: string;\n      up_sql: string[] | string;\n      down_sql: string[] | string | null;\n      applied_at: Date | string;\n      executed_by: string | null;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      version: Number(row.version),\n      name: row.name,\n      scope: row.scope,\n      templateKey: row.template_key,\n      moduleName: row.module_name,\n      checksum: row.checksum,\n      upSql: typeof row.up_sql === 'string' ? JSON.parse(row.up_sql) : row.up_sql,\n      downSql: row.down_sql\n        ? typeof row.down_sql === 'string'\n          ? JSON.parse(row.down_sql)\n          : row.down_sql\n        : [],\n      appliedAt: new Date(row.applied_at),\n      executedBy: row.executed_by,\n    }));\n  }\n\n  private async getPendingMigrations(options: MigrationRunOptions = {}): Promise<MigrationFile[]> {\n    const files = await this.loadMigrationFiles(options);\n    const applied = await this.getAppliedMigrations(options);\n    const appliedVersions = new Set(applied.map((m) => m.version));\n\n    return files.filter((f) => !appliedVersions.has(f.version));\n  }\n\n  private async recordMigration(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    migration: MigrationFile\n  ): Promise<void> {\n    const checksum = this.computeChecksum(migration.up);\n\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          migration.up,\n          migration.down.length ? migration.down : null,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await client.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          JSON.stringify(migration.up),\n          migration.down.length ? JSON.stringify(migration.down) : null,\n        ]\n      );\n    } else {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          JSON.stringify(migration.up),\n          migration.down.length ? JSON.stringify(migration.down) : null,\n        ]\n      );\n    }\n  }\n\n  private async removeMigrationRecord(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    version: number\n  ): Promise<void> {\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(`DELETE FROM \"${this.tableName}\" WHERE version = $1`, [version]);\n    } else {\n      await client.execute(\n        `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE version = ?`,\n        [version]\n      );\n    }\n  }\n\n  private computeChecksum(statements: string[]): string {\n    return createHash('sha256').update(statements.join('\\n')).digest('hex');\n  }\n\n  private splitSqlStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inSingleQuote) {\n        current += char;\n        if (char === \"'\" && next !== \"'\") {\n          inSingleQuote = false;\n        } else if (char === \"'\" && next === \"'\") {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (inDoubleQuote) {\n        current += char;\n        if (char === '\"' && next !== '\"') {\n          inDoubleQuote = false;\n        } else if (char === '\"' && next === '\"') {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\") {\n        inSingleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '\"') {\n        inDoubleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n\nexport function createMigrationRunner(\n  driver: Driver,\n  options: MigrationRunnerOptions\n): MigrationRunner {\n  return new MigrationRunner(driver, options);\n}\n","import { createHash } from 'node:crypto';\nimport type { Driver } from '../driver/types.js';\nimport { type Dialect, getDialect } from '../migrations/dialects/index.js';\nimport type { MigrationResult, SchemaDefinition, TableDefinition } from '../types/index.js';\n\nexport interface SchemaRegistryOptions {\n  tableName?: string;\n}\n\nexport interface RegisterSchemaOptions {\n  appId: string;\n  schemaName: string;\n  version: string;\n  schema: SchemaDefinition;\n}\n\nexport interface SchemaRecord {\n  app_id: string;\n  schema_name: string;\n  version: string;\n  schema: SchemaDefinition;\n  checksum: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport class SchemaRegistry {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: SchemaRegistryOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_schema_registry';\n  }\n\n  async ensureRegistryTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          app_id TEXT NOT NULL,\n          schema_name TEXT NOT NULL,\n          version TEXT NOT NULL,\n          schema JSONB NOT NULL,\n          checksum TEXT NOT NULL,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW(),\n          PRIMARY KEY (app_id, schema_name)\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            app_id VARCHAR(255) NOT NULL,\n            schema_name VARCHAR(255) NOT NULL,\n            version VARCHAR(50) NOT NULL,\n            schema JSON NOT NULL,\n            checksum VARCHAR(64) NOT NULL,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            PRIMARY KEY (app_id, schema_name)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            app_id TEXT NOT NULL,\n            schema_name TEXT NOT NULL,\n            version TEXT NOT NULL,\n            schema TEXT NOT NULL,\n            checksum TEXT NOT NULL,\n            created_at TEXT DEFAULT (datetime('now')),\n            updated_at TEXT DEFAULT (datetime('now')),\n            PRIMARY KEY (app_id, schema_name)\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n  }\n\n  async register(options: RegisterSchemaOptions): Promise<MigrationResult[]> {\n    await this.ensureRegistryTable();\n\n    this.validateSchema(options.schema);\n\n    const current = await this.getCurrentSchema(options.appId, options.schemaName);\n    const diff = this.computeDiff(current?.schema ?? null, options.schema);\n\n    if (diff.length === 0) {\n      return [];\n    }\n\n    const results: MigrationResult[] = [];\n    const checksum = this.computeChecksum(options.schema);\n\n    if (this.dialect.supportsTransactionalDDL) {\n      await this.driver.transaction(async (trx) => {\n        for (const change of diff) {\n          const startTime = Date.now();\n          try {\n            await trx.execute(change.sql);\n            results.push({\n              version: Date.now(),\n              name: change.description,\n              success: true,\n              duration: Date.now() - startTime,\n            });\n          } catch (error) {\n            results.push({\n              version: Date.now(),\n              name: change.description,\n              success: false,\n              error: error instanceof Error ? error.message : String(error),\n              duration: Date.now() - startTime,\n            });\n            throw error;\n          }\n        }\n\n        await this.upsertSchemaRecord(trx, {\n          appId: options.appId,\n          schemaName: options.schemaName,\n          version: options.version,\n          schema: options.schema,\n          checksum,\n        });\n      });\n    } else {\n      for (const change of diff) {\n        const startTime = Date.now();\n        try {\n          await this.driver.execute(change.sql);\n          results.push({\n            version: Date.now(),\n            name: change.description,\n            success: true,\n            duration: Date.now() - startTime,\n          });\n        } catch (error) {\n          results.push({\n            version: Date.now(),\n            name: change.description,\n            success: false,\n            error: error instanceof Error ? error.message : String(error),\n            duration: Date.now() - startTime,\n          });\n          throw error;\n        }\n      }\n\n      await this.upsertSchemaRecord(this.driver, {\n        appId: options.appId,\n        schemaName: options.schemaName,\n        version: options.version,\n        schema: options.schema,\n        checksum,\n      });\n    }\n\n    return results;\n  }\n\n  async getCurrentSchema(appId: string, schemaName: string): Promise<SchemaRecord | null> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT app_id, schema_name, version, schema, checksum, created_at, updated_at\n        FROM \"${this.tableName}\"\n        WHERE app_id = $1 AND schema_name = $2\n      `;\n      params = [appId, schemaName];\n    } else {\n      sql = `\n        SELECT app_id, schema_name, version, schema, checksum, created_at, updated_at\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE app_id = ? AND schema_name = ?\n      `;\n      params = [appId, schemaName];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      schema_name: string;\n      version: string;\n      schema: SchemaDefinition | string;\n      checksum: string;\n      created_at: Date | string;\n      updated_at: Date | string;\n    }>(sql, params);\n\n    if (!result.rows.length) return null;\n\n    const row = result.rows[0];\n    return {\n      app_id: row.app_id,\n      schema_name: row.schema_name,\n      version: row.version,\n      schema: typeof row.schema === 'string' ? JSON.parse(row.schema) : row.schema,\n      checksum: row.checksum,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    };\n  }\n\n  async listSchemas(appId?: string): Promise<SchemaRecord[]> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = appId\n        ? `SELECT * FROM \"${this.tableName}\" WHERE app_id = $1 ORDER BY schema_name`\n        : `SELECT * FROM \"${this.tableName}\" ORDER BY app_id, schema_name`;\n      params = appId ? [appId] : [];\n    } else {\n      const table = this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`;\n      sql = appId\n        ? `SELECT * FROM ${table} WHERE app_id = ? ORDER BY schema_name`\n        : `SELECT * FROM ${table} ORDER BY app_id, schema_name`;\n      params = appId ? [appId] : [];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      schema_name: string;\n      version: string;\n      schema: SchemaDefinition | string;\n      checksum: string;\n      created_at: Date | string;\n      updated_at: Date | string;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      app_id: row.app_id,\n      schema_name: row.schema_name,\n      version: row.version,\n      schema: typeof row.schema === 'string' ? JSON.parse(row.schema) : row.schema,\n      checksum: row.checksum,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n  }\n\n  private validateSchema(schema: SchemaDefinition): void {\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      if (!table.columns.app_id) {\n        throw new Error(`Table \"${tableName}\" must have an \"app_id\" column for multi-tenancy`);\n      }\n      if (!table.columns.organization_id) {\n        throw new Error(\n          `Table \"${tableName}\" must have an \"organization_id\" column for multi-tenancy`\n        );\n      }\n      if (!table.columns.id) {\n        throw new Error(`Table \"${tableName}\" must have an \"id\" column`);\n      }\n\n      const appIdCol = table.columns.app_id;\n      const orgIdCol = table.columns.organization_id;\n\n      if (!appIdCol.tenant) {\n        throw new Error(`Column \"app_id\" in table \"${tableName}\" must be marked as tenant column`);\n      }\n      if (!orgIdCol.tenant) {\n        throw new Error(\n          `Column \"organization_id\" in table \"${tableName}\" must be marked as tenant column`\n        );\n      }\n    }\n  }\n\n  private computeDiff(\n    current: SchemaDefinition | null,\n    desired: SchemaDefinition\n  ): Array<{ sql: string; description: string }> {\n    const changes: Array<{ sql: string; description: string }> = [];\n\n    for (const [tableName, desiredTable] of Object.entries(desired.tables)) {\n      const currentTable = current?.tables[tableName];\n\n      if (!currentTable) {\n        const sql = this.dialect.createTable(tableName, desiredTable);\n        changes.push({ sql, description: `Create table ${tableName}` });\n\n        if (desiredTable.indexes) {\n          for (const index of desiredTable.indexes) {\n            const indexSql = this.dialect.createIndex(tableName, index);\n            changes.push({\n              sql: indexSql,\n              description: `Create index on ${tableName}(${index.columns.join(', ')})`,\n            });\n          }\n        }\n\n        continue;\n      }\n\n      for (const [colName, desiredCol] of Object.entries(desiredTable.columns)) {\n        const currentCol = currentTable.columns[colName];\n\n        if (!currentCol) {\n          const sql = this.dialect.addColumn(tableName, colName, desiredCol);\n          changes.push({ sql, description: `Add column ${tableName}.${colName}` });\n        } else if (!this.columnsEqual(currentCol, desiredCol)) {\n          try {\n            const sql = this.dialect.alterColumn(tableName, colName, desiredCol);\n            changes.push({ sql, description: `Alter column ${tableName}.${colName}` });\n          } catch (error) {\n            console.warn(`Cannot alter column ${tableName}.${colName}: ${error}`);\n          }\n        }\n      }\n\n      for (const colName of Object.keys(currentTable.columns)) {\n        if (!desiredTable.columns[colName]) {\n          try {\n            const sql = this.dialect.dropColumn(tableName, colName);\n            changes.push({ sql, description: `Drop column ${tableName}.${colName}` });\n          } catch (error) {\n            console.warn(`Cannot drop column ${tableName}.${colName}: ${error}`);\n          }\n        }\n      }\n    }\n\n    if (current) {\n      for (const tableName of Object.keys(current.tables)) {\n        if (!desired.tables[tableName]) {\n          const sql = this.dialect.dropTable(tableName);\n          changes.push({ sql, description: `Drop table ${tableName}` });\n        }\n      }\n    }\n\n    return changes;\n  }\n\n  private columnsEqual(\n    a: TableDefinition['columns'][string],\n    b: TableDefinition['columns'][string]\n  ): boolean {\n    return (\n      a.type === b.type &&\n      a.nullable === b.nullable &&\n      a.unique === b.unique &&\n      a.default === b.default &&\n      JSON.stringify(a.references) === JSON.stringify(b.references)\n    );\n  }\n\n  private async upsertSchemaRecord(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    data: {\n      appId: string;\n      schemaName: string;\n      version: string;\n      schema: SchemaDefinition;\n      checksum: string;\n    }\n  ): Promise<void> {\n    const schemaJson = JSON.stringify(data.schema);\n\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (app_id, schema_name, version, schema, checksum)\n        VALUES ($1, $2, $3, $4, $5)\n        ON CONFLICT (app_id, schema_name) DO UPDATE SET\n          version = EXCLUDED.version,\n          schema = EXCLUDED.schema,\n          checksum = EXCLUDED.checksum,\n          updated_at = NOW()\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await client.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (app_id, schema_name, version, schema, checksum)\n        VALUES (?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          version = VALUES(version),\n          schema = VALUES(schema),\n          checksum = VALUES(checksum)\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    } else {\n      await client.execute(\n        `\n        INSERT OR REPLACE INTO \"${this.tableName}\" (app_id, schema_name, version, schema, checksum, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, datetime('now'), datetime('now'))\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    }\n  }\n\n  private computeChecksum(schema: SchemaDefinition): string {\n    return createHash('sha256').update(JSON.stringify(schema)).digest('hex');\n  }\n}\n\nexport function createSchemaRegistry(\n  driver: Driver,\n  options?: SchemaRegistryOptions\n): SchemaRegistry {\n  return new SchemaRegistry(driver, options);\n}\n","import { SQLCompiler } from './compiler/index.js';\nimport type { Driver, TransactionClient } from './driver/types.js';\nimport { type MigrationRunOptions, MigrationRunner } from './migrations/runner.js';\nimport { TableBuilder } from './query-builder/index.js';\nimport { type RegisterSchemaOptions, SchemaRegistry } from './schema/registry.js';\nimport type { QueryResult, TenantContext } from './types/index.js';\nimport { validateTenantContext } from './utils/tenant-validation.js';\n\nexport interface DbClientOptions {\n  migrationsPath?: string;\n  tenantColumns?: {\n    appId: string;\n    organizationId: string;\n  };\n  strictTenantMode?: boolean;\n}\n\nexport class DbClient {\n  private driver: Driver;\n  private compiler: SQLCompiler;\n  private migrationRunner?: MigrationRunner;\n  private schemaRegistry: SchemaRegistry;\n  private strictTenantMode: boolean;\n\n  constructor(driver: Driver, options: DbClientOptions = {}) {\n    this.driver = driver;\n    this.compiler = new SQLCompiler({\n      dialect: driver.dialect,\n      injectTenant: true,\n      tenantColumns: options.tenantColumns,\n    });\n\n    if (options.migrationsPath) {\n      this.migrationRunner = new MigrationRunner(driver, {\n        migrationsPath: options.migrationsPath,\n      });\n    }\n\n    this.schemaRegistry = new SchemaRegistry(driver);\n    this.strictTenantMode = options.strictTenantMode ?? true;\n  }\n\n  table<T = Record<string, unknown>>(name: string, ctx: TenantContext): TableBuilder<T> {\n    if (this.strictTenantMode) {\n      validateTenantContext(ctx, name);\n    }\n    return new TableBuilder<T>(this.driver, this.compiler, name, ctx, true);\n  }\n\n  tableWithoutTenant<T = Record<string, unknown>>(name: string): TableBuilder<T> {\n    const compilerWithoutTenant = new SQLCompiler({\n      dialect: this.driver.dialect,\n      injectTenant: false,\n    });\n    return new TableBuilder<T>(this.driver, compilerWithoutTenant, name, undefined, false);\n  }\n\n  async transaction<T>(\n    ctx: TenantContext,\n    fn: (trx: TransactionContext) => Promise<T>\n  ): Promise<T> {\n    return this.driver.transaction(async (trxClient) => {\n      if (this.driver.dialect === 'postgresql') {\n        await trxClient.execute(`SELECT set_config('app.current_app_id', $1, true)`, [ctx.appId]);\n        await trxClient.execute(`SELECT set_config('app.current_org_id', $1, true)`, [\n          ctx.organizationId,\n        ]);\n      }\n\n      const trxContext = new TransactionContext(trxClient, this.compiler, ctx);\n      return fn(trxContext);\n    });\n  }\n\n  async raw<T = Record<string, unknown>>(sql: string, params?: unknown[]): Promise<QueryResult<T>> {\n    return this.driver.query<T>(sql, params);\n  }\n\n  async rawWithTenant<T = Record<string, unknown>>(\n    ctx: TenantContext,\n    sql: string,\n    params: unknown[] = []\n  ): Promise<QueryResult<T>> {\n    const tenantParams = [ctx.appId, ctx.organizationId, ...params];\n    return this.driver.query<T>(sql, tenantParams);\n  }\n\n  async execute(sql: string, params?: unknown[]): Promise<{ rowCount: number }> {\n    return this.driver.execute(sql, params);\n  }\n\n  get migrations() {\n    if (!this.migrationRunner) {\n      throw new Error('Migrations path not configured. Pass migrationsPath to DbClient options.');\n    }\n    return {\n      up: (options?: MigrationRunOptions) => this.migrationRunner!.up(options),\n      down: (options?: MigrationRunOptions) => this.migrationRunner!.down(options),\n      status: (options?: MigrationRunOptions) => this.migrationRunner!.status(options),\n      verify: (options?: MigrationRunOptions) => this.migrationRunner!.verify(options),\n    };\n  }\n\n  get schema() {\n    return {\n      register: (options: RegisterSchemaOptions) => this.schemaRegistry.register(options),\n      get: (appId: string, schemaName: string) =>\n        this.schemaRegistry.getCurrentSchema(appId, schemaName),\n      list: (appId?: string) => this.schemaRegistry.listSchemas(appId),\n    };\n  }\n\n  get dialect() {\n    return this.driver.dialect;\n  }\n\n  async close(): Promise<void> {\n    return this.driver.close();\n  }\n}\n\nexport class TransactionContext {\n  private client: TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx: TenantContext;\n\n  constructor(client: TransactionClient, compiler: SQLCompiler, ctx: TenantContext) {\n    this.client = client;\n    this.compiler = compiler;\n    this.ctx = ctx;\n  }\n\n  table<T = Record<string, unknown>>(name: string): TableBuilder<T> {\n    return new TableBuilder<T>(this.client, this.compiler, name, this.ctx, true);\n  }\n\n  async raw<T = Record<string, unknown>>(sql: string, params?: unknown[]): Promise<QueryResult<T>> {\n    return this.client.query<T>(sql, params);\n  }\n\n  async execute(sql: string, params?: unknown[]): Promise<{ rowCount: number }> {\n    return this.client.execute(sql, params);\n  }\n}\n\nexport function createDbClient(driver: Driver, options?: DbClientOptions): DbClient {\n  return new DbClient(driver, options);\n}\n","import type { ColumnType, IndexDefinition } from '../types/index.js';\n\nexport interface EntityMetadata {\n  tableName: string;\n  columns: Map<string, ColumnMetadata>;\n  indexes: IndexDefinition[];\n  relations: Map<string, RelationMetadata>;\n}\n\nexport interface ColumnMetadata {\n  propertyName: string;\n  columnName: string;\n  type: ColumnType;\n  primaryKey: boolean;\n  nullable: boolean;\n  unique: boolean;\n  default?: string;\n  tenant: boolean;\n  references?: {\n    table: string;\n    column: string;\n    onDelete?: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n    onUpdate?: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n  };\n}\n\nexport interface RelationMetadata {\n  propertyName: string;\n  type: 'one-to-many' | 'many-to-one' | 'one-to-one' | 'many-to-many';\n  target: () => Function;\n  inverseSide?: string;\n  foreignKey?: string;\n  joinTable?: string;\n}\n\nexport type EntityConstructor<T = unknown> = new (...args: unknown[]) => T;\n\nclass MetadataStorage {\n  private entities: Map<Function, EntityMetadata> = new Map();\n\n  registerEntity(target: Function, tableName: string): void {\n    if (!this.entities.has(target)) {\n      this.entities.set(target, {\n        tableName,\n        columns: new Map(),\n        indexes: [],\n        relations: new Map(),\n      });\n    } else {\n      const metadata = this.entities.get(target)!;\n      metadata.tableName = tableName;\n    }\n  }\n\n  registerColumn(target: Function, propertyName: string, metadata: Partial<ColumnMetadata>): void {\n    this.ensureEntity(target);\n    const entity = this.entities.get(target)!;\n\n    const existing = entity.columns.get(propertyName) || {\n      propertyName,\n      columnName: this.toSnakeCase(propertyName),\n      type: 'string' as ColumnType,\n      primaryKey: false,\n      nullable: true,\n      unique: false,\n      tenant: false,\n    };\n\n    entity.columns.set(propertyName, { ...existing, ...metadata });\n  }\n\n  registerRelation(target: Function, propertyName: string, metadata: RelationMetadata): void {\n    this.ensureEntity(target);\n    const entity = this.entities.get(target)!;\n    entity.relations.set(propertyName, metadata);\n  }\n\n  registerIndex(target: Function, index: IndexDefinition): void {\n    this.ensureEntity(target);\n    const entity = this.entities.get(target)!;\n    entity.indexes.push(index);\n  }\n\n  getEntityMetadata(target: Function): EntityMetadata | undefined {\n    return this.entities.get(target);\n  }\n\n  getAllEntities(): Map<Function, EntityMetadata> {\n    return this.entities;\n  }\n\n  hasEntity(target: Function): boolean {\n    return this.entities.has(target);\n  }\n\n  private ensureEntity(target: Function): void {\n    if (!this.entities.has(target)) {\n      this.entities.set(target, {\n        tableName: this.toSnakeCase(target.name),\n        columns: new Map(),\n        indexes: [],\n        relations: new Map(),\n      });\n    }\n  }\n\n  private toSnakeCase(str: string): string {\n    return str\n      .replace(/([A-Z])/g, '_$1')\n      .toLowerCase()\n      .replace(/^_/, '');\n  }\n\n  clear(): void {\n    this.entities.clear();\n  }\n}\n\nexport const metadataStorage = new MetadataStorage();\n","import type { ColumnType } from '../types/index.js';\nimport { metadataStorage } from './metadata.js';\n\nexport interface ColumnOptions {\n  name?: string;\n  nullable?: boolean;\n  unique?: boolean;\n  default?: string;\n  references?: {\n    table: string;\n    column: string;\n    onDelete?: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n    onUpdate?: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n  };\n}\n\nexport interface EntityOptions {\n  name?: string;\n}\n\nexport interface IndexOptions {\n  name?: string;\n  columns: string[];\n  unique?: boolean;\n  where?: string;\n}\n\nexport function Entity(tableNameOrOptions?: string | EntityOptions): ClassDecorator {\n  return (target: Function) => {\n    const tableName =\n      typeof tableNameOrOptions === 'string'\n        ? tableNameOrOptions\n        : tableNameOrOptions?.name || toSnakeCase(target.name);\n\n    metadataStorage.registerEntity(target, tableName);\n  };\n}\n\nexport function Column(type: ColumnType, options?: ColumnOptions): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      propertyName,\n      columnName: options?.name || toSnakeCase(propertyName),\n      type,\n      nullable: options?.nullable ?? true,\n      unique: options?.unique ?? false,\n      default: options?.default,\n      references: options?.references,\n      primaryKey: false,\n      tenant: false,\n    });\n  };\n}\n\nexport function PrimaryKey(): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      primaryKey: true,\n      nullable: false,\n    });\n  };\n}\n\nexport function TenantColumn(): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      tenant: true,\n      nullable: false,\n    });\n  };\n}\n\nexport function Unique(): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      unique: true,\n    });\n  };\n}\n\nexport function Nullable(): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      nullable: true,\n    });\n  };\n}\n\nexport function Default(value: string): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      default: value,\n    });\n  };\n}\n\nexport function Index(options: IndexOptions): ClassDecorator {\n  return (target: Function) => {\n    metadataStorage.registerIndex(target, {\n      name: options.name,\n      columns: options.columns,\n      unique: options.unique,\n      where: options.where,\n    });\n  };\n}\n\nexport function OneToMany(target: () => Function, inverseSide: string): PropertyDecorator {\n  return (targetClass: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerRelation(targetClass.constructor, propertyName, {\n      propertyName,\n      type: 'one-to-many',\n      target,\n      inverseSide,\n    });\n  };\n}\n\nexport function ManyToOne(\n  target: () => Function,\n  options?: { foreignKey?: string }\n): PropertyDecorator {\n  return (targetClass: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerRelation(targetClass.constructor, propertyName, {\n      propertyName,\n      type: 'many-to-one',\n      target,\n      foreignKey: options?.foreignKey,\n    });\n  };\n}\n\nexport function OneToOne(\n  target: () => Function,\n  options?: { foreignKey?: string; inverseSide?: string }\n): PropertyDecorator {\n  return (targetClass: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerRelation(targetClass.constructor, propertyName, {\n      propertyName,\n      type: 'one-to-one',\n      target,\n      foreignKey: options?.foreignKey,\n      inverseSide: options?.inverseSide,\n    });\n  };\n}\n\nexport function ManyToMany(\n  target: () => Function,\n  options?: { joinTable?: string; inverseSide?: string }\n): PropertyDecorator {\n  return (targetClass: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerRelation(targetClass.constructor, propertyName, {\n      propertyName,\n      type: 'many-to-many',\n      target,\n      joinTable: options?.joinTable,\n      inverseSide: options?.inverseSide,\n    });\n  };\n}\n\nfunction toSnakeCase(str: string): string {\n  return str\n    .replace(/([A-Z])/g, '_$1')\n    .toLowerCase()\n    .replace(/^_/, '');\n}\n","import { metadataStorage } from './metadata.js';\n\nexport function applyTenantColumns(target: Function): void {\n  metadataStorage.registerColumn(target, 'app_id', {\n    propertyName: 'app_id',\n    columnName: 'app_id',\n    type: 'string',\n    primaryKey: false,\n    nullable: false,\n    unique: false,\n    tenant: true,\n  });\n\n  metadataStorage.registerColumn(target, 'organization_id', {\n    propertyName: 'organization_id',\n    columnName: 'organization_id',\n    type: 'uuid',\n    primaryKey: false,\n    nullable: false,\n    unique: false,\n    tenant: true,\n  });\n}\n\nexport function applyTimestampColumns(target: Function): void {\n  metadataStorage.registerColumn(target, 'created_at', {\n    propertyName: 'created_at',\n    columnName: 'created_at',\n    type: 'datetime',\n    primaryKey: false,\n    nullable: false,\n    unique: false,\n    tenant: false,\n    default: 'NOW()',\n  });\n\n  metadataStorage.registerColumn(target, 'updated_at', {\n    propertyName: 'updated_at',\n    columnName: 'updated_at',\n    type: 'datetime',\n    primaryKey: false,\n    nullable: false,\n    unique: false,\n    tenant: false,\n    default: 'NOW()',\n  });\n}\n\nexport function WithTenantColumns(): ClassDecorator {\n  return (target: Function) => {\n    applyTenantColumns(target);\n  };\n}\n\nexport function WithTimestamps(): ClassDecorator {\n  return (target: Function) => {\n    applyTimestampColumns(target);\n  };\n}\n\nexport abstract class TenantEntity {\n  app_id!: string;\n  organization_id!: string;\n}\n\nexport abstract class TimestampedEntity {\n  created_at!: Date;\n  updated_at!: Date;\n}\n\nexport abstract class TenantTimestampedEntity {\n  app_id!: string;\n  organization_id!: string;\n  created_at!: Date;\n  updated_at!: Date;\n}\n","import type {\n  ColumnDefinition,\n  IndexDefinition,\n  SchemaDefinition,\n  TableDefinition,\n} from '../types/index.js';\nimport { type EntityConstructor, type EntityMetadata, metadataStorage } from './metadata.js';\n\nexport interface ExtractSchemaOptions {\n  entities: EntityConstructor[];\n}\n\nexport function extractSchemaFromEntities(entities: EntityConstructor[]): SchemaDefinition {\n  const tables: Record<string, TableDefinition> = {};\n\n  for (const entity of entities) {\n    const metadata = metadataStorage.getEntityMetadata(entity);\n    if (!metadata) {\n      throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n    }\n\n    tables[metadata.tableName] = extractTableDefinition(metadata);\n  }\n\n  return { tables };\n}\n\nexport function extractSchemaFromEntity(entity: EntityConstructor): SchemaDefinition {\n  return extractSchemaFromEntities([entity]);\n}\n\nexport function extractTableDefinition(metadata: EntityMetadata): TableDefinition {\n  const columns: Record<string, ColumnDefinition> = {};\n  const primaryKeyColumns: string[] = [];\n\n  for (const [, columnMeta] of metadata.columns) {\n    const columnDef: ColumnDefinition = {\n      type: columnMeta.type,\n      nullable: columnMeta.nullable,\n    };\n\n    if (columnMeta.primaryKey) {\n      columnDef.primaryKey = true;\n      primaryKeyColumns.push(columnMeta.columnName);\n    }\n\n    if (columnMeta.unique) {\n      columnDef.unique = true;\n    }\n\n    if (columnMeta.default) {\n      columnDef.default = columnMeta.default;\n    }\n\n    if (columnMeta.tenant) {\n      columnDef.tenant = true;\n    }\n\n    if (columnMeta.references) {\n      columnDef.references = columnMeta.references;\n    }\n\n    columns[columnMeta.columnName] = columnDef;\n  }\n\n  const indexes: IndexDefinition[] = metadata.indexes.map((idx) => ({\n    name: idx.name,\n    columns: idx.columns,\n    unique: idx.unique,\n    where: idx.where,\n  }));\n\n  const tableDef: TableDefinition = {\n    columns,\n  };\n\n  if (indexes.length > 0) {\n    tableDef.indexes = indexes;\n  }\n\n  if (primaryKeyColumns.length > 1) {\n    tableDef.primaryKey = primaryKeyColumns;\n  }\n\n  return tableDef;\n}\n\nexport function getEntityTableName(entity: EntityConstructor): string {\n  const metadata = metadataStorage.getEntityMetadata(entity);\n  if (!metadata) {\n    throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n  }\n  return metadata.tableName;\n}\n\nexport function getEntityColumns(entity: EntityConstructor): Map<string, string> {\n  const metadata = metadataStorage.getEntityMetadata(entity);\n  if (!metadata) {\n    throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n  }\n\n  const columnMap = new Map<string, string>();\n  for (const [propertyName, columnMeta] of metadata.columns) {\n    columnMap.set(propertyName, columnMeta.columnName);\n  }\n  return columnMap;\n}\n\nexport function propertyToColumn(entity: EntityConstructor, propertyName: string): string {\n  const metadata = metadataStorage.getEntityMetadata(entity);\n  if (!metadata) {\n    throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n  }\n\n  const column = metadata.columns.get(propertyName);\n  if (!column) {\n    throw new Error(`Property ${propertyName} not found on entity ${entity.name}`);\n  }\n\n  return column.columnName;\n}\n\nexport function columnToProperty(entity: EntityConstructor, columnName: string): string {\n  const metadata = metadataStorage.getEntityMetadata(entity);\n  if (!metadata) {\n    throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n  }\n\n  for (const [propertyName, columnMeta] of metadata.columns) {\n    if (columnMeta.columnName === columnName) {\n      return propertyName;\n    }\n  }\n\n  throw new Error(`Column ${columnName} not found on entity ${entity.name}`);\n}\n","import type { DbClient, TransactionContext } from '../client.js';\nimport type { Operator, TenantContext } from '../types/index.js';\nimport type { EntityConstructor } from './metadata.js';\nimport { getEntityColumns, getEntityTableName } from './schema-extractor.js';\n\nexport type WhereCondition<T> = Partial<T> | [keyof T, Operator, unknown][];\n\nexport interface FindOptions<T> {\n  where?: WhereCondition<T>;\n  orderBy?: { [K in keyof T]?: 'asc' | 'desc' };\n  limit?: number;\n  offset?: number;\n  select?: (keyof T)[];\n}\n\nexport interface FindOneOptions<T> {\n  where?: WhereCondition<T>;\n  select?: (keyof T)[];\n}\n\nexport class Repository<T> {\n  private db: DbClient | TransactionContext;\n  private tenantContext?: TenantContext;\n  private tableName: string;\n  private columnMap: Map<string, string>;\n\n  constructor(\n    entity: EntityConstructor<T>,\n    db: DbClient | TransactionContext,\n    tenantContext?: TenantContext\n  ) {\n    this.db = db;\n    this.tenantContext = tenantContext;\n    this.tableName = getEntityTableName(entity);\n    this.columnMap = getEntityColumns(entity);\n  }\n\n  async find(options: FindOptions<T> = {}): Promise<T[]> {\n    const builder = this.createTableBuilder();\n\n    let selectBuilder = builder.select(\n      ...(options.select ? options.select.map((p) => this.toColumn(p as string)) : ['*'])\n    );\n\n    if (options.where) {\n      selectBuilder = this.applyWhere(selectBuilder, options.where);\n    }\n\n    if (options.orderBy) {\n      for (const [property, direction] of Object.entries(options.orderBy)) {\n        selectBuilder = selectBuilder.orderBy(this.toColumn(property), direction as 'asc' | 'desc');\n      }\n    }\n\n    if (options.limit !== undefined) {\n      selectBuilder = selectBuilder.limit(options.limit);\n    }\n\n    if (options.offset !== undefined) {\n      selectBuilder = selectBuilder.offset(options.offset);\n    }\n\n    const rows = await selectBuilder.execute();\n    return rows.map((row: Record<string, unknown>) => this.rowToEntity(row));\n  }\n\n  async findOne(options: FindOneOptions<T> = {}): Promise<T | null> {\n    const results = await this.find({ ...options, limit: 1 });\n    return results[0] || null;\n  }\n\n  async findById(id: string | number): Promise<T | null> {\n    return this.findOne({ where: { id } as unknown as WhereCondition<T> });\n  }\n\n  async create(data: Partial<T>): Promise<T> {\n    const builder = this.createTableBuilder();\n    const columnData = this.entityToRow(data);\n\n    const rows = await builder.insert().values(columnData).returning('*').execute();\n\n    if (rows.length === 0) {\n      throw new Error('Insert did not return any rows');\n    }\n\n    return this.rowToEntity(rows[0] as Record<string, unknown>);\n  }\n\n  async createMany(data: Partial<T>[]): Promise<T[]> {\n    const results: T[] = [];\n    for (const item of data) {\n      const created = await this.create(item);\n      results.push(created);\n    }\n    return results;\n  }\n\n  async update(where: WhereCondition<T>, data: Partial<T>): Promise<T[]> {\n    const builder = this.createTableBuilder();\n    const columnData = this.entityToRow(data);\n\n    let updateBuilder = builder.update().set(columnData);\n    updateBuilder = this.applyWhereToUpdate(updateBuilder, where);\n\n    const rows = await updateBuilder.returning('*').execute();\n    return rows.map((row: Record<string, unknown>) => this.rowToEntity(row));\n  }\n\n  async updateById(id: string | number, data: Partial<T>): Promise<T | null> {\n    const results = await this.update({ id } as unknown as WhereCondition<T>, data);\n    return results[0] || null;\n  }\n\n  async delete(where: WhereCondition<T>): Promise<number> {\n    const builder = this.createTableBuilder();\n    let deleteBuilder = builder.delete();\n    deleteBuilder = this.applyWhereToDelete(deleteBuilder, where);\n\n    const rows = await deleteBuilder.execute();\n    return rows.length;\n  }\n\n  async deleteById(id: string | number): Promise<boolean> {\n    const count = await this.delete({ id } as unknown as WhereCondition<T>);\n    return count > 0;\n  }\n\n  async count(where?: WhereCondition<T>): Promise<number> {\n    const builder = this.createTableBuilder();\n    const selectBuilder = builder.select();\n\n    if (where) {\n      this.applyWhere(selectBuilder, where);\n    }\n\n    const countResult = await selectBuilder.count();\n    return countResult;\n  }\n\n  async exists(where: WhereCondition<T>): Promise<boolean> {\n    const count = await this.count(where);\n    return count > 0;\n  }\n\n  private isDbClient(db: DbClient | TransactionContext): db is DbClient {\n    return 'tableWithoutTenant' in db;\n  }\n\n  private createTableBuilder() {\n    if (this.isDbClient(this.db)) {\n      if (!this.tenantContext) {\n        throw new Error(\n          'TenantContext is required when using Repository with DbClient. ' +\n            'Either provide tenantContext or use Repository within a transaction.'\n        );\n      }\n      return this.db.table(this.tableName, this.tenantContext);\n    }\n    return this.db.table(this.tableName);\n  }\n\n  private toColumn(propertyName: string): string {\n    return this.columnMap.get(propertyName) || propertyName;\n  }\n\n  private applyWhere<B extends { where: (col: string, op: Operator, val: unknown) => B }>(\n    builder: B,\n    where: WhereCondition<T>\n  ): B {\n    if (Array.isArray(where)) {\n      for (const [property, op, value] of where) {\n        builder = builder.where(this.toColumn(property as string), op, value);\n      }\n    } else {\n      for (const [property, value] of Object.entries(where)) {\n        if (value !== undefined) {\n          builder = builder.where(this.toColumn(property), '=', value);\n        }\n      }\n    }\n    return builder;\n  }\n\n  private applyWhereToUpdate<B extends { where: (col: string, op: Operator, val: unknown) => B }>(\n    builder: B,\n    where: WhereCondition<T>\n  ): B {\n    return this.applyWhere(builder, where);\n  }\n\n  private applyWhereToDelete<B extends { where: (col: string, op: Operator, val: unknown) => B }>(\n    builder: B,\n    where: WhereCondition<T>\n  ): B {\n    return this.applyWhere(builder, where);\n  }\n\n  private entityToRow(entity: Partial<T>): Record<string, unknown> {\n    const row: Record<string, unknown> = {};\n    for (const [property, value] of Object.entries(entity)) {\n      if (value !== undefined) {\n        const columnName = this.toColumn(property);\n        row[columnName] = value;\n      }\n    }\n    return row;\n  }\n\n  private rowToEntity(row: Record<string, unknown>): T {\n    const entity: Record<string, unknown> = {};\n    for (const [property, columnName] of this.columnMap) {\n      if (columnName in row) {\n        entity[property] = row[columnName];\n      }\n    }\n    for (const [key, value] of Object.entries(row)) {\n      if (!(key in entity)) {\n        entity[key] = value;\n      }\n    }\n    return entity as T;\n  }\n}\n\nexport function createRepository<T>(\n  entity: EntityConstructor<T>,\n  db: DbClient | TransactionContext,\n  tenantContext?: TenantContext\n): Repository<T> {\n  return new Repository(entity, db, tenantContext);\n}\n","export * from './types/index.js';\n\nexport * from './orm/index.js';\n\nexport { createDriver, detectDialect } from './driver/index.js';\nexport type {\n  Driver,\n  DriverConfig,\n  TransactionClient,\n  CreateDriverOptions,\n} from './driver/index.js';\n\nexport { SQLCompiler, createCompiler } from './compiler/index.js';\nexport type { CompilerOptions } from './compiler/index.js';\n\nexport {\n  SelectBuilder,\n  InsertBuilder,\n  UpdateBuilder,\n  DeleteBuilder,\n  TableBuilder,\n} from './query-builder/index.js';\n\nexport {\n  MigrationRunner,\n  createMigrationRunner,\n} from './migrations/index.js';\nexport type { MigrationRunnerOptions, MigrationRunOptions } from './migrations/index.js';\nexport { getDialect, postgresDialect, mysqlDialect, sqliteDialect } from './migrations/index.js';\nexport type { Dialect } from './migrations/index.js';\n\nexport {\n  ModuleRegistry,\n  createModuleRegistry,\n  MigrationCollector,\n  createMigrationCollector,\n} from './modules/index.js';\nexport type {\n  ModuleRegistryOptions,\n  MigrationCollectorOptions,\n  ModuleDefinition,\n  ModuleMigrationSource,\n} from './modules/index.js';\n\nexport { SchemaRegistry, createSchemaRegistry } from './schema/index.js';\nexport type { SchemaRegistryOptions, RegisterSchemaOptions } from './schema/index.js';\n\nexport { generateTypes, generateSchemaFromDefinition } from './types/generator.js';\nexport type { TypeGeneratorOptions } from './types/generator.js';\n\nexport { DbClient, TransactionContext, createDbClient } from './client.js';\nexport type { DbClientOptions } from './client.js';\n\nexport {\n  TenantContextError,\n  validateTenantContext,\n  validateTenantContextOrWarn,\n} from './utils/tenant-validation.js';\n\nexport {\n  BranchManager,\n  createBranchManager,\n  SchemaDiffer,\n  MigrationMerger,\n  ConnectionManager,\n  createConnectionManager,\n  CleanupScheduler,\n  createCleanupScheduler,\n} from './branch/index.js';\nexport type {\n  Branch,\n  BranchStatus,\n  CreateBranchOptions,\n  SwitchBranchResult,\n  SchemaDiff,\n  TableDiff,\n  ColumnDiff,\n  IndexDiff,\n  ConstraintDiff,\n  Conflict,\n  ConflictResolution,\n  MergeOptions,\n  MergeResult,\n  ListBranchesFilter,\n  CleanupOptions,\n  CleanupResult,\n  BranchManagerOptions,\n  ConnectionManagerOptions,\n  BranchConnection,\n  CleanupSchedulerOptions,\n  CleanupJob,\n  MigrationMergerOptions,\n  MigrationRecord,\n} from './branch/index.js';\n\nexport async function createDb(options: {\n  connectionString: string;\n  migrationsPath?: string;\n  tenantColumns?: { appId: string; organizationId: string };\n  strictTenantMode?: boolean;\n}) {\n  const { createDriver } = await import('./driver/index.js');\n  const { createDbClient } = await import('./client.js');\n\n  const driver = await createDriver({ connectionString: options.connectionString });\n  return createDbClient(driver, {\n    migrationsPath: options.migrationsPath,\n    tenantColumns: options.tenantColumns,\n    strictTenantMode: options.strictTenantMode,\n  });\n}\n","export { MigrationRunner, createMigrationRunner } from './runner.js';\nexport type { MigrationRunnerOptions, MigrationRunOptions } from './runner.js';\nexport { getDialect, postgresDialect, mysqlDialect, sqliteDialect } from './dialects/index.js';\nexport type { Dialect } from './dialects/types.js';\n","import type { Driver } from '../driver/types.js';\nimport { getDialect } from '../migrations/dialects/index.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { ModuleDefinition } from './types.js';\n\nexport interface ModuleRegistryOptions {\n  tableName?: string;\n}\n\nexport class ModuleRegistry {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: ModuleRegistryOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_module_registry';\n  }\n\n  async ensureTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          name TEXT PRIMARY KEY,\n          display_name TEXT NOT NULL,\n          description TEXT,\n          version TEXT NOT NULL,\n          dependencies TEXT[] DEFAULT '{}',\n          migration_prefix TEXT NOT NULL UNIQUE,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW()\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            name VARCHAR(255) PRIMARY KEY,\n            display_name VARCHAR(255) NOT NULL,\n            description TEXT,\n            version VARCHAR(50) NOT NULL,\n            dependencies JSON DEFAULT ('[]'),\n            migration_prefix VARCHAR(255) NOT NULL UNIQUE,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            name TEXT PRIMARY KEY,\n            display_name TEXT NOT NULL,\n            description TEXT,\n            version TEXT NOT NULL,\n            dependencies TEXT DEFAULT '[]',\n            migration_prefix TEXT NOT NULL UNIQUE,\n            created_at TEXT DEFAULT (datetime('now')),\n            updated_at TEXT DEFAULT (datetime('now'))\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n  }\n\n  async register(module: ModuleDefinition): Promise<void> {\n    await this.ensureTable();\n\n    const dependencies = module.dependencies ?? [];\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES ($1, $2, $3, $4, $5, $6)\n        ON CONFLICT (name) DO UPDATE SET\n          display_name = EXCLUDED.display_name,\n          description = EXCLUDED.description,\n          version = EXCLUDED.version,\n          dependencies = EXCLUDED.dependencies,\n          migration_prefix = EXCLUDED.migration_prefix,\n          updated_at = NOW()\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          dependencies,\n          module.migrationPrefix,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES (?, ?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          display_name = VALUES(display_name),\n          description = VALUES(description),\n          version = VALUES(version),\n          dependencies = VALUES(dependencies),\n          migration_prefix = VALUES(migration_prefix)\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          JSON.stringify(dependencies),\n          module.migrationPrefix,\n        ]\n      );\n    } else {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES (?, ?, ?, ?, ?, ?)\n        ON CONFLICT (name) DO UPDATE SET\n          display_name = excluded.display_name,\n          description = excluded.description,\n          version = excluded.version,\n          dependencies = excluded.dependencies,\n          migration_prefix = excluded.migration_prefix,\n          updated_at = datetime('now')\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          JSON.stringify(dependencies),\n          module.migrationPrefix,\n        ]\n      );\n    }\n  }\n\n  async get(name: string): Promise<ModuleDefinition | null> {\n    await this.ensureTable();\n\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM \"${this.tableName}\"\n        WHERE name = $1\n      `;\n      params = [name];\n    } else {\n      sql = `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE name = ?\n      `;\n      params = [name];\n    }\n\n    const result = await this.driver.query<{\n      name: string;\n      display_name: string;\n      description: string | null;\n      version: string;\n      dependencies: string[] | string;\n      migration_prefix: string;\n    }>(sql, params);\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0];\n    return {\n      name: row.name,\n      displayName: row.display_name,\n      description: row.description ?? undefined,\n      version: row.version,\n      dependencies:\n        typeof row.dependencies === 'string' ? JSON.parse(row.dependencies) : row.dependencies,\n      migrationPrefix: row.migration_prefix,\n    };\n  }\n\n  async list(): Promise<ModuleDefinition[]> {\n    await this.ensureTable();\n\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM \"${this.tableName}\"\n        ORDER BY name ASC\n      `\n        : `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        ORDER BY name ASC\n      `;\n\n    const result = await this.driver.query<{\n      name: string;\n      display_name: string;\n      description: string | null;\n      version: string;\n      dependencies: string[] | string;\n      migration_prefix: string;\n    }>(sql);\n\n    return result.rows.map((row) => ({\n      name: row.name,\n      displayName: row.display_name,\n      description: row.description ?? undefined,\n      version: row.version,\n      dependencies:\n        typeof row.dependencies === 'string' ? JSON.parse(row.dependencies) : row.dependencies,\n      migrationPrefix: row.migration_prefix,\n    }));\n  }\n\n  async unregister(name: string): Promise<void> {\n    await this.ensureTable();\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(`DELETE FROM \"${this.tableName}\" WHERE name = $1`, [name]);\n    } else {\n      await this.driver.execute(\n        `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE name = ?`,\n        [name]\n      );\n    }\n  }\n}\n\nexport function createModuleRegistry(\n  driver: Driver,\n  options: ModuleRegistryOptions = {}\n): ModuleRegistry {\n  return new ModuleRegistry(driver, options);\n}\n","import { readFile, readdir, stat } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { MigrationFile } from '../types/index.js';\nimport type { ModuleMigrationSource } from './types.js';\n\nexport interface MigrationCollectorOptions {\n  scope?: 'core' | 'template';\n}\n\nexport class MigrationCollector {\n  async discoverFromDirectory(basePath: string): Promise<ModuleMigrationSource[]> {\n    const sources: ModuleMigrationSource[] = [];\n\n    try {\n      const entries = await readdir(basePath);\n\n      for (const entry of entries) {\n        const entryPath = join(basePath, entry);\n        const entryStat = await stat(entryPath);\n\n        if (entryStat.isDirectory()) {\n          sources.push({\n            moduleName: entry,\n            migrationsPath: entryPath,\n          });\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n\n    return sources.sort((a, b) => a.moduleName.localeCompare(b.moduleName));\n  }\n\n  async collect(\n    sources: ModuleMigrationSource[],\n    options: MigrationCollectorOptions = {}\n  ): Promise<MigrationFile[]> {\n    const migrations: MigrationFile[] = [];\n\n    for (const source of sources) {\n      const sourceMigrations = await this.loadMigrationsFromSource(source, options);\n      migrations.push(...sourceMigrations);\n    }\n\n    return this.orderMigrations(migrations);\n  }\n\n  private async loadMigrationsFromSource(\n    source: ModuleMigrationSource,\n    options: MigrationCollectorOptions = {}\n  ): Promise<MigrationFile[]> {\n    const scope = options.scope ?? 'core';\n    const migrations: MigrationFile[] = [];\n\n    try {\n      const files = await readdir(source.migrationsPath);\n      const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();\n\n      for (const file of sqlFiles) {\n        const content = await readFile(join(source.migrationsPath, file), 'utf-8');\n        const parsed = this.parseMigrationFile(file, content, scope, source.moduleName);\n        if (parsed) {\n          migrations.push(parsed);\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n\n    return migrations;\n  }\n\n  private parseMigrationFile(\n    filename: string,\n    content: string,\n    scope: 'core' | 'template',\n    moduleName: string\n  ): MigrationFile | null {\n    const match = filename.match(/^(\\d+)__(.+)\\.sql$/);\n    if (!match) return null;\n\n    const [, versionStr, name] = match;\n    const version = Number.parseInt(versionStr, 10);\n\n    const upMatch = content.match(/--\\s*up\\s*\\n([\\s\\S]*?)(?=--\\s*down|$)/i);\n    const downMatch = content.match(/--\\s*down\\s*\\n([\\s\\S]*?)$/i);\n\n    const up = upMatch ? this.splitSqlStatements(upMatch[1]) : [];\n    const down = downMatch ? this.splitSqlStatements(downMatch[1]) : [];\n\n    if (!up.length) return null;\n\n    return {\n      version,\n      name,\n      up,\n      down,\n      scope,\n      moduleName,\n    };\n  }\n\n  private orderMigrations(migrations: MigrationFile[]): MigrationFile[] {\n    return migrations.sort((a, b) => {\n      if (a.version !== b.version) {\n        return a.version - b.version;\n      }\n      const moduleA = a.moduleName ?? '';\n      const moduleB = b.moduleName ?? '';\n      return moduleA.localeCompare(moduleB);\n    });\n  }\n\n  private splitSqlStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inSingleQuote) {\n        current += char;\n        if (char === \"'\" && next !== \"'\") {\n          inSingleQuote = false;\n        } else if (char === \"'\" && next === \"'\") {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (inDoubleQuote) {\n        current += char;\n        if (char === '\"' && next !== '\"') {\n          inDoubleQuote = false;\n        } else if (char === '\"' && next === '\"') {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\") {\n        inSingleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '\"') {\n        inDoubleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n\nexport function createMigrationCollector(): MigrationCollector {\n  return new MigrationCollector();\n}\n","export { SchemaRegistry, createSchemaRegistry } from './registry.js';\nexport type { SchemaRegistryOptions, RegisterSchemaOptions, SchemaRecord } from './registry.js';\n","import type { ColumnType, SchemaDefinition } from './index.js';\n\nexport interface TypeGeneratorOptions {\n  includeInsertTypes?: boolean;\n  includeUpdateTypes?: boolean;\n  omitTenantColumns?: boolean;\n}\n\nfunction pascalCase(str: string): string {\n  return str\n    .split(/[-_]/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\nfunction pgTypeToTs(type: ColumnType): string {\n  const map: Record<ColumnType, string> = {\n    uuid: 'string',\n    string: 'string',\n    text: 'string',\n    integer: 'number',\n    bigint: 'number',\n    float: 'number',\n    decimal: 'number',\n    boolean: 'boolean',\n    datetime: 'Date',\n    date: 'Date',\n    time: 'string',\n    json: 'Record<string, unknown>',\n    binary: 'Buffer',\n  };\n  return map[type] || 'unknown';\n}\n\nexport function generateTypes(\n  schemas: Map<string, SchemaDefinition>,\n  options: TypeGeneratorOptions = {}\n): string {\n  const {\n    includeInsertTypes = true,\n    includeUpdateTypes = true,\n    omitTenantColumns = true,\n  } = options;\n\n  const lines: string[] = [\n    '// Auto-generated by @launchpad/db-engine',\n    '// Do not edit this file manually',\n    '',\n  ];\n\n  for (const [schemaName, schema] of schemas) {\n    const namespace = pascalCase(schemaName);\n    lines.push(`export namespace ${namespace} {`);\n\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      const typeName = pascalCase(tableName);\n\n      lines.push(`  /** Row type for ${tableName} table */`);\n      lines.push(`  export interface ${typeName} {`);\n\n      for (const [colName, col] of Object.entries(table.columns)) {\n        const tsType = pgTypeToTs(col.type);\n        const nullable = col.nullable ? ' | null' : '';\n        lines.push(`    ${colName}: ${tsType}${nullable};`);\n      }\n\n      lines.push('  }');\n      lines.push('');\n\n      if (includeInsertTypes) {\n        lines.push(`  /** Insert type for ${tableName} table */`);\n        lines.push(`  export interface ${typeName}Insert {`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (colName === 'id' && col.default) continue;\n          if (colName === 'created_at' && col.default) continue;\n          if (colName === 'updated_at' && col.default) continue;\n\n          if (omitTenantColumns && col.tenant) continue;\n\n          const tsType = pgTypeToTs(col.type);\n          const optional = col.nullable || col.default ? '?' : '';\n          lines.push(`    ${colName}${optional}: ${tsType};`);\n        }\n\n        lines.push('  }');\n        lines.push('');\n      }\n\n      if (includeUpdateTypes) {\n        lines.push(`  /** Update type for ${tableName} table */`);\n        lines.push(`  export interface ${typeName}Update {`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (colName === 'id') continue;\n          if (colName === 'created_at') continue;\n\n          if (omitTenantColumns && col.tenant) continue;\n\n          const tsType = pgTypeToTs(col.type);\n          lines.push(`    ${colName}?: ${tsType} | null;`);\n        }\n\n        lines.push('  }');\n        lines.push('');\n      }\n    }\n\n    const tableNames = Object.keys(schema.tables)\n      .map((t) => `'${t}'`)\n      .join(' | ');\n    lines.push(`  export type TableName = ${tableNames};`);\n    lines.push('');\n\n    lines.push('  export interface Tables {');\n    for (const tableName of Object.keys(schema.tables)) {\n      const typeName = pascalCase(tableName);\n      lines.push(`    ${tableName}: ${typeName};`);\n    }\n    lines.push('  }');\n\n    lines.push('}');\n    lines.push('');\n  }\n\n  lines.push('export type AllSchemas = {');\n  for (const schemaName of schemas.keys()) {\n    const namespace = pascalCase(schemaName);\n    lines.push(`  ${schemaName}: typeof ${namespace};`);\n  }\n  lines.push('};');\n\n  return lines.join('\\n');\n}\n\nexport function generateSchemaFromDefinition(schema: SchemaDefinition): string {\n  const lines: string[] = [\n    \"import type { SchemaDefinition } from '@launchpad/db-engine';\",\n    '',\n    'export const schema: SchemaDefinition = {',\n    '  tables: {',\n  ];\n\n  for (const [tableName, table] of Object.entries(schema.tables)) {\n    lines.push(`    ${tableName}: {`);\n    lines.push('      columns: {');\n\n    for (const [colName, col] of Object.entries(table.columns)) {\n      const colDef: string[] = [];\n      colDef.push(`type: '${col.type}'`);\n\n      if (col.primaryKey) colDef.push('primaryKey: true');\n      if (col.nullable) colDef.push('nullable: true');\n      if (col.unique) colDef.push('unique: true');\n      if (col.default) colDef.push(`default: '${col.default}'`);\n      if (col.tenant) colDef.push('tenant: true');\n\n      if (col.references) {\n        colDef.push(\n          `references: { table: '${col.references.table}', column: '${col.references.column}'${col.references.onDelete ? `, onDelete: '${col.references.onDelete}'` : ''} }`\n        );\n      }\n\n      lines.push(`        ${colName}: { ${colDef.join(', ')} },`);\n    }\n\n    lines.push('      },');\n\n    if (table.indexes?.length) {\n      lines.push('      indexes: [');\n      for (const index of table.indexes) {\n        const indexDef: string[] = [];\n        indexDef.push(`columns: [${index.columns.map((c) => `'${c}'`).join(', ')}]`);\n        if (index.name) indexDef.push(`name: '${index.name}'`);\n        if (index.unique) indexDef.push('unique: true');\n        if (index.where) indexDef.push(`where: '${index.where}'`);\n        lines.push(`        { ${indexDef.join(', ')} },`);\n      }\n      lines.push('      ],');\n    }\n\n    lines.push('    },');\n  }\n\n  lines.push('  },');\n  lines.push('};');\n\n  return lines.join('\\n');\n}\n","import type { Driver } from '../driver/types.js';\nimport type {\n  ColumnDiff,\n  Conflict,\n  ConstraintDiff,\n  IndexDiff,\n  SchemaColumnInfo,\n  SchemaConstraintInfo,\n  SchemaDiff,\n  SchemaIndexInfo,\n  SchemaInfo,\n  SchemaTableInfo,\n  TableDiff,\n} from './types.js';\n\nexport class SchemaDiffer {\n  constructor(private driver: Driver) {}\n\n  async diff(sourceSchema: string, targetSchema: string): Promise<SchemaDiff> {\n    const [sourceInfo, targetInfo] = await Promise.all([\n      this.getSchemaInfo(sourceSchema),\n      this.getSchemaInfo(targetSchema),\n    ]);\n\n    const tables = this.diffTables(sourceInfo, targetInfo);\n    const columns = this.diffColumns(sourceInfo, targetInfo);\n    const indexes = this.diffIndexes(sourceInfo, targetInfo);\n    const constraints = this.diffConstraints(sourceInfo, targetInfo);\n    const conflicts = this.detectConflicts(columns, constraints);\n\n    const hasChanges =\n      tables.length > 0 || columns.length > 0 || indexes.length > 0 || constraints.length > 0;\n\n    return {\n      source: sourceSchema,\n      target: targetSchema,\n      generatedAt: new Date(),\n      hasChanges,\n      canAutoMerge: conflicts.length === 0,\n      tables,\n      columns,\n      indexes,\n      constraints,\n      conflicts,\n      forwardSql: this.generateMigrationSql(\n        sourceSchema,\n        targetSchema,\n        tables,\n        columns,\n        indexes,\n        constraints,\n        'forward'\n      ),\n      reverseSql: this.generateMigrationSql(\n        targetSchema,\n        sourceSchema,\n        tables,\n        columns,\n        indexes,\n        constraints,\n        'reverse'\n      ),\n    };\n  }\n\n  private async getSchemaInfo(schemaName: string): Promise<SchemaInfo> {\n    const [tables, columns, indexes, constraints] = await Promise.all([\n      this.driver.query<SchemaTableInfo>(\n        `\n        SELECT table_name, table_type\n        FROM information_schema.tables\n        WHERE table_schema = $1 AND table_name NOT LIKE 'lp_%'\n        ORDER BY table_name\n      `,\n        [schemaName]\n      ),\n\n      this.driver.query<SchemaColumnInfo>(\n        `\n        SELECT\n          table_name, column_name, data_type,\n          character_maximum_length, numeric_precision, numeric_scale,\n          is_nullable, column_default, udt_name, ordinal_position\n        FROM information_schema.columns\n        WHERE table_schema = $1 AND table_name NOT LIKE 'lp_%'\n        ORDER BY table_name, ordinal_position\n      `,\n        [schemaName]\n      ),\n\n      this.driver.query<SchemaIndexInfo>(\n        `\n        SELECT\n          schemaname, tablename, indexname, indexdef\n        FROM pg_indexes\n        WHERE schemaname = $1 AND tablename NOT LIKE 'lp_%'\n        ORDER BY tablename, indexname\n      `,\n        [schemaName]\n      ),\n\n      this.driver.query<SchemaConstraintInfo>(\n        `\n        SELECT\n          tc.table_name, tc.constraint_name, tc.constraint_type,\n          kcu.column_name, ccu.table_name AS foreign_table_name,\n          ccu.column_name AS foreign_column_name\n        FROM information_schema.table_constraints tc\n        LEFT JOIN information_schema.key_column_usage kcu\n          ON tc.constraint_name = kcu.constraint_name\n          AND tc.table_schema = kcu.table_schema\n        LEFT JOIN information_schema.constraint_column_usage ccu\n          ON tc.constraint_name = ccu.constraint_name\n          AND tc.table_schema = ccu.table_schema\n        WHERE tc.table_schema = $1 AND tc.table_name NOT LIKE 'lp_%'\n        ORDER BY tc.table_name, tc.constraint_name\n      `,\n        [schemaName]\n      ),\n    ]);\n\n    return {\n      tables: tables.rows,\n      columns: columns.rows,\n      indexes: indexes.rows,\n      constraints: constraints.rows,\n    };\n  }\n\n  private diffTables(source: SchemaInfo, target: SchemaInfo): TableDiff[] {\n    const diffs: TableDiff[] = [];\n    const sourceNames = new Set(source.tables.map((t) => t.table_name));\n    const targetNames = new Set(target.tables.map((t) => t.table_name));\n\n    for (const table of source.tables) {\n      if (!targetNames.has(table.table_name)) {\n        diffs.push({\n          name: table.table_name,\n          action: 'added',\n          sourceDefinition: this.getTableDefinition(table.table_name, source),\n        });\n      }\n    }\n\n    for (const table of target.tables) {\n      if (!sourceNames.has(table.table_name)) {\n        diffs.push({\n          name: table.table_name,\n          action: 'removed',\n          targetDefinition: this.getTableDefinition(table.table_name, target),\n        });\n      }\n    }\n\n    return diffs;\n  }\n\n  private diffColumns(source: SchemaInfo, target: SchemaInfo): ColumnDiff[] {\n    const diffs: ColumnDiff[] = [];\n    const sourceTableNames = new Set(source.tables.map((t) => t.table_name));\n    const targetTableNames = new Set(target.tables.map((t) => t.table_name));\n    const commonTables = [...sourceTableNames].filter((t) => targetTableNames.has(t));\n\n    for (const tableName of commonTables) {\n      const sourceCols = source.columns.filter((c) => c.table_name === tableName);\n      const targetCols = target.columns.filter((c) => c.table_name === tableName);\n      const sourceColMap = new Map(sourceCols.map((c) => [c.column_name, c]));\n      const targetColMap = new Map(targetCols.map((c) => [c.column_name, c]));\n\n      diffs.push(...this.findAddedColumns(tableName, sourceCols, targetColMap));\n      diffs.push(...this.findRemovedColumns(tableName, targetCols, sourceColMap));\n      diffs.push(...this.findModifiedColumns(tableName, sourceCols, targetColMap));\n    }\n\n    return diffs;\n  }\n\n  private findAddedColumns(\n    tableName: string,\n    sourceCols: SchemaColumnInfo[],\n    targetColMap: Map<string, SchemaColumnInfo>\n  ): ColumnDiff[] {\n    return sourceCols\n      .filter((col) => !targetColMap.has(col.column_name))\n      .map((col) => ({\n        tableName,\n        columnName: col.column_name,\n        action: 'added' as const,\n        sourceType: this.getColumnType(col),\n        sourceNullable: col.is_nullable === 'YES',\n        sourceDefault: col.column_default ?? undefined,\n        isBreaking: false,\n      }));\n  }\n\n  private findRemovedColumns(\n    tableName: string,\n    targetCols: SchemaColumnInfo[],\n    sourceColMap: Map<string, SchemaColumnInfo>\n  ): ColumnDiff[] {\n    return targetCols\n      .filter((col) => !sourceColMap.has(col.column_name))\n      .map((col) => ({\n        tableName,\n        columnName: col.column_name,\n        action: 'removed' as const,\n        targetType: this.getColumnType(col),\n        targetNullable: col.is_nullable === 'YES',\n        targetDefault: col.column_default ?? undefined,\n        isBreaking: true,\n      }));\n  }\n\n  private findModifiedColumns(\n    tableName: string,\n    sourceCols: SchemaColumnInfo[],\n    targetColMap: Map<string, SchemaColumnInfo>\n  ): ColumnDiff[] {\n    const diffs: ColumnDiff[] = [];\n    for (const col of sourceCols) {\n      const targetCol = targetColMap.get(col.column_name);\n      if (targetCol && this.hasColumnChanges(col, targetCol)) {\n        const sourceType = this.getColumnType(col);\n        const targetType = this.getColumnType(targetCol);\n        diffs.push({\n          tableName,\n          columnName: col.column_name,\n          action: 'modified',\n          sourceType,\n          targetType,\n          sourceNullable: col.is_nullable === 'YES',\n          targetNullable: targetCol.is_nullable === 'YES',\n          sourceDefault: col.column_default ?? undefined,\n          targetDefault: targetCol.column_default ?? undefined,\n          isBreaking: this.isBreakingTypeChange(sourceType, targetType),\n        });\n      }\n    }\n    return diffs;\n  }\n\n  private diffIndexes(source: SchemaInfo, target: SchemaInfo): IndexDiff[] {\n    const diffs: IndexDiff[] = [];\n\n    const sourceMap = new Map(source.indexes.map((i) => [`${i.tablename}.${i.indexname}`, i]));\n    const targetMap = new Map(target.indexes.map((i) => [`${i.tablename}.${i.indexname}`, i]));\n\n    for (const [key, idx] of sourceMap) {\n      if (!targetMap.has(key)) {\n        diffs.push({\n          tableName: idx.tablename,\n          indexName: idx.indexname,\n          action: 'added',\n          sourceDefinition: idx.indexdef,\n        });\n      }\n    }\n\n    for (const [key, idx] of targetMap) {\n      if (!sourceMap.has(key)) {\n        diffs.push({\n          tableName: idx.tablename,\n          indexName: idx.indexname,\n          action: 'removed',\n          targetDefinition: idx.indexdef,\n        });\n      }\n    }\n\n    for (const [key, sourceIdx] of sourceMap) {\n      const targetIdx = targetMap.get(key);\n      if (targetIdx) {\n        const normalizedSource = this.normalizeIndexDef(sourceIdx.indexdef);\n        const normalizedTarget = this.normalizeIndexDef(targetIdx.indexdef);\n\n        if (normalizedSource !== normalizedTarget) {\n          diffs.push({\n            tableName: sourceIdx.tablename,\n            indexName: sourceIdx.indexname,\n            action: 'modified',\n            sourceDefinition: sourceIdx.indexdef,\n            targetDefinition: targetIdx.indexdef,\n          });\n        }\n      }\n    }\n\n    return diffs;\n  }\n\n  private diffConstraints(source: SchemaInfo, target: SchemaInfo): ConstraintDiff[] {\n    const diffs: ConstraintDiff[] = [];\n\n    const sourceMap = new Map(\n      source.constraints.map((c) => [`${c.table_name}.${c.constraint_name}`, c])\n    );\n    const targetMap = new Map(\n      target.constraints.map((c) => [`${c.table_name}.${c.constraint_name}`, c])\n    );\n\n    for (const [key, con] of sourceMap) {\n      if (!targetMap.has(key)) {\n        diffs.push({\n          tableName: con.table_name,\n          constraintName: con.constraint_name,\n          constraintType: this.mapConstraintType(con.constraint_type),\n          action: 'added',\n          isBreaking: false,\n          sourceDefinition: this.getConstraintDefinition(con),\n        });\n      }\n    }\n\n    for (const [key, con] of targetMap) {\n      if (!sourceMap.has(key)) {\n        diffs.push({\n          tableName: con.table_name,\n          constraintName: con.constraint_name,\n          constraintType: this.mapConstraintType(con.constraint_type),\n          action: 'removed',\n          isBreaking: con.constraint_type !== 'CHECK',\n          targetDefinition: this.getConstraintDefinition(con),\n        });\n      }\n    }\n\n    return diffs;\n  }\n\n  private detectConflicts(columns: ColumnDiff[], constraints: ConstraintDiff[]): Conflict[] {\n    const conflicts: Conflict[] = [];\n\n    for (const col of columns.filter((c) => c.action === 'modified')) {\n      if (col.sourceType !== col.targetType) {\n        conflicts.push({\n          type: 'column_type_mismatch',\n          description: `Column ${col.tableName}.${col.columnName} has different types: ${col.sourceType} vs ${col.targetType}`,\n          sourcePath: `${col.tableName}.${col.columnName}`,\n          targetPath: `${col.tableName}.${col.columnName}`,\n          resolution: ['keep_source', 'keep_target', 'manual'],\n        });\n      }\n    }\n\n    for (const con of constraints.filter(\n      (c) => c.action === 'removed' && c.constraintType === 'foreign_key'\n    )) {\n      conflicts.push({\n        type: 'constraint_conflict',\n        description: `Foreign key ${con.constraintName} on ${con.tableName} would be removed`,\n        sourcePath: `${con.tableName}.${con.constraintName}`,\n        targetPath: `${con.tableName}.${con.constraintName}`,\n        resolution: ['keep_source', 'keep_target', 'manual'],\n      });\n    }\n\n    return conflicts;\n  }\n\n  private generateMigrationSql(\n    sourceSchema: string,\n    targetSchema: string,\n    tables: TableDiff[],\n    columns: ColumnDiff[],\n    indexes: IndexDiff[],\n    constraints: ConstraintDiff[],\n    direction: 'forward' | 'reverse'\n  ): string[] {\n    const schema = direction === 'forward' ? targetSchema : sourceSchema;\n    const ctx = { sourceSchema, targetSchema, schema, direction };\n\n    return [\n      ...this.generateTableSql(tables, ctx),\n      ...this.generateColumnSql(columns, ctx),\n      ...this.generateIndexSql(indexes, ctx),\n      ...this.generateConstraintSql(constraints, ctx),\n    ];\n  }\n\n  private generateTableSql(\n    tables: TableDiff[],\n    ctx: { sourceSchema: string; schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    const sql: string[] = [];\n    for (const table of tables) {\n      const isCreate =\n        (ctx.direction === 'forward' && table.action === 'added') ||\n        (ctx.direction === 'reverse' && table.action === 'removed');\n      const isDrop =\n        (ctx.direction === 'forward' && table.action === 'removed') ||\n        (ctx.direction === 'reverse' && table.action === 'added');\n\n      if (isCreate && table.sourceDefinition) {\n        sql.push(table.sourceDefinition.replace(ctx.sourceSchema, ctx.schema));\n      } else if (isDrop) {\n        sql.push(`DROP TABLE IF EXISTS \"${ctx.schema}\".\"${table.name}\" CASCADE`);\n      }\n    }\n    return sql;\n  }\n\n  private shouldCreate(action: string, direction: 'forward' | 'reverse'): boolean {\n    return (\n      (direction === 'forward' && action === 'added') ||\n      (direction === 'reverse' && action === 'removed')\n    );\n  }\n\n  private shouldDrop(action: string, direction: 'forward' | 'reverse'): boolean {\n    return (\n      (direction === 'forward' && action === 'removed') ||\n      (direction === 'reverse' && action === 'added')\n    );\n  }\n\n  private generateColumnSql(\n    columns: ColumnDiff[],\n    ctx: { schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    return columns.flatMap((col) => this.generateSingleColumnSql(col, ctx));\n  }\n\n  private generateSingleColumnSql(\n    col: ColumnDiff,\n    ctx: { schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    const tableName = `\"${ctx.schema}\".\"${col.tableName}\"`;\n    if (this.shouldCreate(col.action, ctx.direction)) {\n      const type = ctx.direction === 'forward' ? col.sourceType : col.targetType;\n      return [`ALTER TABLE ${tableName} ADD COLUMN \"${col.columnName}\" ${type}`];\n    }\n    if (this.shouldDrop(col.action, ctx.direction)) {\n      return [`ALTER TABLE ${tableName} DROP COLUMN IF EXISTS \"${col.columnName}\"`];\n    }\n    if (col.action === 'modified') {\n      const type = ctx.direction === 'forward' ? col.sourceType : col.targetType;\n      return [`ALTER TABLE ${tableName} ALTER COLUMN \"${col.columnName}\" TYPE ${type}`];\n    }\n    return [];\n  }\n\n  private generateIndexSql(\n    indexes: IndexDiff[],\n    ctx: {\n      sourceSchema: string;\n      targetSchema: string;\n      schema: string;\n      direction: 'forward' | 'reverse';\n    }\n  ): string[] {\n    return indexes.flatMap((idx) => this.generateSingleIndexSql(idx, ctx));\n  }\n\n  private generateSingleIndexSql(\n    idx: IndexDiff,\n    ctx: {\n      sourceSchema: string;\n      targetSchema: string;\n      schema: string;\n      direction: 'forward' | 'reverse';\n    }\n  ): string[] {\n    if (this.shouldCreate(idx.action, ctx.direction)) {\n      const def = ctx.direction === 'forward' ? idx.sourceDefinition : idx.targetDefinition;\n      if (def) {\n        return [def.replace(ctx.sourceSchema, ctx.schema).replace(ctx.targetSchema, ctx.schema)];\n      }\n    }\n    if (this.shouldDrop(idx.action, ctx.direction)) {\n      return [`DROP INDEX IF EXISTS \"${ctx.schema}\".\"${idx.indexName}\"`];\n    }\n    return [];\n  }\n\n  private generateConstraintSql(\n    constraints: ConstraintDiff[],\n    ctx: { schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    return constraints.flatMap((con) => this.generateSingleConstraintSql(con, ctx));\n  }\n\n  private generateSingleConstraintSql(\n    con: ConstraintDiff,\n    ctx: { schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    const tableName = `\"${ctx.schema}\".\"${con.tableName}\"`;\n    if (this.shouldCreate(con.action, ctx.direction)) {\n      const def = ctx.direction === 'forward' ? con.sourceDefinition : con.targetDefinition;\n      if (def) {\n        return [`ALTER TABLE ${tableName} ADD ${def}`];\n      }\n    }\n    if (this.shouldDrop(con.action, ctx.direction)) {\n      return [`ALTER TABLE ${tableName} DROP CONSTRAINT IF EXISTS \"${con.constraintName}\"`];\n    }\n    return [];\n  }\n\n  private getTableDefinition(tableName: string, schema: SchemaInfo): string {\n    const columns = schema.columns.filter((c) => c.table_name === tableName);\n    const colDefs = columns.map((c) => {\n      let def = `\"${c.column_name}\" ${this.getColumnType(c)}`;\n      if (c.is_nullable === 'NO') {\n        def += ' NOT NULL';\n      }\n      if (c.column_default) {\n        def += ` DEFAULT ${c.column_default}`;\n      }\n      return def;\n    });\n\n    return `CREATE TABLE \"${tableName}\" (\\n  ${colDefs.join(',\\n  ')}\\n)`;\n  }\n\n  private getColumnType(col: SchemaColumnInfo): string {\n    let type = col.data_type;\n\n    if (col.character_maximum_length) {\n      type = `${col.udt_name}(${col.character_maximum_length})`;\n    } else if (col.numeric_precision && col.numeric_scale !== null) {\n      type = `${col.udt_name}(${col.numeric_precision},${col.numeric_scale})`;\n    } else if (col.udt_name && col.udt_name !== col.data_type) {\n      type = col.udt_name;\n    }\n\n    return type.toUpperCase();\n  }\n\n  private hasColumnChanges(source: SchemaColumnInfo, target: SchemaColumnInfo): boolean {\n    return (\n      this.getColumnType(source) !== this.getColumnType(target) ||\n      source.is_nullable !== target.is_nullable ||\n      source.column_default !== target.column_default\n    );\n  }\n\n  private isBreakingTypeChange(sourceType: string, targetType: string): boolean {\n    const breakingChanges = [\n      { from: 'TEXT', to: 'VARCHAR' },\n      { from: 'VARCHAR', to: 'INTEGER' },\n      { from: 'INTEGER', to: 'SMALLINT' },\n      { from: 'BIGINT', to: 'INTEGER' },\n      { from: 'TIMESTAMP', to: 'DATE' },\n    ];\n\n    const source = sourceType.toUpperCase();\n    const target = targetType.toUpperCase();\n\n    return breakingChanges.some(\n      (change) => source.includes(change.from) && target.includes(change.to)\n    );\n  }\n\n  private normalizeIndexDef(indexdef: string): string {\n    return indexdef\n      .replace(/\\s+/g, ' ')\n      .replace(/\\s*,\\s*/g, ', ')\n      .toLowerCase()\n      .trim();\n  }\n\n  private mapConstraintType(type: string): 'primary_key' | 'foreign_key' | 'unique' | 'check' {\n    switch (type) {\n      case 'PRIMARY KEY':\n        return 'primary_key';\n      case 'FOREIGN KEY':\n        return 'foreign_key';\n      case 'UNIQUE':\n        return 'unique';\n      case 'CHECK':\n        return 'check';\n      default:\n        return 'check';\n    }\n  }\n\n  private getConstraintDefinition(con: SchemaConstraintInfo): string {\n    if (\n      con.constraint_type === 'FOREIGN KEY' &&\n      con.foreign_table_name &&\n      con.foreign_column_name\n    ) {\n      return `CONSTRAINT \"${con.constraint_name}\" FOREIGN KEY (\"${con.column_name}\") REFERENCES \"${con.foreign_table_name}\"(\"${con.foreign_column_name}\")`;\n    }\n    if (con.constraint_type === 'PRIMARY KEY') {\n      return `CONSTRAINT \"${con.constraint_name}\" PRIMARY KEY (\"${con.column_name}\")`;\n    }\n    if (con.constraint_type === 'UNIQUE') {\n      return `CONSTRAINT \"${con.constraint_name}\" UNIQUE (\"${con.column_name}\")`;\n    }\n    return `CONSTRAINT \"${con.constraint_name}\"`;\n  }\n}\n","import type { Driver } from '../driver/types.js';\nimport { SchemaDiffer } from './schema-differ.js';\nimport type { Conflict, ConflictResolution, MergeOptions, MergeResult } from './types.js';\n\nexport interface MigrationRecord {\n  version: number;\n  name: string;\n  scope: 'core' | 'template';\n  checksum: string;\n  upSql: string[];\n  downSql: string[];\n  appliedAt: Date;\n}\n\nexport interface MigrationMergerOptions {\n  mainSchema?: string;\n  branchPrefix?: string;\n  migrationsTable?: string;\n}\n\nexport class MigrationMerger {\n  private driver: Driver;\n  private mainSchema: string;\n  private migrationsTable: string;\n\n  constructor(driver: Driver, options: MigrationMergerOptions = {}) {\n    this.driver = driver;\n    this.mainSchema = options.mainSchema ?? 'public';\n    this.migrationsTable = options.migrationsTable ?? 'lp_migrations';\n  }\n\n  async merge(options: MergeOptions): Promise<MergeResult> {\n    const { sourceBranch, targetBranch, dryRun, conflictResolution } = options;\n\n    const sourceSchema = await this.resolveSchemaName(sourceBranch);\n    const targetSchema = await this.resolveSchemaName(targetBranch);\n\n    const differ = new SchemaDiffer(this.driver);\n    const diff = await differ.diff(sourceSchema, targetSchema);\n\n    if (!diff.hasChanges) {\n      return {\n        success: true,\n        migrationsApplied: 0,\n        conflicts: [],\n        errors: [],\n        rollbackAvailable: false,\n      };\n    }\n\n    if (\n      diff.conflicts.length > 0 &&\n      !this.allConflictsResolved(diff.conflicts, conflictResolution)\n    ) {\n      return {\n        success: false,\n        migrationsApplied: 0,\n        conflicts: diff.conflicts,\n        errors: ['Unresolved conflicts detected. Provide conflict resolutions.'],\n        rollbackAvailable: false,\n      };\n    }\n\n    if (dryRun) {\n      return {\n        success: true,\n        migrationsApplied: diff.forwardSql.length,\n        conflicts: [],\n        errors: [],\n        rollbackAvailable: false,\n      };\n    }\n\n    try {\n      await this.driver.transaction(async (trx) => {\n        for (const sql of diff.forwardSql) {\n          const adjustedSql = sql.replace(\n            new RegExp(`\"${sourceSchema}\"`, 'g'),\n            `\"${targetSchema}\"`\n          );\n          await trx.execute(adjustedSql);\n        }\n\n        await trx.execute(\n          `\n          INSERT INTO ${this.quoteIdent(this.migrationsTable)} (\n            version, name, scope, checksum, up_sql, down_sql\n          ) VALUES (\n            EXTRACT(EPOCH FROM NOW())::BIGINT * 1000 + (random() * 1000)::INT,\n            $1,\n            'core',\n            $2,\n            $3,\n            $4\n          )\n        `,\n          [\n            `merge_${sourceBranch}_to_${targetBranch}`,\n            this.computeChecksum(diff.forwardSql),\n            diff.forwardSql,\n            diff.reverseSql,\n          ]\n        );\n      });\n\n      return {\n        success: true,\n        migrationsApplied: diff.forwardSql.length,\n        conflicts: [],\n        errors: [],\n        rollbackAvailable: true,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        migrationsApplied: 0,\n        conflicts: [],\n        errors: [error instanceof Error ? error.message : String(error)],\n        rollbackAvailable: false,\n      };\n    }\n  }\n\n  async getPendingMigrations(\n    _sourceBranch: string,\n    _targetBranch: string\n  ): Promise<MigrationRecord[]> {\n    const result = await this.driver.query<{\n      version: string | number;\n      name: string;\n      scope: 'core' | 'template';\n      checksum: string;\n      up_sql: string[] | string;\n      down_sql: string[] | string | null;\n      applied_at: Date | string;\n    }>(`\n      SELECT s.version, s.name, s.scope, s.checksum, s.up_sql, s.down_sql, s.applied_at\n      FROM ${this.quoteIdent(this.migrationsTable)} s\n      WHERE NOT EXISTS (\n        SELECT 1 FROM ${this.quoteIdent(this.migrationsTable)} t\n        WHERE t.version = s.version\n      )\n      ORDER BY s.version ASC\n    `);\n\n    return result.rows.map((row) => ({\n      version: typeof row.version === 'string' ? Number.parseInt(row.version, 10) : row.version,\n      name: row.name,\n      scope: row.scope,\n      checksum: row.checksum,\n      upSql: typeof row.up_sql === 'string' ? JSON.parse(row.up_sql) : row.up_sql,\n      downSql: row.down_sql\n        ? typeof row.down_sql === 'string'\n          ? JSON.parse(row.down_sql)\n          : row.down_sql\n        : [],\n      appliedAt: new Date(row.applied_at),\n    }));\n  }\n\n  async detectMigrationConflicts(\n    migrations: MigrationRecord[],\n    targetBranch: string\n  ): Promise<Conflict[]> {\n    const conflicts: Conflict[] = [];\n    const targetSchema = await this.resolveSchemaName(targetBranch);\n\n    const tableNames = new Set<string>();\n    for (const migration of migrations) {\n      for (const sql of migration.upSql) {\n        const createMatch = sql.match(/CREATE TABLE\\s+(?:\"[^\"]+\"\\.)?\"([^\"]+)\"/i);\n        const alterMatch = sql.match(/ALTER TABLE\\s+(?:\"[^\"]+\"\\.)?\"([^\"]+)\"/i);\n\n        const tableName = createMatch?.[1] || alterMatch?.[1];\n        if (tableName) {\n          tableNames.add(tableName);\n        }\n      }\n    }\n\n    for (const tableName of tableNames) {\n      const exists = await this.tableExists(targetSchema, tableName);\n\n      if (exists) {\n        const willBeCreated = migrations.some((m) =>\n          m.upSql.some((sql) =>\n            sql.match(new RegExp(`CREATE TABLE\\\\s+(?:\"[^\"]+\"\\\\.)?[\"']?${tableName}[\"']?`, 'i'))\n          )\n        );\n\n        if (willBeCreated) {\n          conflicts.push({\n            type: 'table_removed',\n            description: `Table ${tableName} already exists in target branch but will be created by migration`,\n            sourcePath: tableName,\n            targetPath: tableName,\n            resolution: ['keep_source', 'keep_target', 'manual'],\n          });\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  private allConflictsResolved(\n    conflicts: Conflict[],\n    resolution?: Record<string, ConflictResolution>\n  ): boolean {\n    if (!resolution) {\n      return conflicts.length === 0;\n    }\n\n    for (const conflict of conflicts) {\n      const key = conflict.sourcePath;\n      if (!resolution[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private async resolveSchemaName(branchName: string): Promise<string> {\n    if (branchName === 'main' || branchName === 'public') {\n      return this.mainSchema;\n    }\n\n    const result = await this.driver.query<{ schema_name: string }>(\n      `\n      SELECT schema_name FROM lp_branch_metadata\n      WHERE slug = $1 AND deleted_at IS NULL\n    `,\n      [branchName]\n    );\n\n    if (result.rows.length === 0) {\n      throw new Error(`Branch '${branchName}' not found`);\n    }\n\n    return result.rows[0].schema_name;\n  }\n\n  private async tableExists(schema: string, tableName: string): Promise<boolean> {\n    const result = await this.driver.query<{ exists: boolean }>(\n      `\n      SELECT EXISTS (\n        SELECT 1 FROM information_schema.tables\n        WHERE table_schema = $1 AND table_name = $2\n      ) as exists\n    `,\n      [schema, tableName]\n    );\n\n    return result.rows[0]?.exists ?? false;\n  }\n\n  private computeChecksum(statements: string[]): string {\n    const { createHash } = require('node:crypto');\n    return createHash('sha256').update(statements.join('\\n')).digest('hex');\n  }\n\n  private quoteIdent(identifier: string): string {\n    return `\"${identifier.replace(/\"/g, '\"\"')}\"`;\n  }\n}\n","import type { Driver, TransactionClient } from '../driver/types.js';\nimport { MigrationMerger } from './migration-merger.js';\nimport { SchemaDiffer } from './schema-differ.js';\nimport type {\n  Branch,\n  BranchRow,\n  BranchStatus,\n  CleanupOptions,\n  CleanupResult,\n  CreateBranchOptions,\n  ListBranchesFilter,\n  MergeOptions,\n  MergeResult,\n  SchemaDiff,\n  SwitchBranchResult,\n} from './types.js';\n\nexport interface BranchManagerOptions {\n  driver: Driver;\n  mainSchemaName?: string;\n  branchPrefix?: string;\n  defaultAutoDeleteDays?: number;\n  metadataTableName?: string;\n}\n\nexport class BranchManager {\n  private driver: Driver;\n  private mainSchema: string;\n  private branchPrefix: string;\n  private defaultAutoDeleteDays: number;\n  private metadataTable: string;\n\n  constructor(options: BranchManagerOptions) {\n    this.driver = options.driver;\n    this.mainSchema = options.mainSchemaName ?? 'public';\n    this.branchPrefix = options.branchPrefix ?? 'branch_';\n    this.defaultAutoDeleteDays = options.defaultAutoDeleteDays ?? 7;\n    this.metadataTable = options.metadataTableName ?? 'lp_branch_metadata';\n  }\n\n  async ensureMetadataTable(): Promise<void> {\n    await this.driver.execute(`\n      CREATE TABLE IF NOT EXISTS ${this.quoteIdent(this.metadataTable)} (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        name VARCHAR(128) NOT NULL,\n        slug VARCHAR(128) NOT NULL UNIQUE,\n        schema_name VARCHAR(128) NOT NULL UNIQUE,\n        parent_branch_id UUID REFERENCES ${this.quoteIdent(this.metadataTable)}(id),\n\n        git_branch VARCHAR(256),\n        pr_number INTEGER,\n        pr_url TEXT,\n\n        status VARCHAR(20) NOT NULL DEFAULT 'active'\n          CHECK (status IN ('active', 'protected', 'stale', 'deleting')),\n        is_protected BOOLEAN NOT NULL DEFAULT FALSE,\n        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n        created_by VARCHAR(256),\n        last_accessed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n        deleted_at TIMESTAMPTZ,\n\n        migration_count INTEGER DEFAULT 0,\n        table_count INTEGER DEFAULT 0,\n        storage_bytes BIGINT DEFAULT 0,\n\n        auto_delete_days INTEGER DEFAULT 7,\n        copy_data BOOLEAN DEFAULT FALSE,\n        pii_masking BOOLEAN DEFAULT TRUE\n      )\n    `);\n\n    await this.driver.execute(`\n      CREATE INDEX IF NOT EXISTS idx_${this.metadataTable}_status\n      ON ${this.quoteIdent(this.metadataTable)}(status)\n    `);\n\n    await this.driver.execute(`\n      CREATE INDEX IF NOT EXISTS idx_${this.metadataTable}_parent\n      ON ${this.quoteIdent(this.metadataTable)}(parent_branch_id)\n    `);\n\n    await this.driver.execute(`\n      CREATE INDEX IF NOT EXISTS idx_${this.metadataTable}_pr\n      ON ${this.quoteIdent(this.metadataTable)}(pr_number)\n    `);\n\n    await this.driver.execute(`\n      CREATE INDEX IF NOT EXISTS idx_${this.metadataTable}_accessed\n      ON ${this.quoteIdent(this.metadataTable)}(last_accessed_at)\n    `);\n  }\n\n  async createBranch(options: CreateBranchOptions): Promise<Branch> {\n    await this.ensureMetadataTable();\n\n    const slug = this.generateSlug(options.name);\n    const schemaName = `${this.branchPrefix}${slug}`;\n\n    const existing = await this.getBranchBySlug(slug);\n    if (existing) {\n      throw new Error(`Branch '${slug}' already exists`);\n    }\n\n    const parentBranch = options.parentBranch\n      ? await this.getBranchBySlug(options.parentBranch)\n      : null;\n\n    const parentSchema = parentBranch?.schemaName ?? this.mainSchema;\n\n    return await this.driver.transaction(async (trx) => {\n      await trx.execute(`CREATE SCHEMA IF NOT EXISTS ${this.quoteIdent(schemaName)}`);\n\n      await this.cloneSchemaStructure(trx, parentSchema, schemaName);\n\n      if (options.copyData) {\n        await this.copyDataWithMasking(trx, parentSchema, schemaName, options.piiMasking ?? true);\n      }\n\n      const tableCount = await this.getTableCount(trx, schemaName);\n\n      const result = await trx.query<BranchRow>(\n        `\n        INSERT INTO ${this.quoteIdent(this.metadataTable)} (\n          name, slug, schema_name, parent_branch_id,\n          git_branch, pr_number, pr_url,\n          auto_delete_days, copy_data, pii_masking, created_by, table_count\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\n        RETURNING *\n      `,\n        [\n          options.name,\n          slug,\n          schemaName,\n          parentBranch?.id ?? null,\n          options.gitBranch ?? null,\n          options.prNumber ?? null,\n          options.prUrl ?? null,\n          options.autoDeleteDays ?? this.defaultAutoDeleteDays,\n          options.copyData ?? false,\n          options.piiMasking ?? true,\n          options.createdBy ?? null,\n          tableCount,\n        ]\n      );\n\n      return this.mapBranchRow(result.rows[0]);\n    });\n  }\n\n  async getBranchBySlug(slug: string): Promise<Branch | null> {\n    const result = await this.driver.query<BranchRow>(\n      `\n      SELECT * FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE slug = $1 AND deleted_at IS NULL\n    `,\n      [slug]\n    );\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    return this.mapBranchRow(result.rows[0]);\n  }\n\n  async getBranchById(id: string): Promise<Branch | null> {\n    const result = await this.driver.query<BranchRow>(\n      `\n      SELECT * FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE id = $1 AND deleted_at IS NULL\n    `,\n      [id]\n    );\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    return this.mapBranchRow(result.rows[0]);\n  }\n\n  async deleteBranch(branchSlug: string, force = false): Promise<void> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    if (branch.isProtected && !force) {\n      throw new Error(`Branch '${branchSlug}' is protected. Use force=true to delete.`);\n    }\n\n    await this.driver.transaction(async (trx) => {\n      await trx.execute(\n        `\n        UPDATE ${this.quoteIdent(this.metadataTable)}\n        SET status = 'deleting', deleted_at = NOW()\n        WHERE id = $1\n      `,\n        [branch.id]\n      );\n\n      await trx.execute(`DROP SCHEMA IF EXISTS ${this.quoteIdent(branch.schemaName)} CASCADE`);\n\n      await trx.execute(\n        `\n        DELETE FROM ${this.quoteIdent(this.metadataTable)} WHERE id = $1\n      `,\n        [branch.id]\n      );\n    });\n  }\n\n  async switchBranch(branchSlug: string): Promise<SwitchBranchResult> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    await this.driver.execute(\n      `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET last_accessed_at = NOW()\n      WHERE id = $1\n    `,\n      [branch.id]\n    );\n\n    const searchPath = `${branch.schemaName}, public`;\n\n    return {\n      connectionString: this.generateConnectionString(branch),\n      searchPath,\n      schemaName: branch.schemaName,\n    };\n  }\n\n  async diffBranches(sourceBranch: string, targetBranch: string): Promise<SchemaDiff> {\n    const source = await this.resolveSchemaName(sourceBranch);\n    const target = await this.resolveSchemaName(targetBranch);\n\n    const differ = new SchemaDiffer(this.driver);\n    return differ.diff(source, target);\n  }\n\n  async mergeBranch(options: MergeOptions): Promise<MergeResult> {\n    const merger = new MigrationMerger(this.driver, {\n      mainSchema: this.mainSchema,\n      branchPrefix: this.branchPrefix,\n    });\n\n    const result = await merger.merge(options);\n\n    if (result.success && options.deleteSourceAfterMerge) {\n      await this.deleteBranch(options.sourceBranch, true);\n    }\n\n    return result;\n  }\n\n  async listBranches(filter?: ListBranchesFilter): Promise<Branch[]> {\n    await this.ensureMetadataTable();\n\n    let sql = `SELECT * FROM ${this.quoteIdent(this.metadataTable)} WHERE deleted_at IS NULL`;\n    const params: unknown[] = [];\n    let paramIndex = 1;\n\n    if (filter?.status) {\n      sql += ` AND status = $${paramIndex++}`;\n      params.push(filter.status);\n    }\n\n    if (filter?.parentId) {\n      sql += ` AND parent_branch_id = $${paramIndex++}`;\n      params.push(filter.parentId);\n    }\n\n    if (filter?.staleDays) {\n      sql += ` AND last_accessed_at < NOW() - INTERVAL '${filter.staleDays} days'`;\n    }\n\n    sql += ' ORDER BY created_at DESC';\n\n    const result = await this.driver.query<BranchRow>(sql, params);\n    return result.rows.map((row) => this.mapBranchRow(row));\n  }\n\n  async cleanupStaleBranches(options: CleanupOptions = {}): Promise<CleanupResult> {\n    await this.ensureMetadataTable();\n\n    const maxAge = options.maxAgeDays ?? 7;\n    const skipProtected = options.skipProtected ?? true;\n\n    let sql = `\n      SELECT * FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE deleted_at IS NULL\n        AND last_accessed_at < NOW() - INTERVAL '${maxAge} days'\n        AND status != 'deleting'\n    `;\n\n    if (skipProtected) {\n      sql += ` AND is_protected = FALSE AND status != 'protected'`;\n    }\n\n    const result = await this.driver.query<BranchRow>(sql);\n    const deleted: string[] = [];\n    const skipped: string[] = [];\n\n    for (const row of result.rows) {\n      const branch = this.mapBranchRow(row);\n      if (options.dryRun) {\n        deleted.push(branch.slug);\n      } else {\n        try {\n          await this.deleteBranch(branch.slug, true);\n          deleted.push(branch.slug);\n        } catch (error) {\n          skipped.push(`${branch.slug}: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      }\n    }\n\n    return { deleted, skipped };\n  }\n\n  async protectBranch(branchSlug: string): Promise<void> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    await this.driver.execute(\n      `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET is_protected = TRUE, status = 'protected'\n      WHERE id = $1\n    `,\n      [branch.id]\n    );\n  }\n\n  async unprotectBranch(branchSlug: string): Promise<void> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    await this.driver.execute(\n      `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET is_protected = FALSE, status = 'active'\n      WHERE id = $1\n    `,\n      [branch.id]\n    );\n  }\n\n  async updateBranchStats(branchSlug: string): Promise<void> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    const tableCount = await this.getTableCount(this.driver, branch.schemaName);\n\n    const storageResult = await this.driver.query<{ storage_bytes: string }>(\n      `\n      SELECT COALESCE(sum(pg_total_relation_size(quote_ident(schemaname) || '.' || quote_ident(tablename)))::bigint, 0)::text as storage_bytes\n      FROM pg_tables\n      WHERE schemaname = $1\n    `,\n      [branch.schemaName]\n    );\n\n    const storageBytes = Number.parseInt(storageResult.rows[0]?.storage_bytes ?? '0', 10);\n\n    await this.driver.execute(\n      `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET table_count = $1, storage_bytes = $2\n      WHERE id = $3\n    `,\n      [tableCount, storageBytes, branch.id]\n    );\n  }\n\n  private async cloneSchemaStructure(\n    trx: TransactionClient,\n    sourceSchema: string,\n    targetSchema: string\n  ): Promise<void> {\n    const tablesResult = await trx.query<{ tablename: string }>(\n      `\n      SELECT tablename FROM pg_tables\n      WHERE schemaname = $1 AND tablename NOT LIKE 'lp_%'\n    `,\n      [sourceSchema]\n    );\n\n    for (const { tablename } of tablesResult.rows) {\n      await trx.execute(`\n        CREATE TABLE ${this.quoteIdent(targetSchema)}.${this.quoteIdent(tablename)}\n        (LIKE ${this.quoteIdent(sourceSchema)}.${this.quoteIdent(tablename)}\n         INCLUDING ALL)\n      `);\n    }\n\n    await this.cloneSequences(trx, sourceSchema, targetSchema);\n    await this.cloneViews(trx, sourceSchema, targetSchema);\n  }\n\n  private async cloneSequences(\n    trx: TransactionClient,\n    sourceSchema: string,\n    targetSchema: string\n  ): Promise<void> {\n    const sequencesResult = await trx.query<{ sequence_name: string }>(\n      `\n      SELECT sequence_name\n      FROM information_schema.sequences\n      WHERE sequence_schema = $1\n    `,\n      [sourceSchema]\n    );\n\n    for (const { sequence_name } of sequencesResult.rows) {\n      const seqInfo = await trx.query<{\n        start_value: string;\n        increment_by: string;\n        min_value: string;\n        max_value: string;\n        last_value: string | null;\n      }>(\n        `\n        SELECT start_value::text, increment_by::text, min_value::text, max_value::text, last_value::text\n        FROM pg_sequences\n        WHERE schemaname = $1 AND sequencename = $2\n      `,\n        [sourceSchema, sequence_name]\n      );\n\n      if (seqInfo.rows.length > 0) {\n        const seq = seqInfo.rows[0];\n        await trx.execute(`\n          CREATE SEQUENCE IF NOT EXISTS ${this.quoteIdent(targetSchema)}.${this.quoteIdent(sequence_name)}\n          START WITH ${seq.last_value ?? seq.start_value}\n          INCREMENT BY ${seq.increment_by}\n          MINVALUE ${seq.min_value}\n          MAXVALUE ${seq.max_value}\n        `);\n      }\n    }\n  }\n\n  private async cloneViews(\n    trx: TransactionClient,\n    sourceSchema: string,\n    targetSchema: string\n  ): Promise<void> {\n    const viewsResult = await trx.query<{ viewname: string; definition: string }>(\n      `\n      SELECT viewname, definition\n      FROM pg_views\n      WHERE schemaname = $1\n    `,\n      [sourceSchema]\n    );\n\n    for (const { viewname, definition } of viewsResult.rows) {\n      const adjustedDefinition = definition.replace(\n        new RegExp(`${sourceSchema}\\\\.`, 'g'),\n        `${targetSchema}.`\n      );\n\n      await trx.execute(`\n        CREATE OR REPLACE VIEW ${this.quoteIdent(targetSchema)}.${this.quoteIdent(viewname)} AS\n        ${adjustedDefinition}\n      `);\n    }\n  }\n\n  private async copyDataWithMasking(\n    trx: TransactionClient,\n    sourceSchema: string,\n    targetSchema: string,\n    applyMasking: boolean\n  ): Promise<void> {\n    const tablesResult = await trx.query<{ tablename: string }>(\n      `\n      SELECT tablename FROM pg_tables\n      WHERE schemaname = $1 AND tablename NOT LIKE 'lp_%'\n    `,\n      [sourceSchema]\n    );\n\n    for (const { tablename } of tablesResult.rows) {\n      if (applyMasking) {\n        const columnsResult = await trx.query<{ column_name: string; data_type: string }>(\n          `\n          SELECT column_name, data_type\n          FROM information_schema.columns\n          WHERE table_schema = $1 AND table_name = $2\n          ORDER BY ordinal_position\n        `,\n          [sourceSchema, tablename]\n        );\n\n        const columnList = columnsResult.rows\n          .map((col) => this.quoteIdent(col.column_name))\n          .join(', ');\n        const selectList = columnsResult.rows\n          .map((col) => {\n            const isPii = this.isPiiColumn(col.column_name);\n            if ((isPii && col.data_type === 'character varying') || col.data_type === 'text') {\n              if (col.column_name.toLowerCase().includes('email')) {\n                return `CASE WHEN ${this.quoteIdent(col.column_name)} IS NOT NULL\n                THEN 'masked_' || substr(md5(${this.quoteIdent(col.column_name)}::text), 1, 8) || '@example.com'\n                ELSE NULL END AS ${this.quoteIdent(col.column_name)}`;\n              }\n              return `CASE WHEN ${this.quoteIdent(col.column_name)} IS NOT NULL\n              THEN 'masked_' || substr(md5(${this.quoteIdent(col.column_name)}::text), 1, 8)\n              ELSE NULL END AS ${this.quoteIdent(col.column_name)}`;\n            }\n            return this.quoteIdent(col.column_name);\n          })\n          .join(', ');\n\n        await trx.execute(`\n          INSERT INTO ${this.quoteIdent(targetSchema)}.${this.quoteIdent(tablename)} (${columnList})\n          SELECT ${selectList}\n          FROM ${this.quoteIdent(sourceSchema)}.${this.quoteIdent(tablename)}\n        `);\n      } else {\n        await trx.execute(`\n          INSERT INTO ${this.quoteIdent(targetSchema)}.${this.quoteIdent(tablename)}\n          SELECT * FROM ${this.quoteIdent(sourceSchema)}.${this.quoteIdent(tablename)}\n        `);\n      }\n    }\n  }\n\n  private isPiiColumn(columnName: string): boolean {\n    const piiPatterns = [\n      'email',\n      'phone',\n      'address',\n      'ssn',\n      'social_security',\n      'credit_card',\n      'password',\n      'secret',\n      'token',\n      'first_name',\n      'last_name',\n      'full_name',\n      'name',\n      'dob',\n      'date_of_birth',\n      'ip_address',\n      'ip',\n      'location',\n      'latitude',\n      'longitude',\n    ];\n\n    const lower = columnName.toLowerCase();\n    return piiPatterns.some((pattern) => lower.includes(pattern));\n  }\n\n  private async getTableCount(\n    client: Driver | TransactionClient,\n    schemaName: string\n  ): Promise<number> {\n    const result = await client.query<{ count: string }>(\n      `\n      SELECT COUNT(*)::text as count\n      FROM pg_tables\n      WHERE schemaname = $1 AND tablename NOT LIKE 'lp_%'\n    `,\n      [schemaName]\n    );\n\n    return Number.parseInt(result.rows[0]?.count ?? '0', 10);\n  }\n\n  private generateSlug(name: string): string {\n    return name\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, '_')\n      .replace(/^_|_$/g, '')\n      .substring(0, 100);\n  }\n\n  private quoteIdent(identifier: string): string {\n    return `\"${identifier.replace(/\"/g, '\"\"')}\"`;\n  }\n\n  private async resolveSchemaName(branchName: string): Promise<string> {\n    if (branchName === 'main' || branchName === 'public') {\n      return this.mainSchema;\n    }\n    const branch = await this.getBranchBySlug(branchName);\n    if (!branch) {\n      throw new Error(`Branch '${branchName}' not found`);\n    }\n    return branch.schemaName;\n  }\n\n  private generateConnectionString(branch: Branch): string {\n    const baseUrl = process.env.DATABASE_URL || '';\n    if (!baseUrl) {\n      return `options=-c search_path=${branch.schemaName},public`;\n    }\n    try {\n      const url = new URL(baseUrl);\n      url.searchParams.set('options', `-c search_path=${branch.schemaName},public`);\n      return url.toString();\n    } catch {\n      return `${baseUrl}?options=-c search_path=${branch.schemaName},public`;\n    }\n  }\n\n  private mapBranchRow(row: BranchRow): Branch {\n    return {\n      id: row.id,\n      name: row.name,\n      slug: row.slug,\n      schemaName: row.schema_name,\n      parentBranchId: row.parent_branch_id,\n      gitBranch: row.git_branch,\n      prNumber: row.pr_number,\n      prUrl: row.pr_url,\n      status: row.status as BranchStatus,\n      isProtected: row.is_protected,\n      createdAt: new Date(row.created_at),\n      createdBy: row.created_by,\n      lastAccessedAt: new Date(row.last_accessed_at),\n      deletedAt: row.deleted_at ? new Date(row.deleted_at) : null,\n      migrationCount: row.migration_count,\n      tableCount: row.table_count,\n      storageBytes:\n        typeof row.storage_bytes === 'string'\n          ? Number.parseInt(row.storage_bytes, 10)\n          : row.storage_bytes,\n      autoDeleteDays: row.auto_delete_days,\n      copyData: row.copy_data,\n      piiMasking: row.pii_masking,\n    };\n  }\n}\n\nexport function createBranchManager(options: BranchManagerOptions): BranchManager {\n  return new BranchManager(options);\n}\n","import type { Driver, TransactionClient } from '../driver/types.js';\n\nexport interface ConnectionManagerOptions {\n  driver: Driver;\n  mainSchema?: string;\n  branchPrefix?: string;\n}\n\nexport interface BranchConnection {\n  schemaName: string;\n  searchPath: string;\n  connectionString: string;\n}\n\nexport class ConnectionManager {\n  private driver: Driver;\n  private mainSchema: string;\n  private branchPrefix: string;\n  private currentSchema: string;\n\n  constructor(options: ConnectionManagerOptions) {\n    this.driver = options.driver;\n    this.mainSchema = options.mainSchema ?? 'public';\n    this.branchPrefix = options.branchPrefix ?? 'branch_';\n    this.currentSchema = this.mainSchema;\n  }\n\n  async switchToBranch(branchSlug: string): Promise<BranchConnection> {\n    const schemaName = await this.getSchemaForBranch(branchSlug);\n    const searchPath = `${schemaName}, public`;\n\n    await this.driver.execute(`SET search_path TO ${searchPath}`);\n\n    this.currentSchema = schemaName;\n\n    await this.updateLastAccessed(branchSlug);\n\n    return {\n      schemaName,\n      searchPath,\n      connectionString: this.generateConnectionString(schemaName),\n    };\n  }\n\n  async switchToMain(): Promise<BranchConnection> {\n    const searchPath = `${this.mainSchema}, public`;\n\n    await this.driver.execute(`SET search_path TO ${searchPath}`);\n\n    this.currentSchema = this.mainSchema;\n\n    return {\n      schemaName: this.mainSchema,\n      searchPath,\n      connectionString: this.generateConnectionString(this.mainSchema),\n    };\n  }\n\n  async withBranch<T>(\n    branchSlug: string,\n    callback: (client: TransactionClient) => Promise<T>\n  ): Promise<T> {\n    const schemaName = await this.getSchemaForBranch(branchSlug);\n    const searchPath = `${schemaName}, public`;\n\n    return await this.driver.transaction(async (trx) => {\n      await trx.execute(`SET LOCAL search_path TO ${searchPath}`);\n      return callback(trx);\n    });\n  }\n\n  async withSchema<T>(\n    schemaName: string,\n    callback: (client: TransactionClient) => Promise<T>\n  ): Promise<T> {\n    const searchPath = `${schemaName}, public`;\n\n    return await this.driver.transaction(async (trx) => {\n      await trx.execute(`SET LOCAL search_path TO ${searchPath}`);\n      return callback(trx);\n    });\n  }\n\n  getCurrentSchema(): string {\n    return this.currentSchema;\n  }\n\n  async getCurrentSearchPath(): Promise<string> {\n    const result = await this.driver.query<{ search_path: string }>('SHOW search_path');\n    return result.rows[0]?.search_path ?? this.mainSchema;\n  }\n\n  async validateSchema(schemaName: string): Promise<boolean> {\n    const result = await this.driver.query<{ exists: boolean }>(\n      `\n      SELECT EXISTS (\n        SELECT 1 FROM information_schema.schemata\n        WHERE schema_name = $1\n      ) as exists\n    `,\n      [schemaName]\n    );\n\n    return result.rows[0]?.exists ?? false;\n  }\n\n  async listAvailableSchemas(): Promise<string[]> {\n    const result = await this.driver.query<{ schema_name: string }>(\n      `\n      SELECT schema_name\n      FROM information_schema.schemata\n      WHERE schema_name LIKE $1 OR schema_name = $2\n      ORDER BY schema_name\n    `,\n      [`${this.branchPrefix}%`, this.mainSchema]\n    );\n\n    return result.rows.map((row) => row.schema_name);\n  }\n\n  generateConnectionString(schemaName: string): string {\n    const baseUrl = process.env.DATABASE_URL || '';\n    if (!baseUrl) {\n      return `options=-c search_path=${schemaName},public`;\n    }\n\n    try {\n      const url = new URL(baseUrl);\n      url.searchParams.set('options', `-c search_path=${schemaName},public`);\n      return url.toString();\n    } catch {\n      const separator = baseUrl.includes('?') ? '&' : '?';\n      return `${baseUrl}${separator}options=-c search_path=${schemaName},public`;\n    }\n  }\n\n  generateEnvVars(schemaName: string): Record<string, string> {\n    return {\n      DATABASE_URL: this.generateConnectionString(schemaName),\n      DB_SCHEMA: schemaName,\n      DB_SEARCH_PATH: `${schemaName}, public`,\n    };\n  }\n\n  private async getSchemaForBranch(branchSlug: string): Promise<string> {\n    if (branchSlug === 'main' || branchSlug === 'public') {\n      return this.mainSchema;\n    }\n\n    const result = await this.driver.query<{ schema_name: string }>(\n      `\n      SELECT schema_name FROM lp_branch_metadata\n      WHERE slug = $1 AND deleted_at IS NULL\n    `,\n      [branchSlug]\n    );\n\n    if (result.rows.length === 0) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    return result.rows[0].schema_name;\n  }\n\n  private async updateLastAccessed(branchSlug: string): Promise<void> {\n    await this.driver.execute(\n      `\n      UPDATE lp_branch_metadata\n      SET last_accessed_at = NOW()\n      WHERE slug = $1\n    `,\n      [branchSlug]\n    );\n  }\n}\n\nexport function createConnectionManager(options: ConnectionManagerOptions): ConnectionManager {\n  return new ConnectionManager(options);\n}\n","import type { Driver } from '../driver/types.js';\nimport type { Branch, BranchRow, CleanupResult } from './types.js';\n\nexport interface CleanupSchedulerOptions {\n  driver: Driver;\n  intervalMs?: number;\n  defaultMaxAgeDays?: number;\n  skipProtected?: boolean;\n  metadataTable?: string;\n  onCleanup?: (result: CleanupResult) => void;\n  onError?: (error: Error) => void;\n}\n\nexport interface CleanupJob {\n  id: string;\n  startedAt: Date;\n  completedAt?: Date;\n  result?: CleanupResult;\n  error?: string;\n}\n\nexport class CleanupScheduler {\n  private driver: Driver;\n  private intervalMs: number;\n  private defaultMaxAgeDays: number;\n  private skipProtected: boolean;\n  private metadataTable: string;\n  private onCleanup?: (result: CleanupResult) => void;\n  private onError?: (error: Error) => void;\n\n  private intervalId: ReturnType<typeof setInterval> | null = null;\n  private isRunning = false;\n  private lastRun: CleanupJob | null = null;\n  private history: CleanupJob[] = [];\n\n  constructor(options: CleanupSchedulerOptions) {\n    this.driver = options.driver;\n    this.intervalMs = options.intervalMs ?? 24 * 60 * 60 * 1000; // 24 hours\n    this.defaultMaxAgeDays = options.defaultMaxAgeDays ?? 7;\n    this.skipProtected = options.skipProtected ?? true;\n    this.metadataTable = options.metadataTable ?? 'lp_branch_metadata';\n    this.onCleanup = options.onCleanup;\n    this.onError = options.onError;\n  }\n\n  start(): void {\n    if (this.intervalId) {\n      return;\n    }\n\n    this.runCleanup().catch((error) => {\n      if (this.onError) {\n        this.onError(error instanceof Error ? error : new Error(String(error)));\n      }\n    });\n\n    this.intervalId = setInterval(() => {\n      this.runCleanup().catch((error) => {\n        if (this.onError) {\n          this.onError(error instanceof Error ? error : new Error(String(error)));\n        }\n      });\n    }, this.intervalMs);\n  }\n\n  stop(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n\n  isScheduled(): boolean {\n    return this.intervalId !== null;\n  }\n\n  isCurrentlyRunning(): boolean {\n    return this.isRunning;\n  }\n\n  getLastRun(): CleanupJob | null {\n    return this.lastRun;\n  }\n\n  getHistory(limit = 10): CleanupJob[] {\n    return this.history.slice(-limit);\n  }\n\n  async runCleanup(options?: {\n    maxAgeDays?: number;\n    dryRun?: boolean;\n  }): Promise<CleanupResult> {\n    if (this.isRunning) {\n      throw new Error('Cleanup is already running');\n    }\n\n    this.isRunning = true;\n    const job: CleanupJob = {\n      id: this.generateJobId(),\n      startedAt: new Date(),\n    };\n\n    try {\n      const result = await this.executeCleanup(options);\n      this.recordSuccess(job, result);\n      return result;\n    } catch (error) {\n      this.recordError(job, error);\n      throw error;\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  private async executeCleanup(options?: {\n    maxAgeDays?: number;\n    dryRun?: boolean;\n  }): Promise<CleanupResult> {\n    const maxAge = options?.maxAgeDays ?? this.defaultMaxAgeDays;\n    const staleBranches = await this.getStaleBranches(maxAge);\n    const deleted: string[] = [];\n    const skipped: string[] = [];\n\n    for (const branch of staleBranches) {\n      if (options?.dryRun) {\n        deleted.push(branch.slug);\n        continue;\n      }\n      await this.tryDeleteBranch(branch, deleted, skipped);\n    }\n\n    return { deleted, skipped };\n  }\n\n  private async tryDeleteBranch(\n    branch: Branch,\n    deleted: string[],\n    skipped: string[]\n  ): Promise<void> {\n    try {\n      await this.deleteBranch(branch);\n      deleted.push(branch.slug);\n    } catch (error) {\n      skipped.push(`${branch.slug}: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  private recordSuccess(job: CleanupJob, result: CleanupResult): void {\n    job.completedAt = new Date();\n    job.result = result;\n    this.lastRun = job;\n    this.history.push(job);\n\n    if (this.history.length > 100) {\n      this.history = this.history.slice(-100);\n    }\n\n    if (this.onCleanup) {\n      this.onCleanup(result);\n    }\n  }\n\n  private recordError(job: CleanupJob, error: unknown): void {\n    job.completedAt = new Date();\n    job.error = error instanceof Error ? error.message : String(error);\n    this.lastRun = job;\n    this.history.push(job);\n\n    if (this.onError) {\n      this.onError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  async getStaleBranches(maxAgeDays: number): Promise<Branch[]> {\n    let sql = `\n      SELECT * FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE deleted_at IS NULL\n        AND last_accessed_at < NOW() - INTERVAL '${maxAgeDays} days'\n        AND status != 'deleting'\n    `;\n\n    if (this.skipProtected) {\n      sql += ` AND is_protected = FALSE AND status != 'protected'`;\n    }\n\n    sql += ' ORDER BY last_accessed_at ASC';\n\n    const result = await this.driver.query<BranchRow>(sql);\n    return result.rows.map((row) => this.mapBranchRow(row));\n  }\n\n  async markAsStale(maxAgeDays: number): Promise<number> {\n    let sql = `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET status = 'stale'\n      WHERE deleted_at IS NULL\n        AND last_accessed_at < NOW() - INTERVAL '${maxAgeDays} days'\n        AND status = 'active'\n    `;\n\n    if (this.skipProtected) {\n      sql += ' AND is_protected = FALSE';\n    }\n\n    const result = await this.driver.execute(sql);\n    return result.rowCount;\n  }\n\n  async getUpcomingCleanups(\n    daysAhead = 7\n  ): Promise<{ branch: Branch; daysUntilCleanup: number }[]> {\n    const sql = `\n      SELECT *,\n        EXTRACT(DAY FROM (last_accessed_at + (auto_delete_days * INTERVAL '1 day') - NOW())) as days_until_cleanup\n      FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE deleted_at IS NULL\n        AND status != 'protected'\n        AND status != 'deleting'\n        AND is_protected = FALSE\n        AND last_accessed_at + (auto_delete_days * INTERVAL '1 day') < NOW() + INTERVAL '${daysAhead} days'\n      ORDER BY days_until_cleanup ASC\n    `;\n\n    const result = await this.driver.query<BranchRow & { days_until_cleanup: string }>(sql);\n\n    return result.rows.map((row) => ({\n      branch: this.mapBranchRow(row),\n      daysUntilCleanup: Number.parseFloat(row.days_until_cleanup),\n    }));\n  }\n\n  private async deleteBranch(branch: Branch): Promise<void> {\n    await this.driver.transaction(async (trx) => {\n      await trx.execute(\n        `\n        UPDATE ${this.quoteIdent(this.metadataTable)}\n        SET status = 'deleting', deleted_at = NOW()\n        WHERE id = $1\n      `,\n        [branch.id]\n      );\n\n      await trx.execute(`DROP SCHEMA IF EXISTS ${this.quoteIdent(branch.schemaName)} CASCADE`);\n\n      await trx.execute(\n        `\n        DELETE FROM ${this.quoteIdent(this.metadataTable)} WHERE id = $1\n      `,\n        [branch.id]\n      );\n    });\n  }\n\n  private generateJobId(): string {\n    return `cleanup_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n  }\n\n  private quoteIdent(identifier: string): string {\n    return `\"${identifier.replace(/\"/g, '\"\"')}\"`;\n  }\n\n  private mapBranchRow(row: BranchRow): Branch {\n    return {\n      id: row.id,\n      name: row.name,\n      slug: row.slug,\n      schemaName: row.schema_name,\n      parentBranchId: row.parent_branch_id,\n      gitBranch: row.git_branch,\n      prNumber: row.pr_number,\n      prUrl: row.pr_url,\n      status: row.status,\n      isProtected: row.is_protected,\n      createdAt: new Date(row.created_at),\n      createdBy: row.created_by,\n      lastAccessedAt: new Date(row.last_accessed_at),\n      deletedAt: row.deleted_at ? new Date(row.deleted_at) : null,\n      migrationCount: row.migration_count,\n      tableCount: row.table_count,\n      storageBytes:\n        typeof row.storage_bytes === 'string'\n          ? Number.parseInt(row.storage_bytes, 10)\n          : row.storage_bytes,\n      autoDeleteDays: row.auto_delete_days,\n      copyData: row.copy_data,\n      piiMasking: row.pii_masking,\n    };\n  }\n}\n\nexport function createCleanupScheduler(options: CleanupSchedulerOptions): CleanupScheduler {\n  return new CleanupScheduler(options);\n}\n"],"mappings":"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","names":["result","result","createMySQLDriver","createSQLiteDriver","join","init_mysql","init_postgresql","init_sqlite","init_mysql","init_postgresql","init_sqlite","trimmed","createHash","readFile","readdir","join","trimmed","createHash","createDriver","createDbClient"]}