{"version":3,"sources":["../src/driver/health.ts","../src/driver/query-tracker.ts","../src/driver/retry.ts","../src/driver/postgresql.ts","../src/driver/mongodb.ts","../src/driver/signal-handler.ts","../src/driver/pool-monitor.ts","../src/driver/mysql.ts","../src/driver/sqlite.ts","../src/driver/index.ts","../src/compiler/mongo.ts","../src/compiler/index.ts","../src/utils/tenant-validation.ts","../src/query-builder/index.ts","../src/migrations/dialects/mysql.ts","../src/migrations/dialects/postgresql.ts","../src/migrations/dialects/sqlite.ts","../src/migrations/dialects/mongodb.ts","../src/migrations/dialects/index.ts","../src/migrations/runner.ts","../src/schema/registry.ts","../src/client.ts","../src/orm/metadata.ts","../src/orm/decorators.ts","../src/orm/entity.ts","../src/orm/schema-extractor.ts","../src/orm/repository.ts","../src/index.ts","../src/migrations/index.ts","../src/modules/registry.ts","../src/modules/collector.ts","../src/schema/index.ts","../src/schema/introspect.ts","../src/schema/diff.ts","../src/schema/sync.ts","../src/schema/sync-metadata.ts","../src/schema/types.ts","../src/remote/client.ts","../src/remote/auth.ts","../src/types/generator.ts","../src/types/hooks-generator.ts","../src/seed/base.ts","../src/seed/loader.ts","../src/seed/sql-adapter.ts","../src/seed/runner.ts","../src/seed/tracker.ts","../src/branch/schema-differ.ts","../src/branch/migration-merger.ts","../src/branch/branch-manager.ts","../src/branch/connection-manager.ts","../src/branch/cleanup-scheduler.ts"],"sourcesContent":["export interface PoolStats {\n  totalConnections: number;\n  activeConnections: number;\n  idleConnections: number;\n  waitingRequests: number;\n  maxConnections: number;\n}\n\nexport interface HealthCheckResult {\n  healthy: boolean;\n  latencyMs: number;\n  lastCheckedAt: Date;\n  error?: string;\n}\n\nexport interface HealthCheckConfig {\n  enabled?: boolean;\n  intervalMs?: number;\n  timeoutMs?: number;\n  onHealthChange?: (healthy: boolean, result: HealthCheckResult) => void;\n}\n\nexport function createHealthCheckResult(\n  healthy: boolean,\n  latencyMs: number,\n  error?: string\n): HealthCheckResult {\n  return {\n    healthy,\n    latencyMs,\n    lastCheckedAt: new Date(),\n    ...(error && { error }),\n  };\n}\n\nexport function getDefaultHealthCheckConfig(\n  overrides?: Partial<HealthCheckConfig>\n): HealthCheckConfig {\n  return {\n    enabled: overrides?.enabled ?? false,\n    intervalMs: overrides?.intervalMs ?? 30000,\n    timeoutMs: overrides?.timeoutMs ?? 5000,\n    onHealthChange: overrides?.onHealthChange,\n  };\n}\n","export interface QueryInfo {\n  id: string;\n  query: string;\n  startedAt: Date;\n  backendPid?: number;\n}\n\nexport class QueryTracker {\n  private activeQueries = new Map<string, QueryInfo>();\n  private completedCount = 0;\n  private cancelledCount = 0;\n  private draining = false;\n  private drainResolve: (() => void) | null = null;\n\n  trackQuery(id: string, query: string, backendPid?: number): void {\n    if (this.draining) {\n      throw new Error('Driver is draining - new queries are not accepted');\n    }\n    this.activeQueries.set(id, {\n      id,\n      query: query.slice(0, 200),\n      startedAt: new Date(),\n      backendPid,\n    });\n  }\n\n  untrackQuery(id: string): void {\n    if (this.activeQueries.delete(id)) {\n      this.completedCount++;\n      if (this.draining && this.activeQueries.size === 0 && this.drainResolve) {\n        this.drainResolve();\n      }\n    }\n  }\n\n  getActiveCount(): number {\n    return this.activeQueries.size;\n  }\n\n  getActiveQueries(): QueryInfo[] {\n    return Array.from(this.activeQueries.values());\n  }\n\n  async startDrain(timeoutMs: number): Promise<{ timedOut: boolean }> {\n    this.draining = true;\n\n    if (this.activeQueries.size === 0) {\n      return { timedOut: false };\n    }\n\n    const drainPromise = new Promise<void>((resolve) => {\n      this.drainResolve = resolve;\n    });\n\n    const timeoutPromise = new Promise<'timeout'>((resolve) => {\n      setTimeout(() => resolve('timeout'), timeoutMs);\n    });\n\n    const result = await Promise.race([\n      drainPromise.then(() => 'drained' as const),\n      timeoutPromise,\n    ]);\n\n    return { timedOut: result === 'timeout' };\n  }\n\n  markCancelled(id: string): void {\n    if (this.activeQueries.delete(id)) {\n      this.cancelledCount++;\n      if (this.draining && this.activeQueries.size === 0 && this.drainResolve) {\n        this.drainResolve();\n      }\n    }\n  }\n\n  getStats(): { completed: number; cancelled: number; active: number } {\n    return {\n      completed: this.completedCount,\n      cancelled: this.cancelledCount,\n      active: this.activeQueries.size,\n    };\n  }\n\n  isDraining(): boolean {\n    return this.draining;\n  }\n\n  reset(): void {\n    this.activeQueries.clear();\n    this.completedCount = 0;\n    this.cancelledCount = 0;\n    this.draining = false;\n    this.drainResolve = null;\n  }\n}\n","export interface RetryConfig {\n  maxRetries?: number;\n  baseDelayMs?: number;\n  maxDelayMs?: number;\n  retryableErrors?: string[];\n}\n\nconst DEFAULT_RETRYABLE_ERRORS = [\n  'ECONNREFUSED',\n  'ETIMEDOUT',\n  'ECONNRESET',\n  'EPIPE',\n  'ENOTCONN',\n  '57P01',\n  '57P02',\n  '57P03',\n  'PROTOCOL_CONNECTION_LOST',\n  'ER_CON_COUNT_ERROR',\n];\n\nexport function isRetryableError(error: unknown, customErrors: string[] = []): boolean {\n  const allErrors = [...DEFAULT_RETRYABLE_ERRORS, ...customErrors];\n\n  if (error instanceof Error) {\n    const errorCode = (error as Error & { code?: string }).code;\n    const errorMessage = error.message;\n\n    return allErrors.some((code) => errorCode === code || errorMessage.includes(code));\n  }\n  return false;\n}\n\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  config: RetryConfig = {}\n): Promise<T> {\n  const maxRetries = config.maxRetries ?? 3;\n  const baseDelayMs = config.baseDelayMs ?? 100;\n  const maxDelayMs = config.maxDelayMs ?? 5000;\n  const retryableErrors = config.retryableErrors ?? [];\n\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === maxRetries || !isRetryableError(error, retryableErrors)) {\n        throw error;\n      }\n\n      const delay = Math.min(baseDelayMs * 2 ** attempt, maxDelayMs);\n      const jitter = Math.random() * delay * 0.1;\n\n      console.warn(\n        `[db-engine] Connection error (attempt ${attempt + 1}/${maxRetries + 1}), retrying in ${Math.round(delay)}ms:`,\n        lastError.message\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, delay + jitter));\n    }\n  }\n\n  throw lastError;\n}\n\nexport function createTimeoutPromise<T>(timeoutMs: number): Promise<T> {\n  return new Promise((_, reject) =>\n    setTimeout(() => reject(new Error('Health check timeout')), timeoutMs)\n  );\n}\n","import postgres, { type ParameterOrJSON } from 'postgres';\nimport type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport { createTimeoutPromise } from './retry.js';\nimport type {\n  DrainOptions,\n  DrainResult,\n  Driver,\n  DriverConfig,\n  TransactionClient,\n} from './types.js';\n\nexport function createPostgresDriver(config: DriverConfig): Driver {\n  const sql = postgres(config.connectionString, {\n    max: config.max ?? 20,\n    idle_timeout: config.idleTimeout ?? 30,\n    connect_timeout: config.connectTimeout ?? 10,\n    prepare: true,\n  });\n\n  const maxConnections = config.max ?? 20;\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `pg-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      await Promise.race([\n        sql`SELECT 1`,\n        createTimeoutPromise<never>(healthCheckConfig.timeoutMs ?? 5000),\n      ]);\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'postgresql',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const result = await sql.unsafe<T[]>(queryText, params as ParameterOrJSON<never>[]);\n        return {\n          rows: result as T[],\n          rowCount: result.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const result = await sql.unsafe(queryText, params as ParameterOrJSON<never>[]);\n        return { rowCount: result.count ?? 0 };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      try {\n        const result = await sql.begin(async (tx) => {\n          const client: TransactionClient = {\n            async query<R = Record<string, unknown>>(\n              queryText: string,\n              params: unknown[] = []\n            ): Promise<QueryResult<R>> {\n              const txResult = await tx.unsafe<R[]>(queryText, params as ParameterOrJSON<never>[]);\n              return {\n                rows: txResult as R[],\n                rowCount: txResult.length,\n              };\n            },\n\n            async execute(\n              queryText: string,\n              params: unknown[] = []\n            ): Promise<{ rowCount: number }> {\n              const txResult = await tx.unsafe(queryText, params as ParameterOrJSON<never>[]);\n              return { rowCount: txResult.count ?? 0 };\n            },\n          };\n\n          return fn(client);\n        });\n        return result as T;\n      } finally {\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n      const forceCancelOnTimeout = options.forceCancelOnTimeout ?? true;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut && forceCancelOnTimeout) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, cancelling ${activeQueries.length} queries`);\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          try {\n            await sql.unsafe(\n              `SELECT pg_cancel_backend(pid) FROM pg_stat_activity\n               WHERE state = 'active' AND query LIKE $1`,\n              [`%${query.query.slice(0, 50)}%`]\n            );\n            tracker.markCancelled(query.id);\n            cancelledQueries++;\n          } catch (e) {\n            console.warn(`[db-engine] Failed to cancel query ${query.id}:`, e);\n          }\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connections');\n      await sql.end();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await sql.end();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: maxConnections,\n        activeConnections: (sql as unknown as { connections?: number }).connections ?? 0,\n        idleConnections:\n          maxConnections - ((sql as unknown as { connections?: number }).connections ?? 0),\n        waitingRequests: 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n","import type { MongoOperation, QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport type {\n  DrainOptions,\n  DrainResult,\n  Driver,\n  DriverConfig,\n  TransactionClient,\n} from './types.js';\n\nlet mongodbModule: typeof import('mongodb') | null = null;\n\nasync function getMongoDBModule(): Promise<typeof import('mongodb')> {\n  if (!mongodbModule) {\n    try {\n      mongodbModule = await import('mongodb');\n    } catch {\n      throw new Error(\n        'MongoDB driver not found. Please install mongodb package: npm install mongodb'\n      );\n    }\n  }\n  return mongodbModule;\n}\n\nexport interface MongoDriverConfig extends DriverConfig {\n  database?: string;\n}\n\nexport interface MongoDriver extends Driver {\n  executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>>;\n  getDb(): unknown;\n  collection(name: string): unknown;\n}\n\nexport async function createMongoDriver(config: MongoDriverConfig): Promise<MongoDriver> {\n  const mongodb = await getMongoDBModule();\n  const { MongoClient } = mongodb;\n\n  const maxConnections = config.max ?? 10;\n\n  const client = new MongoClient(config.connectionString, {\n    maxPoolSize: maxConnections,\n    serverSelectionTimeoutMS: config.connectTimeout ?? 5000,\n    maxIdleTimeMS: config.idleTimeout ?? 30000,\n  });\n\n  await client.connect();\n  const db = client.db(config.database);\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `mongo-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      await db.command({ ping: 1 });\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  async function executeOperation<T = Record<string, unknown>>(\n    op: MongoOperation\n  ): Promise<QueryResult<T>> {\n    const queryId = generateQueryId();\n    tracker.trackQuery(queryId, `${op.type}:${op.collection}`);\n\n    try {\n      const collection = db.collection(op.collection);\n\n      switch (op.type) {\n        case 'find': {\n          let cursor = collection.find(op.filter ?? {});\n          if (op.options?.sort) cursor = cursor.sort(op.options.sort);\n          if (op.options?.skip) cursor = cursor.skip(op.options.skip);\n          if (op.options?.limit) cursor = cursor.limit(op.options.limit);\n          if (op.options?.projection) cursor = cursor.project(op.options.projection);\n          const rows = await cursor.toArray();\n          return { rows: rows as T[], rowCount: rows.length };\n        }\n\n        case 'aggregate': {\n          const result = await collection.aggregate(op.pipeline!).toArray();\n          return { rows: result as T[], rowCount: result.length };\n        }\n\n        case 'insertOne': {\n          const result = await collection.insertOne(op.document!);\n          const doc = { ...op.document, _id: result.insertedId } as T;\n          return { rows: [doc], rowCount: 1 };\n        }\n\n        case 'insertMany': {\n          const result = await collection.insertMany(op.documents!);\n          return { rows: op.documents as T[], rowCount: result.insertedCount };\n        }\n\n        case 'updateOne': {\n          const result = await collection.updateOne(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'updateMany': {\n          const result = await collection.updateMany(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'deleteOne': {\n          const result = await collection.deleteOne(op.filter!);\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'deleteMany': {\n          const result = await collection.deleteMany(op.filter!);\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'findOneAndUpdate': {\n          const result = await collection.findOneAndUpdate(op.filter!, op.update!, {\n            returnDocument: op.options?.returnDocument ?? 'after',\n            upsert: op.options?.upsert,\n            projection: op.options?.projection,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'findOneAndDelete': {\n          const result = await collection.findOneAndDelete(op.filter!, {\n            projection: op.options?.projection,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'countDocuments': {\n          const count = await collection.countDocuments(op.filter ?? {});\n          return { rows: [{ count } as T], rowCount: 1 };\n        }\n\n        default:\n          throw new Error(`Unsupported MongoDB operation: ${(op as MongoOperation).type}`);\n      }\n    } finally {\n      tracker.untrackQuery(queryId);\n    }\n  }\n\n  async function executeOperationWithSession<T = Record<string, unknown>>(\n    op: MongoOperation,\n    session: import('mongodb').ClientSession\n  ): Promise<QueryResult<T>> {\n    const queryId = generateQueryId();\n    tracker.trackQuery(queryId, `${op.type}:${op.collection}`);\n\n    try {\n      const collection = db.collection(op.collection);\n\n      switch (op.type) {\n        case 'find': {\n          let cursor = collection.find(op.filter ?? {}, { session });\n          if (op.options?.sort) cursor = cursor.sort(op.options.sort);\n          if (op.options?.skip) cursor = cursor.skip(op.options.skip);\n          if (op.options?.limit) cursor = cursor.limit(op.options.limit);\n          if (op.options?.projection) cursor = cursor.project(op.options.projection);\n          const rows = await cursor.toArray();\n          return { rows: rows as T[], rowCount: rows.length };\n        }\n\n        case 'aggregate': {\n          const result = await collection.aggregate(op.pipeline!, { session }).toArray();\n          return { rows: result as T[], rowCount: result.length };\n        }\n\n        case 'insertOne': {\n          const result = await collection.insertOne(op.document!, { session });\n          const doc = { ...op.document, _id: result.insertedId } as T;\n          return { rows: [doc], rowCount: 1 };\n        }\n\n        case 'insertMany': {\n          const result = await collection.insertMany(op.documents!, { session });\n          return { rows: op.documents as T[], rowCount: result.insertedCount };\n        }\n\n        case 'updateOne': {\n          const result = await collection.updateOne(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n            session,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'updateMany': {\n          const result = await collection.updateMany(op.filter!, op.update!, {\n            upsert: op.options?.upsert,\n            session,\n          });\n          return { rows: [], rowCount: result.modifiedCount };\n        }\n\n        case 'deleteOne': {\n          const result = await collection.deleteOne(op.filter!, { session });\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'deleteMany': {\n          const result = await collection.deleteMany(op.filter!, { session });\n          return { rows: [], rowCount: result.deletedCount };\n        }\n\n        case 'findOneAndUpdate': {\n          const result = await collection.findOneAndUpdate(op.filter!, op.update!, {\n            returnDocument: op.options?.returnDocument ?? 'after',\n            upsert: op.options?.upsert,\n            projection: op.options?.projection,\n            session,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'findOneAndDelete': {\n          const result = await collection.findOneAndDelete(op.filter!, {\n            projection: op.options?.projection,\n            session,\n          });\n          return { rows: result ? [result as T] : [], rowCount: result ? 1 : 0 };\n        }\n\n        case 'countDocuments': {\n          const count = await collection.countDocuments(op.filter ?? {}, { session });\n          return { rows: [{ count } as T], rowCount: 1 };\n        }\n\n        default:\n          throw new Error(`Unsupported MongoDB operation: ${(op as MongoOperation).type}`);\n      }\n    } finally {\n      tracker.untrackQuery(queryId);\n    }\n  }\n\n  const driver: MongoDriver = {\n    dialect: 'mongodb',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      _sql: string,\n      _params?: unknown[]\n    ): Promise<QueryResult<T>> {\n      throw new Error(\n        'MongoDriver does not support SQL queries. Use executeOperation() with MongoOperation instead.'\n      );\n    },\n\n    async execute(_sql: string, _params?: unknown[]): Promise<{ rowCount: number }> {\n      throw new Error(\n        'MongoDriver does not support SQL execution. Use executeOperation() with MongoOperation instead.'\n      );\n    },\n\n    async transaction<T>(fn: (trx: MongoTransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const session = client.startSession();\n      try {\n        session.startTransaction();\n        const trxClient = new MongoTransactionClientImpl(session, executeOperationWithSession);\n        const result = await fn(trxClient);\n        await session.commitTransaction();\n        return result;\n      } catch (error) {\n        await session.abortTransaction();\n        throw error;\n      } finally {\n        await session.endSession();\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, ${activeQueries.length} queries still active`);\n        cancelledQueries = activeQueries.length;\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          tracker.markCancelled(query.id);\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connection');\n      await client.close(true);\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await client.close();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: maxConnections,\n        activeConnections: 0,\n        idleConnections: maxConnections,\n        waitingRequests: 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n\n    executeOperation,\n\n    getDb() {\n      return db;\n    },\n\n    collection(name: string) {\n      return db.collection(name);\n    },\n  };\n\n  return driver;\n}\n\nexport interface MongoTransactionClient extends TransactionClient {\n  executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>>;\n}\n\nclass MongoTransactionClientImpl implements MongoTransactionClient {\n  constructor(\n    private session: import('mongodb').ClientSession,\n    private execWithSession: <T>(\n      op: MongoOperation,\n      session: import('mongodb').ClientSession\n    ) => Promise<QueryResult<T>>\n  ) {}\n\n  async query<T = Record<string, unknown>>(\n    _sql: string,\n    _params?: unknown[]\n  ): Promise<QueryResult<T>> {\n    throw new Error('MongoTransactionClient does not support SQL queries.');\n  }\n\n  async execute(_sql: string, _params?: unknown[]): Promise<{ rowCount: number }> {\n    throw new Error('MongoTransactionClient does not support SQL execution.');\n  }\n\n  async executeOperation<T = Record<string, unknown>>(op: MongoOperation): Promise<QueryResult<T>> {\n    return this.execWithSession<T>(op, this.session);\n  }\n}\n\nexport function isMongoDriver(driver: Driver): driver is MongoDriver {\n  return driver.dialect === 'mongodb' && 'executeOperation' in driver;\n}\n","import type { DrainResult, Driver } from './types.js';\n\nexport interface SignalHandlerOptions {\n  timeout?: number;\n  exitCodeSuccess?: number;\n  exitCodeForced?: number;\n  autoExit?: boolean;\n  onShutdownStart?: () => void;\n  onShutdownComplete?: (result: DrainResult) => void;\n}\n\nexport function registerSignalHandlers(\n  driver: Driver,\n  options: SignalHandlerOptions = {}\n): () => void {\n  const {\n    timeout = 30000,\n    exitCodeSuccess = 0,\n    exitCodeForced = 1,\n    autoExit = true,\n    onShutdownStart,\n    onShutdownComplete,\n  } = options;\n\n  let shuttingDown = false;\n\n  const handleSignal = async (signal: string) => {\n    if (shuttingDown) {\n      console.log(`[db-engine] Already shutting down, ignoring ${signal}`);\n      return;\n    }\n\n    shuttingDown = true;\n    console.log(`[db-engine] Received ${signal}, starting graceful shutdown`);\n    onShutdownStart?.();\n\n    try {\n      const result = await driver.drainAndClose({\n        timeout,\n        onProgress: (progress) => {\n          console.log(\n            `[db-engine] Shutdown progress: ${progress.phase} - ` +\n              `${progress.activeQueries} active, ${progress.completedQueries} completed`\n          );\n        },\n      });\n\n      onShutdownComplete?.(result);\n\n      if (autoExit) {\n        const exitCode = result.cancelledQueries > 0 ? exitCodeForced : exitCodeSuccess;\n        process.exit(exitCode);\n      }\n    } catch (error) {\n      console.error('[db-engine] Error during shutdown:', error);\n      if (autoExit) {\n        process.exit(1);\n      }\n    }\n  };\n\n  const sigterm = () => {\n    handleSignal('SIGTERM');\n  };\n  const sigint = () => {\n    handleSignal('SIGINT');\n  };\n\n  process.on('SIGTERM', sigterm);\n  process.on('SIGINT', sigint);\n\n  return () => {\n    process.off('SIGTERM', sigterm);\n    process.off('SIGINT', sigint);\n  };\n}\n","import type { PoolStats } from './health.js';\n\nexport interface PoolMonitorConfig {\n  warningThreshold?: number;\n  criticalThreshold?: number;\n  checkIntervalMs?: number;\n  onWarning?: (stats: PoolStats) => void;\n  onCritical?: (stats: PoolStats) => void;\n  onRecovery?: (stats: PoolStats) => void;\n}\n\nexport interface PoolMonitor {\n  start(): void;\n  stop(): void;\n  getLastLevel(): 'normal' | 'warning' | 'critical';\n}\n\nexport function createPoolMonitor(\n  getStats: () => PoolStats,\n  config: PoolMonitorConfig = {}\n): PoolMonitor {\n  const warningThreshold = config.warningThreshold ?? 0.8;\n  const criticalThreshold = config.criticalThreshold ?? 0.95;\n  const checkIntervalMs = config.checkIntervalMs ?? 10000;\n\n  let interval: ReturnType<typeof setInterval> | null = null;\n  let lastLevel: 'normal' | 'warning' | 'critical' = 'normal';\n\n  function checkPool(): void {\n    const stats = getStats();\n    if (stats.maxConnections === 0) return;\n\n    const utilization = stats.activeConnections / stats.maxConnections;\n\n    if (utilization >= criticalThreshold && lastLevel !== 'critical') {\n      lastLevel = 'critical';\n      console.error(\n        `[db-engine] CRITICAL: Pool exhaustion imminent (${(utilization * 100).toFixed(1)}% utilized)`,\n        stats\n      );\n      config.onCritical?.(stats);\n    } else if (\n      utilization >= warningThreshold &&\n      utilization < criticalThreshold &&\n      lastLevel === 'normal'\n    ) {\n      lastLevel = 'warning';\n      console.warn(\n        `[db-engine] WARNING: High pool utilization (${(utilization * 100).toFixed(1)}%)`,\n        stats\n      );\n      config.onWarning?.(stats);\n    } else if (utilization < warningThreshold && lastLevel !== 'normal') {\n      lastLevel = 'normal';\n      console.info(\n        `[db-engine] Pool utilization returned to normal (${(utilization * 100).toFixed(1)}%)`\n      );\n      config.onRecovery?.(stats);\n    }\n  }\n\n  return {\n    start(): void {\n      if (interval) return;\n      interval = setInterval(checkPool, checkIntervalMs);\n      checkPool();\n    },\n\n    stop(): void {\n      if (interval) {\n        clearInterval(interval);\n        interval = null;\n      }\n    },\n\n    getLastLevel(): 'normal' | 'warning' | 'critical' {\n      return lastLevel;\n    },\n  };\n}\n","import type { PoolConnection } from 'mysql2/promise';\nimport type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport { createTimeoutPromise } from './retry.js';\nimport type {\n  DrainOptions,\n  DrainResult,\n  Driver,\n  DriverConfig,\n  TransactionClient,\n} from './types.js';\n\nexport async function createMySQLDriver(config: DriverConfig): Promise<Driver> {\n  const mysql = await import('mysql2/promise');\n\n  const pool = mysql.createPool({\n    uri: config.connectionString,\n    waitForConnections: true,\n    connectionLimit: config.max ?? 20,\n    idleTimeout: (config.idleTimeout ?? 30) * 1000,\n    connectTimeout: (config.connectTimeout ?? 10) * 1000,\n  });\n\n  const maxConnections = config.max ?? 20;\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `mysql-${++queryIdCounter}`;\n\n  async function performHealthCheck(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    try {\n      const connection = (await Promise.race([\n        pool.getConnection(),\n        createTimeoutPromise<never>(healthCheckConfig.timeoutMs ?? 5000),\n      ])) as PoolConnection;\n\n      await connection.ping();\n      connection.release();\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'mysql',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const [rows] = await pool.execute(queryText, params);\n        const resultRows = Array.isArray(rows) ? rows : [];\n        return {\n          rows: resultRows as T[],\n          rowCount: resultRows.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const [result] = await pool.execute(queryText, params);\n        const affectedRows = (result as { affectedRows?: number }).affectedRows ?? 0;\n        return { rowCount: affectedRows };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const connection = await pool.getConnection();\n      await connection.beginTransaction();\n\n      try {\n        const client: TransactionClient = {\n          async query<R = Record<string, unknown>>(\n            queryText: string,\n            params: unknown[] = []\n          ): Promise<QueryResult<R>> {\n            const [rows] = await connection.execute(queryText, params);\n            const resultRows = Array.isArray(rows) ? rows : [];\n            return {\n              rows: resultRows as R[],\n              rowCount: resultRows.length,\n            };\n          },\n\n          async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n            const [result] = await connection.execute(queryText, params);\n            const affectedRows = (result as { affectedRows?: number }).affectedRows ?? 0;\n            return { rowCount: affectedRows };\n          },\n        };\n\n        const result = await fn(client);\n        await connection.commit();\n        return result;\n      } catch (error) {\n        await connection.rollback();\n        throw error;\n      } finally {\n        connection.release();\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n      const timeout = options.timeout ?? 30000;\n      const forceCancelOnTimeout = options.forceCancelOnTimeout ?? true;\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      const { timedOut } = await tracker.startDrain(timeout);\n      let cancelledQueries = 0;\n\n      if (timedOut && forceCancelOnTimeout) {\n        const activeQueries = tracker.getActiveQueries();\n        console.log(`[db-engine] Timeout reached, cancelling ${activeQueries.length} queries`);\n\n        options.onProgress?.({\n          phase: 'cancelling',\n          activeQueries: activeQueries.length,\n          completedQueries: tracker.getStats().completed,\n          cancelledQueries: 0,\n          elapsedMs: Date.now() - startTime,\n        });\n\n        for (const query of activeQueries) {\n          if (query.backendPid) {\n            try {\n              await pool.execute(`KILL QUERY ${query.backendPid}`);\n              tracker.markCancelled(query.id);\n              cancelledQueries++;\n            } catch (e) {\n              console.warn(`[db-engine] Failed to cancel query ${query.id}:`, e);\n            }\n          } else {\n            tracker.markCancelled(query.id);\n            cancelledQueries++;\n          }\n        }\n      }\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connections');\n      await pool.end();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      await pool.end();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      const poolState = (pool as unknown as { pool?: MySQLPoolState }).pool;\n      return {\n        totalConnections: poolState?._allConnections?.length ?? 0,\n        activeConnections: poolState?._acquiringConnections?.length ?? 0,\n        idleConnections: poolState?._freeConnections?.length ?? 0,\n        waitingRequests: poolState?._connectionQueue?.length ?? 0,\n        maxConnections,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n\ninterface MySQLPoolState {\n  _allConnections?: unknown[];\n  _acquiringConnections?: unknown[];\n  _freeConnections?: unknown[];\n  _connectionQueue?: unknown[];\n}\n","import type { QueryResult } from '../types/index.js';\nimport {\n  type HealthCheckResult,\n  type PoolStats,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\nimport { QueryTracker } from './query-tracker.js';\nimport type {\n  DrainOptions,\n  DrainResult,\n  Driver,\n  DriverConfig,\n  TransactionClient,\n} from './types.js';\n\nexport async function createSQLiteDriver(config: DriverConfig): Promise<Driver> {\n  const Database = (await import('better-sqlite3')).default;\n\n  const dbPath = config.connectionString.replace('sqlite://', '').replace('file://', '');\n  const db = new Database(dbPath);\n\n  db.pragma('journal_mode = WAL');\n  db.pragma('foreign_keys = ON');\n\n  let lastHealthCheck: HealthCheckResult = createHealthCheckResult(true, 0);\n  let healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n\n  const healthCheckConfig = getDefaultHealthCheckConfig(config.healthCheck);\n\n  const tracker = new QueryTracker();\n  let queryIdCounter = 0;\n  let draining = false;\n\n  const generateQueryId = () => `sqlite-${++queryIdCounter}`;\n\n  function performHealthCheck(): HealthCheckResult {\n    const startTime = Date.now();\n    try {\n      db.prepare('SELECT 1').get();\n\n      const result = createHealthCheckResult(true, Date.now() - startTime);\n\n      if (!lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(true, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    } catch (error) {\n      const result = createHealthCheckResult(\n        false,\n        Date.now() - startTime,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n\n      if (lastHealthCheck.healthy && healthCheckConfig.onHealthChange) {\n        healthCheckConfig.onHealthChange(false, result);\n      }\n\n      lastHealthCheck = result;\n      return result;\n    }\n  }\n\n  return {\n    dialect: 'sqlite',\n    connectionString: config.connectionString,\n\n    get isDraining() {\n      return draining;\n    },\n\n    async query<T = Record<string, unknown>>(\n      queryText: string,\n      params: unknown[] = []\n    ): Promise<QueryResult<T>> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const stmt = db.prepare(queryText);\n        const rows = stmt.all(...params) as T[];\n        return {\n          rows,\n          rowCount: rows.length,\n        };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n      const queryId = generateQueryId();\n      tracker.trackQuery(queryId, queryText);\n\n      try {\n        const stmt = db.prepare(queryText);\n        const result = stmt.run(...params);\n        return { rowCount: result.changes };\n      } finally {\n        tracker.untrackQuery(queryId);\n      }\n    },\n\n    async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n      const txQueryId = generateQueryId();\n      tracker.trackQuery(txQueryId, 'TRANSACTION');\n\n      const client: TransactionClient = {\n        async query<R = Record<string, unknown>>(\n          queryText: string,\n          params: unknown[] = []\n        ): Promise<QueryResult<R>> {\n          const stmt = db.prepare(queryText);\n          const rows = stmt.all(...params) as R[];\n          return {\n            rows,\n            rowCount: rows.length,\n          };\n        },\n\n        async execute(queryText: string, params: unknown[] = []): Promise<{ rowCount: number }> {\n          const stmt = db.prepare(queryText);\n          const result = stmt.run(...params);\n          return { rowCount: result.changes };\n        },\n      };\n\n      let result: T;\n      let committed = false;\n\n      db.prepare('BEGIN IMMEDIATE').run();\n      try {\n        result = await fn(client);\n        db.prepare('COMMIT').run();\n        committed = true;\n        return result;\n      } catch (error) {\n        if (!committed) {\n          db.prepare('ROLLBACK').run();\n        }\n        throw error;\n      } finally {\n        tracker.untrackQuery(txQueryId);\n      }\n    },\n\n    getActiveQueryCount(): number {\n      return tracker.getActiveCount();\n    },\n\n    async drainAndClose(options: DrainOptions = {}): Promise<DrainResult> {\n      const startTime = Date.now();\n\n      draining = true;\n      const initialActive = tracker.getActiveCount();\n\n      options.onProgress?.({\n        phase: 'draining',\n        activeQueries: initialActive,\n        completedQueries: 0,\n        cancelledQueries: 0,\n        elapsedMs: 0,\n      });\n\n      console.log(`[db-engine] Starting graceful shutdown with ${initialActive} active queries`);\n\n      options.onProgress?.({\n        phase: 'closing',\n        activeQueries: 0,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries: 0,\n        elapsedMs: Date.now() - startTime,\n      });\n\n      console.log('[db-engine] Closing database connection');\n      db.close();\n\n      const result: DrainResult = {\n        success: true,\n        completedQueries: tracker.getStats().completed,\n        cancelledQueries: 0,\n        elapsedMs: Date.now() - startTime,\n      };\n\n      options.onProgress?.({\n        phase: 'complete',\n        activeQueries: 0,\n        completedQueries: result.completedQueries,\n        cancelledQueries: result.cancelledQueries,\n        elapsedMs: result.elapsedMs,\n      });\n\n      console.log(`[db-engine] Shutdown complete in ${result.elapsedMs}ms`);\n      return result;\n    },\n\n    async close(): Promise<void> {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n      db.close();\n    },\n\n    async healthCheck(): Promise<HealthCheckResult> {\n      return performHealthCheck();\n    },\n\n    getPoolStats(): PoolStats {\n      return {\n        totalConnections: 1,\n        activeConnections: lastHealthCheck.healthy ? 1 : 0,\n        idleConnections: 0,\n        waitingRequests: 0,\n        maxConnections: 1,\n      };\n    },\n\n    isHealthy(): boolean {\n      return lastHealthCheck.healthy;\n    },\n\n    startHealthChecks(): void {\n      if (healthCheckInterval) return;\n      healthCheckInterval = setInterval(performHealthCheck, healthCheckConfig.intervalMs ?? 30000);\n      performHealthCheck();\n    },\n\n    stopHealthChecks(): void {\n      if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n      }\n    },\n  };\n}\n","import type { DialectName } from '../types/index.js';\nimport { createPostgresDriver } from './postgresql.js';\nimport type { Driver, DriverConfig } from './types.js';\n\nexport type {\n  Driver,\n  DriverConfig,\n  TransactionClient,\n  DrainOptions,\n  DrainProgress,\n  DrainResult,\n  DrainPhase,\n} from './types.js';\nexport type { MongoDriver, MongoDriverConfig, MongoTransactionClient } from './mongodb.js';\nexport { createMongoDriver, isMongoDriver } from './mongodb.js';\nexport { QueryTracker, type QueryInfo } from './query-tracker.js';\nexport { registerSignalHandlers, type SignalHandlerOptions } from './signal-handler.js';\n\nexport type {\n  PoolStats,\n  HealthCheckResult,\n  HealthCheckConfig,\n} from './health.js';\nexport {\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n} from './health.js';\n\nexport type { PoolMonitorConfig, PoolMonitor } from './pool-monitor.js';\nexport { createPoolMonitor } from './pool-monitor.js';\n\nexport type { RetryConfig } from './retry.js';\nexport { isRetryableError, withRetry, createTimeoutPromise } from './retry.js';\n\nexport interface CreateDriverOptions extends DriverConfig {\n  dialect?: DialectName;\n  database?: string;\n}\n\nexport function detectDialect(connectionString: string): DialectName {\n  if (connectionString.startsWith('mongodb://') || connectionString.startsWith('mongodb+srv://')) {\n    return 'mongodb';\n  }\n  if (connectionString.startsWith('postgres://') || connectionString.startsWith('postgresql://')) {\n    return 'postgresql';\n  }\n  if (connectionString.startsWith('mysql://') || connectionString.startsWith('mariadb://')) {\n    return 'mysql';\n  }\n  if (\n    connectionString.startsWith('sqlite://') ||\n    connectionString.startsWith('file://') ||\n    connectionString.endsWith('.db') ||\n    connectionString.endsWith('.sqlite') ||\n    connectionString.endsWith('.sqlite3')\n  ) {\n    return 'sqlite';\n  }\n  throw new Error(`Unable to detect database dialect from connection string: ${connectionString}`);\n}\n\nexport async function createDriver(options: CreateDriverOptions): Promise<Driver> {\n  const dialect = options.dialect ?? detectDialect(options.connectionString);\n\n  switch (dialect) {\n    case 'postgresql':\n      return createPostgresDriver(options);\n\n    case 'mysql': {\n      const { createMySQLDriver } = await import('./mysql.js');\n      return createMySQLDriver(options);\n    }\n\n    case 'sqlite': {\n      const { createSQLiteDriver } = await import('./sqlite.js');\n      return createSQLiteDriver(options);\n    }\n\n    case 'mongodb': {\n      const { createMongoDriver } = await import('./mongodb.js');\n      return createMongoDriver(options);\n    }\n\n    default:\n      throw new Error(`Unsupported dialect: ${dialect}`);\n  }\n}\n","import type {\n  MongoOperation,\n  Operator,\n  QueryAST,\n  TenantContext,\n  WhereClause,\n} from '../types/index.js';\n\nexport interface MongoCompilerOptions {\n  injectTenant?: boolean;\n  tenantColumns?: {\n    appId: string;\n    organizationId: string;\n  };\n}\n\nconst DEFAULT_TENANT_COLUMNS = {\n  appId: 'app_id',\n  organizationId: 'organization_id',\n};\n\nexport class MongoCompiler {\n  private injectTenant: boolean;\n  private tenantColumns: { appId: string; organizationId: string };\n\n  constructor(options: MongoCompilerOptions = {}) {\n    this.injectTenant = options.injectTenant ?? true;\n    this.tenantColumns = options.tenantColumns ?? DEFAULT_TENANT_COLUMNS;\n  }\n\n  compile(ast: QueryAST, ctx?: TenantContext): MongoOperation {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    switch (ast.type) {\n      case 'select':\n        return this.compileSelect(ast, ctx);\n      case 'insert':\n        return this.compileInsert(ast, ctx);\n      case 'update':\n        return this.compileUpdate(ast, ctx);\n      case 'delete':\n        return this.compileDelete(ast, ctx);\n      default:\n        throw new Error(`Unsupported query type: ${(ast as QueryAST).type}`);\n    }\n  }\n\n  private compileSelect(ast: QueryAST, ctx?: TenantContext): MongoOperation {\n    const hasJoins = ast.joins && ast.joins.length > 0;\n    const hasGroupBy = ast.groupBy && ast.groupBy.columns.length > 0;\n    const hasHaving = ast.having && ast.having.length > 0;\n\n    if (hasJoins || hasGroupBy || hasHaving) {\n      return this.compileSelectAggregate(ast, ctx);\n    }\n\n    return this.compileSelectFind(ast, ctx);\n  }\n\n  private compileSelectFind(ast: QueryAST, ctx?: TenantContext): MongoOperation {\n    const filter = this.buildFilter(ast.where, ctx);\n    const options: MongoOperation['options'] = {};\n\n    if (ast.columns && !ast.columns.includes('*')) {\n      const hasCountColumn = ast.columns.some((c) => c.toLowerCase().startsWith('count('));\n      if (hasCountColumn) {\n        return {\n          type: 'countDocuments',\n          collection: ast.table,\n          filter,\n        };\n      }\n\n      options.projection = {} as Record<string, 0 | 1>;\n      for (const col of ast.columns) {\n        (options.projection as Record<string, 1>)[col] = 1;\n      }\n    }\n\n    if (ast.orderBy) {\n      options.sort = {\n        [ast.orderBy.column]: ast.orderBy.direction === 'desc' ? -1 : 1,\n      } as Record<string, 1 | -1>;\n    }\n\n    if (ast.offset !== undefined) options.skip = ast.offset;\n    if (ast.limit !== undefined) options.limit = ast.limit;\n\n    return {\n      type: 'find',\n      collection: ast.table,\n      filter,\n      options: Object.keys(options).length > 0 ? options : undefined,\n    };\n  }\n\n  private compileSelectAggregate(ast: QueryAST, ctx?: TenantContext): MongoOperation {\n    const pipeline: Record<string, unknown>[] = [];\n\n    const filter = this.buildFilter(ast.where, ctx);\n    if (Object.keys(filter).length > 0) {\n      pipeline.push({ $match: filter });\n    }\n\n    if (ast.joins) {\n      for (const join of ast.joins) {\n        const leftCol = join.on.leftColumn.split('.').pop()!;\n        const rightCol = join.on.rightColumn.split('.').pop()!;\n\n        pipeline.push({\n          $lookup: {\n            from: join.table,\n            localField: leftCol,\n            foreignField: rightCol,\n            as: join.alias ?? join.table,\n          },\n        });\n\n        if (join.type === 'INNER') {\n          pipeline.push({ $unwind: `$${join.alias ?? join.table}` });\n        } else if (join.type === 'LEFT') {\n          pipeline.push({\n            $unwind: {\n              path: `$${join.alias ?? join.table}`,\n              preserveNullAndEmptyArrays: true,\n            },\n          });\n        }\n      }\n    }\n\n    if (ast.groupBy && ast.groupBy.columns.length > 0) {\n      const groupId =\n        ast.groupBy.columns.length === 1\n          ? `$${ast.groupBy.columns[0]}`\n          : Object.fromEntries(ast.groupBy.columns.map((c) => [c, `$${c}`]));\n      pipeline.push({ $group: { _id: groupId } });\n    }\n\n    if (ast.having && ast.having.length > 0) {\n      const havingFilter: Record<string, unknown> = {};\n      for (const h of ast.having) {\n        havingFilter[h.column] = this.mapOperatorValue(h.op, h.value);\n      }\n      pipeline.push({ $match: havingFilter });\n    }\n\n    if (ast.orderBy) {\n      pipeline.push({\n        $sort: {\n          [ast.orderBy.column]: ast.orderBy.direction === 'desc' ? -1 : 1,\n        },\n      });\n    }\n\n    if (ast.offset !== undefined) pipeline.push({ $skip: ast.offset });\n    if (ast.limit !== undefined) pipeline.push({ $limit: ast.limit });\n\n    if (ast.columns && !ast.columns.includes('*')) {\n      const project: Record<string, 1> = {};\n      for (const col of ast.columns) {\n        if (!col.toLowerCase().startsWith('count(')) {\n          project[col] = 1;\n        }\n      }\n      if (Object.keys(project).length > 0) {\n        pipeline.push({ $project: project });\n      }\n    }\n\n    return {\n      type: 'aggregate',\n      collection: ast.table,\n      pipeline,\n    };\n  }\n\n  private compileInsert(ast: QueryAST, ctx?: TenantContext): MongoOperation {\n    if (ast.dataRows && ast.dataRows.length > 0) {\n      const documents = ast.dataRows.map((row) => this.injectTenantData(row, ctx));\n      return {\n        type: 'insertMany',\n        collection: ast.table,\n        documents,\n      };\n    }\n\n    const document = this.injectTenantData(ast.data ?? {}, ctx);\n    return {\n      type: 'insertOne',\n      collection: ast.table,\n      document,\n    };\n  }\n\n  private compileUpdate(ast: QueryAST, ctx?: TenantContext): MongoOperation {\n    const filter = this.buildFilter(ast.where, ctx);\n    const update = { $set: ast.data };\n\n    if (ast.returning && ast.returning.length > 0) {\n      const projection: Record<string, 1> = {};\n      for (const col of ast.returning) {\n        projection[col] = 1;\n      }\n      return {\n        type: 'findOneAndUpdate',\n        collection: ast.table,\n        filter,\n        update,\n        options: {\n          returnDocument: 'after',\n          projection: projection as Record<string, 0 | 1>,\n        },\n      };\n    }\n\n    return {\n      type: 'updateMany',\n      collection: ast.table,\n      filter,\n      update,\n    };\n  }\n\n  private compileDelete(ast: QueryAST, ctx?: TenantContext): MongoOperation {\n    const filter = this.buildFilter(ast.where, ctx);\n\n    if (ast.returning && ast.returning.length > 0) {\n      const projection: Record<string, 1> = {};\n      for (const col of ast.returning) {\n        projection[col] = 1;\n      }\n      return {\n        type: 'findOneAndDelete',\n        collection: ast.table,\n        filter,\n        options: {\n          projection: projection as Record<string, 0 | 1>,\n        },\n      };\n    }\n\n    return {\n      type: 'deleteMany',\n      collection: ast.table,\n      filter,\n    };\n  }\n\n  private buildFilter(\n    where: WhereClause[] | undefined,\n    ctx?: TenantContext\n  ): Record<string, unknown> {\n    const filter: Record<string, unknown> = {};\n\n    if (this.injectTenant && ctx) {\n      filter[this.tenantColumns.appId] = ctx.appId;\n      filter[this.tenantColumns.organizationId] = ctx.organizationId;\n    }\n\n    if (where) {\n      const orConditions: Record<string, unknown>[] = [];\n      let hasOr = false;\n\n      for (const clause of where) {\n        const value = this.mapOperatorValue(clause.op, clause.value);\n\n        if (clause.connector === 'OR') {\n          hasOr = true;\n          orConditions.push({ [clause.column]: value });\n        } else {\n          if (filter[clause.column] !== undefined) {\n            const existing = filter[clause.column];\n            if (\n              typeof existing === 'object' &&\n              existing !== null &&\n              typeof value === 'object' &&\n              value !== null\n            ) {\n              filter[clause.column] = {\n                ...(existing as Record<string, unknown>),\n                ...(value as Record<string, unknown>),\n              };\n            } else {\n              filter[clause.column] = value;\n            }\n          } else {\n            filter[clause.column] = value;\n          }\n        }\n      }\n\n      if (hasOr) {\n        const andConditions: Record<string, unknown>[] = [];\n        for (const [key, val] of Object.entries(filter)) {\n          if (key !== '$or') {\n            andConditions.push({ [key]: val });\n          }\n        }\n        if (orConditions.length > 0) {\n          if (andConditions.length > 0) {\n            return {\n              $and: [...andConditions, { $or: orConditions }],\n            };\n          }\n          filter.$or = orConditions;\n        }\n      }\n    }\n\n    return filter;\n  }\n\n  private mapOperatorValue(op: Operator, value: unknown): unknown {\n    switch (op) {\n      case '=':\n        return value;\n      case '!=':\n        return { $ne: value };\n      case '>':\n        return { $gt: value };\n      case '<':\n        return { $lt: value };\n      case '>=':\n        return { $gte: value };\n      case '<=':\n        return { $lte: value };\n      case 'IN':\n        return { $in: value };\n      case 'NOT IN':\n        return { $nin: value };\n      case 'LIKE':\n        return { $regex: this.likeToRegex(value as string) };\n      case 'ILIKE':\n        return { $regex: this.likeToRegex(value as string), $options: 'i' };\n      case 'IS NULL':\n        return null;\n      case 'IS NOT NULL':\n        return { $ne: null };\n      default:\n        throw new Error(`Unsupported operator: ${op}`);\n    }\n  }\n\n  private likeToRegex(pattern: string): string {\n    return pattern\n      .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n      .replace(/\\\\%/g, '%')\n      .replace(/%/g, '.*')\n      .replace(/\\\\_/g, '_')\n      .replace(/_/g, '.');\n  }\n\n  private injectTenantData(\n    data: Record<string, unknown>,\n    ctx?: TenantContext\n  ): Record<string, unknown> {\n    if (!this.injectTenant || !ctx) return data;\n    return {\n      ...data,\n      [this.tenantColumns.appId]: ctx.appId,\n      [this.tenantColumns.organizationId]: ctx.organizationId,\n    };\n  }\n}\n\nexport function createMongoCompiler(options?: MongoCompilerOptions): MongoCompiler {\n  return new MongoCompiler(options);\n}\n","import type {\n  CompiledQuery,\n  DialectName,\n  HavingClause,\n  QueryAST,\n  TenantContext,\n  WhereClause,\n} from '../types/index.js';\n\nexport interface CompilerOptions {\n  dialect: DialectName;\n  injectTenant?: boolean;\n  tenantColumns?: {\n    appId: string;\n    organizationId: string;\n  };\n}\n\ninterface CompilationState {\n  params: unknown[];\n  paramIndex: number;\n}\n\nconst DEFAULT_TENANT_COLUMNS = {\n  appId: 'app_id',\n  organizationId: 'organization_id',\n};\n\nexport class SQLCompiler {\n  private dialect: DialectName;\n  private injectTenant: boolean;\n  private tenantColumns: { appId: string; organizationId: string };\n\n  constructor(options: CompilerOptions) {\n    this.dialect = options.dialect;\n    this.injectTenant = options.injectTenant ?? true;\n    this.tenantColumns = options.tenantColumns ?? DEFAULT_TENANT_COLUMNS;\n  }\n\n  compile(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    switch (ast.type) {\n      case 'select':\n        return this.compileSelect(ast, ctx);\n      case 'insert':\n        return this.compileInsert(ast, ctx);\n      case 'update':\n        return this.compileUpdate(ast, ctx);\n      case 'delete':\n        return this.compileDelete(ast, ctx);\n      default:\n        throw new Error(`Unsupported query type: ${(ast as QueryAST).type}`);\n    }\n  }\n\n  private getParamPlaceholder(index: number): string {\n    switch (this.dialect) {\n      case 'postgresql':\n        return `$${index}`;\n      case 'mysql':\n      case 'sqlite':\n        return '?';\n      default:\n        return `$${index}`;\n    }\n  }\n\n  private compileSelect(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    const state: CompilationState = { params: [], paramIndex: 1 };\n\n    let sql = this.compileSelectFrom(ast);\n    sql += this.compileSelectJoins(ast);\n    sql += this.compileSelectWhere(ast, ctx, state);\n    sql += this.compileSelectGroupBy(ast);\n    sql += this.compileSelectHaving(ast, state);\n    sql += this.compileSelectOrderBy(ast);\n    sql += this.compileSelectLimitOffset(ast);\n\n    return { sql, params: state.params };\n  }\n\n  private compileSelectFrom(ast: QueryAST): string {\n    const columns = ast.columns?.length\n      ? ast.columns.map((c) => this.quoteIdentifier(c)).join(', ')\n      : '*';\n    return `SELECT ${columns} FROM ${this.quoteIdentifier(ast.table)}`;\n  }\n\n  private compileSelectJoins(ast: QueryAST): string {\n    if (!ast.joins?.length) return '';\n\n    return ast.joins\n      .map((join) => {\n        const alias = join.alias ? ` AS ${this.quoteIdentifier(join.alias)}` : '';\n        return ` ${join.type} JOIN ${this.quoteIdentifier(join.table)}${alias} ON ${this.quoteIdentifier(join.on.leftColumn)} = ${this.quoteIdentifier(join.on.rightColumn)}`;\n      })\n      .join('');\n  }\n\n  private compileSelectWhere(\n    ast: QueryAST,\n    ctx: TenantContext | undefined,\n    state: CompilationState\n  ): string {\n    const predicates = this.buildWherePredicates(ast, ctx, state);\n    if (predicates.length === 0) return '';\n    return ` WHERE ${this.joinPredicates(predicates, ast.where || [])}`;\n  }\n\n  private buildWherePredicates(\n    ast: QueryAST,\n    ctx: TenantContext | undefined,\n    state: CompilationState\n  ): string[] {\n    const predicates: string[] = [];\n\n    if (this.injectTenant && ctx) {\n      const tablePrefix = ast.joins?.length ? `${ast.table}.` : '';\n      predicates.push(\n        `${this.quoteIdentifier(`${tablePrefix}${this.tenantColumns.appId}`)} = ${this.getParamPlaceholder(state.paramIndex++)}`\n      );\n      state.params.push(ctx.appId);\n      predicates.push(\n        `${this.quoteIdentifier(`${tablePrefix}${this.tenantColumns.organizationId}`)} = ${this.getParamPlaceholder(state.paramIndex++)}`\n      );\n      state.params.push(ctx.organizationId);\n    }\n\n    if (ast.where?.length) {\n      for (const w of ast.where) {\n        const { predicate, values, paramCount } = this.compileWhere(w, state.paramIndex);\n        predicates.push(predicate);\n        state.params.push(...values);\n        state.paramIndex += paramCount;\n      }\n    }\n\n    return predicates;\n  }\n\n  private compileSelectGroupBy(ast: QueryAST): string {\n    if (!ast.groupBy?.columns.length) return '';\n    return ` GROUP BY ${ast.groupBy.columns.map((c) => this.quoteIdentifier(c)).join(', ')}`;\n  }\n\n  private compileSelectHaving(ast: QueryAST, state: CompilationState): string {\n    if (!ast.having?.length) return '';\n\n    const havingClauses: string[] = [];\n    for (const h of ast.having) {\n      const { predicate, values, paramCount } = this.compileHaving(h, state.paramIndex);\n      havingClauses.push(predicate);\n      state.params.push(...values);\n      state.paramIndex += paramCount;\n    }\n    return ` HAVING ${havingClauses.join(' AND ')}`;\n  }\n\n  private compileSelectOrderBy(ast: QueryAST): string {\n    if (!ast.orderBy) return '';\n\n    const direction = ast.orderBy.direction.toUpperCase();\n    if (direction !== 'ASC' && direction !== 'DESC') {\n      throw new Error(\n        `Invalid ORDER BY direction: ${ast.orderBy.direction}. Must be 'ASC' or 'DESC'.`\n      );\n    }\n    return ` ORDER BY ${this.quoteIdentifier(ast.orderBy.column)} ${direction}`;\n  }\n\n  private compileSelectLimitOffset(ast: QueryAST): string {\n    let sql = '';\n    if (ast.limit !== undefined) {\n      sql += ` LIMIT ${ast.limit}`;\n    }\n    if (ast.offset !== undefined) {\n      sql += ` OFFSET ${ast.offset}`;\n    }\n    return sql;\n  }\n\n  private compileInsert(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    const params: unknown[] = [];\n    let paramIndex = 1;\n\n    if (ast.dataRows !== undefined) {\n      return this.compileInsertMany(ast, ctx, params, paramIndex);\n    }\n\n    const data = { ...ast.data };\n\n    if (this.injectTenant && ctx) {\n      data[this.tenantColumns.appId] = ctx.appId;\n      data[this.tenantColumns.organizationId] = ctx.organizationId;\n    }\n\n    const columns = Object.keys(data!);\n    const values: string[] = [];\n\n    for (const col of columns) {\n      values.push(this.getParamPlaceholder(paramIndex++));\n      params.push(data![col]);\n    }\n\n    let sql = `INSERT INTO ${this.quoteIdentifier(ast.table)} (${columns.map((c) => this.quoteIdentifier(c)).join(', ')}) VALUES (${values.join(', ')})`;\n\n    if (ast.onConflict) {\n      sql += this.compileOnConflict(ast.onConflict, columns, paramIndex, params);\n    }\n\n    if (ast.returning?.length) {\n      sql += this.compileReturning(ast.returning);\n    }\n\n    return { sql, params };\n  }\n\n  private compileInsertMany(\n    ast: QueryAST,\n    ctx: TenantContext | undefined,\n    params: unknown[],\n    startParamIndex: number\n  ): CompiledQuery {\n    const rows = ast.dataRows!.map((row) => {\n      const data = { ...row };\n      if (this.injectTenant && ctx) {\n        data[this.tenantColumns.appId] = ctx.appId;\n        data[this.tenantColumns.organizationId] = ctx.organizationId;\n      }\n      return data;\n    });\n\n    if (rows.length === 0) {\n      throw new Error('Cannot insert empty array of rows');\n    }\n\n    const columns = Object.keys(rows[0]);\n    const valueGroups: string[] = [];\n    let currentParamIndex = startParamIndex;\n\n    for (const row of rows) {\n      const values: string[] = [];\n      for (const col of columns) {\n        values.push(this.getParamPlaceholder(currentParamIndex++));\n        params.push(row[col]);\n      }\n      valueGroups.push(`(${values.join(', ')})`);\n    }\n\n    let sql = `INSERT INTO ${this.quoteIdentifier(ast.table)} (${columns.map((c) => this.quoteIdentifier(c)).join(', ')}) VALUES ${valueGroups.join(', ')}`;\n\n    if (ast.onConflict) {\n      sql += this.compileOnConflict(ast.onConflict, columns, currentParamIndex, params);\n    }\n\n    if (ast.returning?.length) {\n      sql += this.compileReturning(ast.returning);\n    }\n\n    return { sql, params };\n  }\n\n  private compileOnConflict(\n    conflict: QueryAST['onConflict'],\n    columns: string[],\n    _paramIndex: number,\n    _params: unknown[]\n  ): string {\n    if (!conflict) return '';\n\n    const conflictCols = conflict.columns.map((c) => this.quoteIdentifier(c)).join(', ');\n\n    switch (this.dialect) {\n      case 'postgresql':\n      case 'sqlite': {\n        if (conflict.action === 'nothing') {\n          return ` ON CONFLICT (${conflictCols}) DO NOTHING`;\n        }\n        const updateCols =\n          conflict.updateColumns || columns.filter((c) => !conflict.columns.includes(c));\n        const setClauses = updateCols.map(\n          (c) => `${this.quoteIdentifier(c)} = EXCLUDED.${this.quoteIdentifier(c)}`\n        );\n        return ` ON CONFLICT (${conflictCols}) DO UPDATE SET ${setClauses.join(', ')}`;\n      }\n      case 'mysql': {\n        if (conflict.action === 'nothing') {\n          return ' ON DUPLICATE KEY UPDATE id = id';\n        }\n        const updateCols =\n          conflict.updateColumns || columns.filter((c) => !conflict.columns.includes(c));\n        const setClauses = updateCols.map(\n          (c) => `${this.quoteIdentifier(c)} = VALUES(${this.quoteIdentifier(c)})`\n        );\n        return ` ON DUPLICATE KEY UPDATE ${setClauses.join(', ')}`;\n      }\n      default:\n        throw new Error(`Unsupported dialect for ON CONFLICT: ${this.dialect}`);\n    }\n  }\n\n  private compileUpdate(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    const params: unknown[] = [];\n    let paramIndex = 1;\n\n    const setClauses: string[] = [];\n    for (const [key, value] of Object.entries(ast.data!)) {\n      setClauses.push(`${this.quoteIdentifier(key)} = ${this.getParamPlaceholder(paramIndex++)}`);\n      params.push(value);\n    }\n\n    let sql = `UPDATE ${this.quoteIdentifier(ast.table)} SET ${setClauses.join(', ')}`;\n\n    const predicates: string[] = [];\n\n    if (this.injectTenant && ctx) {\n      predicates.push(\n        `${this.quoteIdentifier(this.tenantColumns.appId)} = ${this.getParamPlaceholder(paramIndex++)}`\n      );\n      params.push(ctx.appId);\n      predicates.push(\n        `${this.quoteIdentifier(this.tenantColumns.organizationId)} = ${this.getParamPlaceholder(paramIndex++)}`\n      );\n      params.push(ctx.organizationId);\n    }\n\n    if (ast.where?.length) {\n      for (const w of ast.where) {\n        const { predicate, values, paramCount } = this.compileWhere(w, paramIndex);\n        predicates.push(predicate);\n        params.push(...values);\n        paramIndex += paramCount;\n      }\n    }\n\n    if (predicates.length) {\n      sql += ` WHERE ${predicates.join(' AND ')}`;\n    }\n\n    if (ast.returning?.length) {\n      sql += this.compileReturning(ast.returning);\n    }\n\n    return { sql, params };\n  }\n\n  private compileDelete(ast: QueryAST, ctx?: TenantContext): CompiledQuery {\n    if (this.injectTenant && !ctx) {\n      throw new Error('Tenant context is required when tenant injection is enabled');\n    }\n\n    const params: unknown[] = [];\n    let paramIndex = 1;\n\n    let sql = `DELETE FROM ${this.quoteIdentifier(ast.table)}`;\n\n    const predicates: string[] = [];\n\n    if (this.injectTenant && ctx) {\n      predicates.push(\n        `${this.quoteIdentifier(this.tenantColumns.appId)} = ${this.getParamPlaceholder(paramIndex++)}`\n      );\n      params.push(ctx.appId);\n      predicates.push(\n        `${this.quoteIdentifier(this.tenantColumns.organizationId)} = ${this.getParamPlaceholder(paramIndex++)}`\n      );\n      params.push(ctx.organizationId);\n    }\n\n    if (ast.where?.length) {\n      for (const w of ast.where) {\n        const { predicate, values, paramCount } = this.compileWhere(w, paramIndex);\n        predicates.push(predicate);\n        params.push(...values);\n        paramIndex += paramCount;\n      }\n    }\n\n    if (predicates.length) {\n      sql += ` WHERE ${predicates.join(' AND ')}`;\n    }\n\n    if (ast.returning?.length) {\n      sql += this.compileReturning(ast.returning);\n    }\n\n    return { sql, params };\n  }\n\n  private compileReturning(columns: string[]): string {\n    switch (this.dialect) {\n      case 'postgresql':\n      case 'sqlite':\n        return ` RETURNING ${columns.map((c) => this.quoteIdentifier(c)).join(', ')}`;\n      case 'mysql':\n        throw new Error(\n          'MySQL does not support RETURNING clause. Use separate SELECT query after INSERT/UPDATE/DELETE.'\n        );\n      default:\n        throw new Error(`Unsupported dialect for RETURNING: ${this.dialect}`);\n    }\n  }\n\n  private compileWhere(\n    w: WhereClause,\n    paramIndex: number\n  ): { predicate: string; values: unknown[]; paramCount: number } {\n    const col = this.quoteIdentifier(w.column);\n\n    switch (w.op) {\n      case 'IS NULL':\n        return { predicate: `${col} IS NULL`, values: [], paramCount: 0 };\n      case 'IS NOT NULL':\n        return { predicate: `${col} IS NOT NULL`, values: [], paramCount: 0 };\n      case 'IN':\n      case 'NOT IN': {\n        const inValues = w.value as unknown[];\n        if (inValues.length === 0) {\n          return {\n            predicate: w.op === 'IN' ? '1 = 0' : '1 = 1',\n            values: [],\n            paramCount: 0,\n          };\n        }\n        const placeholders = inValues\n          .map((_, i) => this.getParamPlaceholder(paramIndex + i))\n          .join(', ');\n        return {\n          predicate: `${col} ${w.op} (${placeholders})`,\n          values: inValues,\n          paramCount: inValues.length,\n        };\n      }\n      default:\n        return {\n          predicate: `${col} ${w.op} ${this.getParamPlaceholder(paramIndex)}`,\n          values: w.value !== undefined ? [w.value] : [],\n          paramCount: w.value !== undefined ? 1 : 0,\n        };\n    }\n  }\n\n  private joinPredicates(predicates: string[], whereClauses: WhereClause[]): string {\n    if (predicates.length === 0) return '';\n\n    const tenantPredicateCount = this.injectTenant ? 2 : 0;\n    const result = predicates.map((predicate, i) => {\n      if (i < tenantPredicateCount) return predicate;\n      const clause = whereClauses[i - tenantPredicateCount];\n      return clause?.connector === 'OR' ? `OR ${predicate}` : predicate;\n    });\n\n    return result.reduce((sql, part, i) => {\n      if (i === 0) return part;\n      return part.startsWith('OR ') ? `${sql} ${part}` : `${sql} AND ${part}`;\n    }, '');\n  }\n\n  private compileHaving(\n    h: HavingClause,\n    paramIndex: number\n  ): { predicate: string; values: unknown[]; paramCount: number } {\n    const col = this.quoteIdentifier(h.column);\n    return {\n      predicate: `${col} ${h.op} ${this.getParamPlaceholder(paramIndex)}`,\n      values: [h.value],\n      paramCount: 1,\n    };\n  }\n\n  private quoteIdentifier(identifier: string): string {\n    if (identifier === '*') return identifier;\n    // Don't quote SQL expressions (functions, aliases, etc.)\n    if (identifier.includes('(') || identifier.toLowerCase().includes(' as ')) {\n      return identifier;\n    }\n    if (identifier.includes('.')) {\n      return identifier\n        .split('.')\n        .map((part) => this.quoteIdentifier(part))\n        .join('.');\n    }\n\n    switch (this.dialect) {\n      case 'postgresql':\n        return `\"${identifier}\"`;\n      case 'mysql':\n        return `\\`${identifier}\\``;\n      case 'sqlite':\n        return `\"${identifier}\"`;\n      default:\n        return `\"${identifier}\"`;\n    }\n  }\n}\n\nexport function createCompiler(options: CompilerOptions): SQLCompiler {\n  return new SQLCompiler(options);\n}\n\nexport { MongoCompiler, createMongoCompiler } from './mongo.js';\nexport type { MongoCompilerOptions } from './mongo.js';\n","import type { TenantContext } from '../types/index.js';\n\nexport class TenantContextError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'TenantContextError';\n  }\n}\n\nexport function validateTenantContext(ctx: TenantContext | undefined, tableName: string): void {\n  if (!ctx) {\n    throw new TenantContextError(\n      `Missing tenant context for table \"${tableName}\". Provide a valid TenantContext with appId and organizationId, or use tableWithoutTenant() for system tables.`\n    );\n  }\n\n  if (typeof ctx.appId !== 'string' || ctx.appId.trim() === '') {\n    throw new TenantContextError(\n      `Invalid tenant context for table \"${tableName}\": appId must be a non-empty string.`\n    );\n  }\n\n  if (typeof ctx.organizationId !== 'string' || ctx.organizationId.trim() === '') {\n    throw new TenantContextError(\n      `Invalid tenant context for table \"${tableName}\": organizationId must be a non-empty string.`\n    );\n  }\n}\n\nexport function validateTenantContextOrWarn(\n  ctx: TenantContext | undefined,\n  tableName: string\n): void {\n  if (!ctx) {\n    console.warn(\n      `[WARNING] Missing tenant context for table \"${tableName}\". This query will not be filtered by tenant. Use tableWithoutTenant() explicitly if this is intended.`\n    );\n    return;\n  }\n\n  if (typeof ctx.appId !== 'string' || ctx.appId.trim() === '') {\n    console.warn(\n      `[WARNING] Invalid appId in tenant context for table \"${tableName}\". This may result in unfiltered queries.`\n    );\n  }\n\n  if (typeof ctx.organizationId !== 'string' || ctx.organizationId.trim() === '') {\n    console.warn(\n      `[WARNING] Invalid organizationId in tenant context for table \"${tableName}\". This may result in unfiltered queries.`\n    );\n  }\n}\n","import type { MongoCompiler, SQLCompiler } from '../compiler/index.js';\nimport type { MongoDriver, MongoTransactionClient } from '../driver/mongodb.js';\nimport type { Driver, TransactionClient } from '../driver/types.js';\nimport type { MongoOperation, Operator, QueryAST, TenantContext } from '../types/index.js';\nimport { validateTenantContextOrWarn } from '../utils/tenant-validation.js';\n\nexport class SelectBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'select',\n      table,\n      columns: ['*'],\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  select<K extends keyof T>(...columns: K[]): this {\n    this.ast.columns = columns as string[];\n    return this;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  whereNull(column: keyof T): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IS NULL', value: null });\n    return this;\n  }\n\n  whereNotNull(column: keyof T): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IS NOT NULL', value: null });\n    return this;\n  }\n\n  whereIn(column: keyof T, values: unknown[]): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IN', value: values });\n    return this;\n  }\n\n  whereNotIn(column: keyof T, values: unknown[]): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'NOT IN', value: values });\n    return this;\n  }\n\n  whereLike(column: keyof T, pattern: string): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'LIKE', value: pattern });\n    return this;\n  }\n\n  whereILike(column: keyof T, pattern: string): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'ILIKE', value: pattern });\n    return this;\n  }\n\n  orWhere(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value, connector: 'OR' });\n    return this;\n  }\n\n  groupBy(...columns: (keyof T)[]): this {\n    this.ast.groupBy = { columns: columns as string[] };\n    return this;\n  }\n\n  having(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.having = this.ast.having ?? [];\n    this.ast.having.push({ column: column as string, op, value });\n    return this;\n  }\n\n  orderBy(column: keyof T, direction: 'asc' | 'desc' = 'asc'): this {\n    this.ast.orderBy = { column: column as string, direction };\n    return this;\n  }\n\n  limit(n: number): this {\n    this.ast.limit = n;\n    return this;\n  }\n\n  offset(n: number): this {\n    this.ast.offset = n;\n    return this;\n  }\n\n  join(\n    type: 'INNER' | 'LEFT' | 'RIGHT' | 'FULL',\n    table: string,\n    leftColumn: string,\n    rightColumn: string,\n    alias?: string\n  ): this {\n    this.ast.joins = this.ast.joins ?? [];\n    this.ast.joins.push({\n      type,\n      table,\n      alias,\n      on: { leftColumn, rightColumn },\n    });\n    return this;\n  }\n\n  innerJoin(table: string, leftColumn: string, rightColumn: string, alias?: string): this {\n    return this.join('INNER', table, leftColumn, rightColumn, alias);\n  }\n\n  leftJoin(table: string, leftColumn: string, rightColumn: string, alias?: string): this {\n    return this.join('LEFT', table, leftColumn, rightColumn, alias);\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.query<T>(sql, params);\n    return result.rows;\n  }\n\n  async first(): Promise<T | null> {\n    this.validateTenantOnce();\n    this.limit(1);\n    const rows = await this.execute();\n    return rows[0] ?? null;\n  }\n\n  async count(): Promise<number> {\n    this.validateTenantOnce();\n    const originalColumns = this.ast.columns;\n    this.ast.columns = ['COUNT(*) as count'];\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.query<{ count: number | string }>(sql, params);\n    this.ast.columns = originalColumns;\n    return Number(result.rows[0]?.count ?? 0);\n  }\n\n  toSQL(): { sql: string; params: unknown[] } {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class InsertBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'insert',\n      table,\n      data: {},\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  values(data: Partial<Omit<T, 'app_id' | 'organization_id'>>): this {\n    this.ast.data = data as Record<string, unknown>;\n    return this;\n  }\n\n  valuesMany(rows: Partial<Omit<T, 'app_id' | 'organization_id'>>[]): this {\n    this.ast.dataRows = rows as Record<string, unknown>[];\n    return this;\n  }\n\n  onConflict(\n    columns: (keyof T)[],\n    action: 'update' | 'nothing',\n    updateColumns?: (keyof T)[]\n  ): this {\n    this.ast.onConflict = {\n      columns: columns as string[],\n      action,\n      updateColumns: updateColumns as string[],\n    };\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    if (this.ast.returning?.length) {\n      const result = await this.driver.query<T>(sql, params);\n      return result.rows;\n    }\n    await this.driver.execute(sql, params);\n    return [];\n  }\n\n  toSQL(): { sql: string; params: unknown[] } {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class UpdateBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'update',\n      table,\n      data: {},\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  set(data: Partial<Omit<T, 'app_id' | 'organization_id' | 'id' | 'created_at'>>): this {\n    this.ast.data = data as Record<string, unknown>;\n    return this;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    if (this.ast.returning?.length) {\n      const result = await this.driver.query<T>(sql, params);\n      return result.rows;\n    }\n    await this.driver.execute(sql, params);\n    return [];\n  }\n\n  toSQL(): { sql: string; params: unknown[] } {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class DeleteBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'delete',\n      table,\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const { sql, params } = this.compiler.compile(this.ast, this.ctx);\n    if (this.ast.returning?.length) {\n      const result = await this.driver.query<T>(sql, params);\n      return result.rows;\n    }\n    await this.driver.execute(sql, params);\n    return [];\n  }\n\n  toSQL(): { sql: string; params: unknown[] } {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class TableBuilder<T = Record<string, unknown>> {\n  private driver: Driver | TransactionClient;\n  private compiler: SQLCompiler;\n  private tableName: string;\n  private ctx?: TenantContext;\n  private shouldValidateTenant: boolean;\n  private whereConditions: Array<{ column: string; op: Operator; value: unknown }> = [];\n  private orderByClause?: { column: string; direction: 'asc' | 'desc' };\n  private limitValue?: number;\n  private offsetValue?: number;\n\n  constructor(\n    driver: Driver | TransactionClient,\n    compiler: SQLCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.tableName = table;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.whereConditions.push({ column: column as string, op, value });\n    return this;\n  }\n\n  whereNull(column: keyof T): this {\n    this.whereConditions.push({ column: column as string, op: 'IS NULL', value: null });\n    return this;\n  }\n\n  whereNotNull(column: keyof T): this {\n    this.whereConditions.push({ column: column as string, op: 'IS NOT NULL', value: null });\n    return this;\n  }\n\n  whereIn(column: keyof T, values: unknown[]): this {\n    this.whereConditions.push({ column: column as string, op: 'IN', value: values });\n    return this;\n  }\n\n  whereNotIn(column: keyof T, values: unknown[]): this {\n    this.whereConditions.push({ column: column as string, op: 'NOT IN', value: values });\n    return this;\n  }\n\n  whereLike(column: keyof T, pattern: string): this {\n    this.whereConditions.push({ column: column as string, op: 'LIKE', value: pattern });\n    return this;\n  }\n\n  whereILike(column: keyof T, pattern: string): this {\n    this.whereConditions.push({ column: column as string, op: 'ILIKE', value: pattern });\n    return this;\n  }\n\n  orderBy(column: keyof T, direction: 'asc' | 'desc' = 'asc'): this {\n    this.orderByClause = { column: column as string, direction };\n    return this;\n  }\n\n  limit(n: number): this {\n    this.limitValue = n;\n    return this;\n  }\n\n  offset(n: number): this {\n    this.offsetValue = n;\n    return this;\n  }\n\n  select<K extends keyof T>(...columns: K[]): SelectBuilder<T> {\n    const builder = new SelectBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    if (columns.length) {\n      builder.select(...columns);\n    }\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    if (this.orderByClause) {\n      builder.orderBy(this.orderByClause.column as keyof T, this.orderByClause.direction);\n    }\n    if (this.limitValue !== undefined) {\n      builder.limit(this.limitValue);\n    }\n    if (this.offsetValue !== undefined) {\n      builder.offset(this.offsetValue);\n    }\n    return builder;\n  }\n\n  insert(): InsertBuilder<T> {\n    return new InsertBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n  }\n\n  update(\n    data?: Partial<Omit<T, 'app_id' | 'organization_id' | 'id' | 'created_at'>>\n  ): UpdateBuilder<T> {\n    const builder = new UpdateBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    if (data) {\n      builder.set(data);\n    }\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    return builder;\n  }\n\n  delete(): DeleteBuilder<T> {\n    const builder = new DeleteBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    return builder;\n  }\n\n  async findById(id: string | number): Promise<T | null> {\n    return this.select()\n      .where('id' as keyof T, '=', id)\n      .first();\n  }\n\n  async findMany(options?: {\n    where?: Array<{ column: keyof T; op: Operator; value: unknown }>;\n    orderBy?: { column: keyof T; direction: 'asc' | 'desc' };\n    limit?: number;\n    offset?: number;\n  }): Promise<T[]> {\n    let builder = this.select();\n\n    if (options?.where) {\n      for (const w of options.where) {\n        builder = builder.where(w.column, w.op, w.value);\n      }\n    }\n\n    if (options?.orderBy) {\n      builder = builder.orderBy(options.orderBy.column, options.orderBy.direction);\n    }\n\n    if (options?.limit !== undefined) {\n      builder = builder.limit(options.limit);\n    }\n\n    if (options?.offset !== undefined) {\n      builder = builder.offset(options.offset);\n    }\n\n    return builder.execute();\n  }\n}\n\nexport class MongoSelectBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: MongoDriver | MongoTransactionClient;\n  private compiler: MongoCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: MongoDriver | MongoTransactionClient,\n    compiler: MongoCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'select',\n      table,\n      columns: ['*'],\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  select<K extends keyof T>(...columns: K[]): this {\n    this.ast.columns = columns as string[];\n    return this;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  whereNull(column: keyof T): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IS NULL', value: null });\n    return this;\n  }\n\n  whereNotNull(column: keyof T): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IS NOT NULL', value: null });\n    return this;\n  }\n\n  whereIn(column: keyof T, values: unknown[]): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'IN', value: values });\n    return this;\n  }\n\n  whereNotIn(column: keyof T, values: unknown[]): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'NOT IN', value: values });\n    return this;\n  }\n\n  whereLike(column: keyof T, pattern: string): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'LIKE', value: pattern });\n    return this;\n  }\n\n  whereILike(column: keyof T, pattern: string): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op: 'ILIKE', value: pattern });\n    return this;\n  }\n\n  orWhere(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value, connector: 'OR' });\n    return this;\n  }\n\n  groupBy(...columns: (keyof T)[]): this {\n    this.ast.groupBy = { columns: columns as string[] };\n    return this;\n  }\n\n  having(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.having = this.ast.having ?? [];\n    this.ast.having.push({ column: column as string, op, value });\n    return this;\n  }\n\n  orderBy(column: keyof T, direction: 'asc' | 'desc' = 'asc'): this {\n    this.ast.orderBy = { column: column as string, direction };\n    return this;\n  }\n\n  limit(n: number): this {\n    this.ast.limit = n;\n    return this;\n  }\n\n  offset(n: number): this {\n    this.ast.offset = n;\n    return this;\n  }\n\n  join(\n    type: 'INNER' | 'LEFT' | 'RIGHT' | 'FULL',\n    table: string,\n    leftColumn: string,\n    rightColumn: string,\n    alias?: string\n  ): this {\n    this.ast.joins = this.ast.joins ?? [];\n    this.ast.joins.push({\n      type,\n      table,\n      alias,\n      on: { leftColumn, rightColumn },\n    });\n    return this;\n  }\n\n  innerJoin(table: string, leftColumn: string, rightColumn: string, alias?: string): this {\n    return this.join('INNER', table, leftColumn, rightColumn, alias);\n  }\n\n  leftJoin(table: string, leftColumn: string, rightColumn: string, alias?: string): this {\n    return this.join('LEFT', table, leftColumn, rightColumn, alias);\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const operation = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.executeOperation<T>(operation);\n    return result.rows;\n  }\n\n  async first(): Promise<T | null> {\n    this.validateTenantOnce();\n    this.limit(1);\n    const rows = await this.execute();\n    return rows[0] ?? null;\n  }\n\n  async count(): Promise<number> {\n    this.validateTenantOnce();\n    const originalColumns = this.ast.columns;\n    this.ast.columns = ['COUNT(*) as count'];\n    const operation = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.executeOperation<{ count: number }>(operation);\n    this.ast.columns = originalColumns;\n    return Number(result.rows[0]?.count ?? 0);\n  }\n\n  toOperation(): MongoOperation {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class MongoInsertBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: MongoDriver | MongoTransactionClient;\n  private compiler: MongoCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: MongoDriver | MongoTransactionClient,\n    compiler: MongoCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'insert',\n      table,\n      data: {},\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  values(data: Partial<Omit<T, 'app_id' | 'organization_id'>>): this {\n    this.ast.data = data as Record<string, unknown>;\n    return this;\n  }\n\n  valuesMany(rows: Partial<Omit<T, 'app_id' | 'organization_id'>>[]): this {\n    this.ast.dataRows = rows as Record<string, unknown>[];\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const operation = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.executeOperation<T>(operation);\n    return result.rows;\n  }\n\n  toOperation(): MongoOperation {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class MongoUpdateBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: MongoDriver | MongoTransactionClient;\n  private compiler: MongoCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: MongoDriver | MongoTransactionClient,\n    compiler: MongoCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'update',\n      table,\n      data: {},\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  set(data: Partial<Omit<T, 'app_id' | 'organization_id' | 'id' | 'created_at'>>): this {\n    this.ast.data = data as Record<string, unknown>;\n    return this;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const operation = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.executeOperation<T>(operation);\n    return result.rows;\n  }\n\n  toOperation(): MongoOperation {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class MongoDeleteBuilder<T = Record<string, unknown>> {\n  private ast: QueryAST;\n  private driver: MongoDriver | MongoTransactionClient;\n  private compiler: MongoCompiler;\n  private ctx?: TenantContext;\n  private tenantValidated = false;\n  private shouldValidateTenant: boolean;\n\n  constructor(\n    driver: MongoDriver | MongoTransactionClient,\n    compiler: MongoCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n    this.ast = {\n      type: 'delete',\n      table,\n      where: [],\n    };\n  }\n\n  private validateTenantOnce(): void {\n    if (!this.tenantValidated && this.shouldValidateTenant) {\n      validateTenantContextOrWarn(this.ctx, this.ast.table);\n      this.tenantValidated = true;\n    }\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.ast.where = this.ast.where ?? [];\n    this.ast.where.push({ column: column as string, op, value });\n    return this;\n  }\n\n  returning<K extends keyof T>(...columns: K[]): this {\n    this.ast.returning = columns as string[];\n    return this;\n  }\n\n  async execute(): Promise<T[]> {\n    this.validateTenantOnce();\n    const operation = this.compiler.compile(this.ast, this.ctx);\n    const result = await this.driver.executeOperation<T>(operation);\n    return result.rows;\n  }\n\n  toOperation(): MongoOperation {\n    return this.compiler.compile(this.ast, this.ctx);\n  }\n}\n\nexport class MongoTableBuilder<T = Record<string, unknown>> {\n  private driver: MongoDriver | MongoTransactionClient;\n  private compiler: MongoCompiler;\n  private tableName: string;\n  private ctx?: TenantContext;\n  private shouldValidateTenant: boolean;\n  private whereConditions: Array<{ column: string; op: Operator; value: unknown }> = [];\n  private orderByClause?: { column: string; direction: 'asc' | 'desc' };\n  private limitValue?: number;\n  private offsetValue?: number;\n\n  constructor(\n    driver: MongoDriver | MongoTransactionClient,\n    compiler: MongoCompiler,\n    table: string,\n    ctx?: TenantContext,\n    shouldValidateTenant = true\n  ) {\n    this.driver = driver;\n    this.compiler = compiler;\n    this.tableName = table;\n    this.ctx = ctx;\n    this.shouldValidateTenant = shouldValidateTenant;\n  }\n\n  where(column: keyof T, op: Operator, value: unknown): this {\n    this.whereConditions.push({ column: column as string, op, value });\n    return this;\n  }\n\n  whereNull(column: keyof T): this {\n    this.whereConditions.push({ column: column as string, op: 'IS NULL', value: null });\n    return this;\n  }\n\n  whereNotNull(column: keyof T): this {\n    this.whereConditions.push({ column: column as string, op: 'IS NOT NULL', value: null });\n    return this;\n  }\n\n  whereIn(column: keyof T, values: unknown[]): this {\n    this.whereConditions.push({ column: column as string, op: 'IN', value: values });\n    return this;\n  }\n\n  whereNotIn(column: keyof T, values: unknown[]): this {\n    this.whereConditions.push({ column: column as string, op: 'NOT IN', value: values });\n    return this;\n  }\n\n  whereLike(column: keyof T, pattern: string): this {\n    this.whereConditions.push({ column: column as string, op: 'LIKE', value: pattern });\n    return this;\n  }\n\n  whereILike(column: keyof T, pattern: string): this {\n    this.whereConditions.push({ column: column as string, op: 'ILIKE', value: pattern });\n    return this;\n  }\n\n  orderBy(column: keyof T, direction: 'asc' | 'desc' = 'asc'): this {\n    this.orderByClause = { column: column as string, direction };\n    return this;\n  }\n\n  limit(n: number): this {\n    this.limitValue = n;\n    return this;\n  }\n\n  offset(n: number): this {\n    this.offsetValue = n;\n    return this;\n  }\n\n  select<K extends keyof T>(...columns: K[]): MongoSelectBuilder<T> {\n    const builder = new MongoSelectBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    if (columns.length) {\n      builder.select(...columns);\n    }\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    if (this.orderByClause) {\n      builder.orderBy(this.orderByClause.column as keyof T, this.orderByClause.direction);\n    }\n    if (this.limitValue !== undefined) {\n      builder.limit(this.limitValue);\n    }\n    if (this.offsetValue !== undefined) {\n      builder.offset(this.offsetValue);\n    }\n    return builder;\n  }\n\n  insert(): MongoInsertBuilder<T> {\n    return new MongoInsertBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n  }\n\n  update(\n    data?: Partial<Omit<T, 'app_id' | 'organization_id' | 'id' | 'created_at'>>\n  ): MongoUpdateBuilder<T> {\n    const builder = new MongoUpdateBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    if (data) {\n      builder.set(data);\n    }\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    return builder;\n  }\n\n  delete(): MongoDeleteBuilder<T> {\n    const builder = new MongoDeleteBuilder<T>(\n      this.driver,\n      this.compiler,\n      this.tableName,\n      this.ctx,\n      this.shouldValidateTenant\n    );\n    for (const w of this.whereConditions) {\n      builder.where(w.column as keyof T, w.op, w.value);\n    }\n    return builder;\n  }\n\n  async findById(id: string | number): Promise<T | null> {\n    return this.select()\n      .where('id' as keyof T, '=', id)\n      .first();\n  }\n\n  async findMany(options?: {\n    where?: Array<{ column: keyof T; op: Operator; value: unknown }>;\n    orderBy?: { column: keyof T; direction: 'asc' | 'desc' };\n    limit?: number;\n    offset?: number;\n  }): Promise<T[]> {\n    let builder = this.select();\n\n    if (options?.where) {\n      for (const w of options.where) {\n        builder = builder.where(w.column, w.op, w.value);\n      }\n    }\n\n    if (options?.orderBy) {\n      builder = builder.orderBy(options.orderBy.column, options.orderBy.direction);\n    }\n\n    if (options?.limit !== undefined) {\n      builder = builder.limit(options.limit);\n    }\n\n    if (options?.offset !== undefined) {\n      builder = builder.offset(options.offset);\n    }\n\n    return builder.execute();\n  }\n}\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nfunction compileMysqlDefault(colDef: ColumnDefinition): string {\n  if (!colDef.default) return '';\n  const defaultVal = colDef.default === 'gen_random_uuid()' ? '(UUID())' : colDef.default;\n  return ` DEFAULT ${defaultVal}`;\n}\n\nfunction compileMysqlConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  sql += compileMysqlDefault(colDef);\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compileMysqlForeignKeys(\n  tableName: string,\n  columns: Record<string, ColumnDefinition>\n): string[] {\n  const fkDefs: string[] = [];\n  for (const [colName, colDef] of Object.entries(columns)) {\n    if (colDef.references) {\n      const fkName = `fk_${tableName}_${colName}`;\n      let fk = `  CONSTRAINT \\`${fkName}\\` FOREIGN KEY (\\`${colName}\\`) `;\n      fk += `REFERENCES \\`${colDef.references.table}\\`(\\`${colDef.references.column}\\`)`;\n      if (colDef.references.onDelete) {\n        fk += ` ON DELETE ${colDef.references.onDelete}`;\n      }\n      fkDefs.push(fk);\n    }\n  }\n  return fkDefs;\n}\n\nexport const mysqlDialect: Dialect = {\n  name: 'mysql',\n  supportsTransactionalDDL: false,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'CHAR(36)',\n      string: 'VARCHAR(255)',\n      text: 'TEXT',\n      integer: 'INT',\n      bigint: 'BIGINT',\n      float: 'DOUBLE',\n      decimal: 'DECIMAL(10,2)',\n      boolean: 'TINYINT(1)',\n      datetime: 'DATETIME',\n      date: 'DATE',\n      time: 'TIME',\n      json: 'JSON',\n      binary: 'BLOB',\n    };\n    return map[type] || 'VARCHAR(255)';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \\`${colName}\\` ${this.mapType(colDef.type)}`;\n      return typeSql + compileMysqlConstraints(colDef);\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\\`${c}\\``).join(', ')})`);\n    }\n\n    const foreignKeys = compileMysqlForeignKeys(name, def.columns);\n    columnDefs.push(...foreignKeys);\n\n    return `CREATE TABLE \\`${name}\\` (\\n${columnDefs.join(',\\n')}\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \\`${name}\\``;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \\`${table}\\` ADD COLUMN \\`${column}\\` ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    if (def.unique) {\n      sql += ' UNIQUE';\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \\`${table}\\` DROP COLUMN \\`${column}\\``;\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \\`${table}\\` MODIFY COLUMN \\`${column}\\` ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    return sql;\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\\`${c}\\``).join(', ');\n    return `CREATE ${unique}INDEX \\`${indexName}\\` ON \\`${table}\\` (${columns})`;\n  },\n\n  dropIndex(name: string, table?: string): string {\n    if (!table) {\n      throw new Error('MySQL requires table name for DROP INDEX');\n    }\n    return `DROP INDEX \\`${name}\\` ON \\`${table}\\``;\n  },\n\n  addForeignKey(\n    table: string,\n    column: string,\n    refTable: string,\n    refColumn: string,\n    onDelete?: string\n  ): string {\n    const constraintName = `fk_${table}_${column}_${refTable}`;\n    let sql = `ALTER TABLE \\`${table}\\` ADD CONSTRAINT \\`${constraintName}\\` `;\n    sql += `FOREIGN KEY (\\`${column}\\`) REFERENCES \\`${refTable}\\`(\\`${refColumn}\\`)`;\n    if (onDelete) {\n      sql += ` ON DELETE ${onDelete}`;\n    }\n    return sql;\n  },\n\n  dropForeignKey(table: string, constraintName: string): string {\n    return `ALTER TABLE \\`${table}\\` DROP FOREIGN KEY \\`${constraintName}\\``;\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT table_name\n      FROM information_schema.tables\n      WHERE table_schema = DATABASE()\n        AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `\n      SELECT\n        column_name,\n        data_type,\n        is_nullable,\n        column_default,\n        character_maximum_length\n      FROM information_schema.columns\n      WHERE table_schema = DATABASE() AND table_name = '${table}'\n      ORDER BY ordinal_position\n    `;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `\n      SELECT\n        index_name,\n        column_name,\n        non_unique\n      FROM information_schema.statistics\n      WHERE table_schema = DATABASE() AND table_name = '${table}'\n      ORDER BY index_name, seq_in_index\n    `;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nfunction compilePostgresConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  if (colDef.default) {\n    sql += ` DEFAULT ${colDef.default}`;\n  }\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compilePostgresReferences(colDef: ColumnDefinition): string {\n  if (!colDef.references) return '';\n  let sql = ` REFERENCES \"${colDef.references.table}\"(\"${colDef.references.column}\")`;\n  if (colDef.references.onDelete) {\n    sql += ` ON DELETE ${colDef.references.onDelete}`;\n  }\n  if (colDef.references.onUpdate) {\n    sql += ` ON UPDATE ${colDef.references.onUpdate}`;\n  }\n  return sql;\n}\n\nexport const postgresDialect: Dialect = {\n  name: 'postgresql',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'UUID',\n      string: 'TEXT',\n      text: 'TEXT',\n      integer: 'INTEGER',\n      bigint: 'BIGINT',\n      float: 'DOUBLE PRECISION',\n      decimal: 'NUMERIC',\n      boolean: 'BOOLEAN',\n      datetime: 'TIMESTAMPTZ',\n      date: 'DATE',\n      time: 'TIME',\n      json: 'JSONB',\n      binary: 'BYTEA',\n    };\n    return map[type] || 'TEXT';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \"${colName}\" ${this.mapType(colDef.type)}`;\n      const constraints = compilePostgresConstraints(colDef);\n      const references = compilePostgresReferences(colDef);\n      return typeSql + constraints + references;\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\"${c}\"`).join(', ')})`);\n    }\n\n    return `CREATE TABLE \"${name}\" (\\n${columnDefs.join(',\\n')}\\n)`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \"${name}\" CASCADE`;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \"${table}\" ADD COLUMN \"${column}\" ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    if (!def.nullable) {\n      sql += ' NOT NULL';\n    }\n\n    if (def.unique) {\n      sql += ' UNIQUE';\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \"${table}\" DROP COLUMN \"${column}\"`;\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): string {\n    const statements: string[] = [];\n\n    statements.push(\n      `ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" TYPE ${this.mapType(def.type)}`\n    );\n\n    if (def.nullable === false) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" SET NOT NULL`);\n    } else if (def.nullable === true) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" DROP NOT NULL`);\n    }\n\n    if (def.default !== undefined) {\n      statements.push(`ALTER TABLE \"${table}\" ALTER COLUMN \"${column}\" SET DEFAULT ${def.default}`);\n    }\n\n    return statements.join(';\\n');\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\"${c}\"`).join(', ');\n    let sql = `CREATE ${unique}INDEX \"${indexName}\" ON \"${table}\" (${columns})`;\n\n    if (index.where) {\n      sql += ` WHERE ${index.where}`;\n    }\n\n    return sql;\n  },\n\n  dropIndex(name: string): string {\n    return `DROP INDEX IF EXISTS \"${name}\"`;\n  },\n\n  addForeignKey(\n    table: string,\n    column: string,\n    refTable: string,\n    refColumn: string,\n    onDelete?: string\n  ): string {\n    const constraintName = `fk_${table}_${column}_${refTable}`;\n    let sql = `ALTER TABLE \"${table}\" ADD CONSTRAINT \"${constraintName}\" `;\n    sql += `FOREIGN KEY (\"${column}\") REFERENCES \"${refTable}\"(\"${refColumn}\")`;\n    if (onDelete) {\n      sql += ` ON DELETE ${onDelete}`;\n    }\n    return sql;\n  },\n\n  dropForeignKey(table: string, constraintName: string): string {\n    return `ALTER TABLE \"${table}\" DROP CONSTRAINT \"${constraintName}\"`;\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT table_name\n      FROM information_schema.tables\n      WHERE table_schema = 'public'\n        AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `\n      SELECT\n        column_name,\n        data_type,\n        is_nullable,\n        column_default,\n        character_maximum_length\n      FROM information_schema.columns\n      WHERE table_schema = 'public' AND table_name = '${table}'\n      ORDER BY ordinal_position\n    `;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `\n      SELECT\n        i.relname as index_name,\n        a.attname as column_name,\n        ix.indisunique as is_unique,\n        ix.indisprimary as is_primary\n      FROM pg_class t\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE t.relname = '${table}'\n      ORDER BY i.relname, a.attnum\n    `;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\nimport type { Dialect } from './types.js';\n\nconst SQLITE_UUID_DEFAULT =\n  \"(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))\";\n\nfunction compileSqliteDefault(colDef: ColumnDefinition): string {\n  if (!colDef.default) return '';\n  let defaultVal = colDef.default;\n  if (colDef.default === 'gen_random_uuid()') {\n    defaultVal = SQLITE_UUID_DEFAULT;\n  } else if (colDef.default === 'now()' || colDef.default === 'NOW()') {\n    defaultVal = \"datetime('now')\";\n  }\n  return ` DEFAULT ${defaultVal}`;\n}\n\nfunction compileSqliteConstraints(colDef: ColumnDefinition): string {\n  let sql = '';\n  if (colDef.primaryKey) {\n    sql += ' PRIMARY KEY';\n  }\n  sql += compileSqliteDefault(colDef);\n  if (!colDef.nullable && !colDef.primaryKey) {\n    sql += ' NOT NULL';\n  }\n  if (colDef.unique && !colDef.primaryKey) {\n    sql += ' UNIQUE';\n  }\n  return sql;\n}\n\nfunction compileSqliteReferences(colDef: ColumnDefinition): string {\n  if (!colDef.references) return '';\n  let sql = ` REFERENCES \"${colDef.references.table}\"(\"${colDef.references.column}\")`;\n  if (colDef.references.onDelete) {\n    sql += ` ON DELETE ${colDef.references.onDelete}`;\n  }\n  return sql;\n}\n\nexport const sqliteDialect: Dialect = {\n  name: 'sqlite',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const map: Record<ColumnType, string> = {\n      uuid: 'TEXT',\n      string: 'TEXT',\n      text: 'TEXT',\n      integer: 'INTEGER',\n      bigint: 'INTEGER',\n      float: 'REAL',\n      decimal: 'REAL',\n      boolean: 'INTEGER',\n      datetime: 'TEXT',\n      date: 'TEXT',\n      time: 'TEXT',\n      json: 'TEXT',\n      binary: 'BLOB',\n    };\n    return map[type] || 'TEXT';\n  },\n\n  createTable(name: string, def: TableDefinition): string {\n    const columnDefs = Object.entries(def.columns).map(([colName, colDef]) => {\n      const typeSql = `  \"${colName}\" ${this.mapType(colDef.type)}`;\n      const constraints = compileSqliteConstraints(colDef);\n      const references = compileSqliteReferences(colDef);\n      return typeSql + constraints + references;\n    });\n\n    if (def.primaryKey && def.primaryKey.length > 1) {\n      columnDefs.push(`  PRIMARY KEY (${def.primaryKey.map((c) => `\"${c}\"`).join(', ')})`);\n    }\n\n    return `CREATE TABLE \"${name}\" (\\n${columnDefs.join(',\\n')}\\n)`;\n  },\n\n  dropTable(name: string): string {\n    return `DROP TABLE IF EXISTS \"${name}\"`;\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): string {\n    let sql = `ALTER TABLE \"${table}\" ADD COLUMN \"${column}\" ${this.mapType(def.type)}`;\n\n    if (def.default) {\n      sql += ` DEFAULT ${def.default}`;\n    }\n\n    return sql;\n  },\n\n  dropColumn(table: string, column: string): string {\n    return `ALTER TABLE \"${table}\" DROP COLUMN \"${column}\"`;\n  },\n\n  alterColumn(_table: string, _column: string, _def: ColumnDefinition): string {\n    throw new Error(\n      'SQLite does not support ALTER COLUMN. Use table recreation instead: ' +\n        '1. Create new table with desired schema, 2. Copy data, 3. Drop old table, 4. Rename new table'\n    );\n  },\n\n  createIndex(table: string, index: IndexDefinition): string {\n    const indexName = index.name || `idx_${table}_${index.columns.join('_')}`;\n    const unique = index.unique ? 'UNIQUE ' : '';\n    const columns = index.columns.map((c) => `\"${c}\"`).join(', ');\n    let sql = `CREATE ${unique}INDEX \"${indexName}\" ON \"${table}\" (${columns})`;\n\n    if (index.where) {\n      sql += ` WHERE ${index.where}`;\n    }\n\n    return sql;\n  },\n\n  dropIndex(name: string): string {\n    return `DROP INDEX IF EXISTS \"${name}\"`;\n  },\n\n  addForeignKey(\n    _table: string,\n    _column: string,\n    _refTable: string,\n    _refColumn: string,\n    _onDelete?: string\n  ): string {\n    throw new Error(\n      'SQLite does not support adding foreign keys after table creation. ' +\n        'Define foreign keys in CREATE TABLE or use table recreation.'\n    );\n  },\n\n  dropForeignKey(_table: string, _constraintName: string): string {\n    throw new Error('SQLite does not support dropping foreign keys. Use table recreation instead.');\n  },\n\n  introspectTablesQuery(): string {\n    return `\n      SELECT name as table_name\n      FROM sqlite_master\n      WHERE type = 'table' AND name NOT LIKE 'sqlite_%'\n      ORDER BY name\n    `;\n  },\n\n  introspectColumnsQuery(table: string): string {\n    return `PRAGMA table_info(\"${table}\")`;\n  },\n\n  introspectIndexesQuery(table: string): string {\n    return `PRAGMA index_list(\"${table}\")`;\n  },\n};\n","import type {\n  ColumnDefinition,\n  ColumnType,\n  IndexDefinition,\n  TableDefinition,\n} from '../../types/index.js';\n\nexport interface MongoMigrationOperation {\n  operation:\n    | 'createCollection'\n    | 'dropCollection'\n    | 'collMod'\n    | 'createIndex'\n    | 'dropIndex'\n    | 'addValidator'\n    | 'removeValidator';\n  collection: string;\n  options?: Record<string, unknown>;\n  indexSpec?: {\n    keys: Record<string, 1 | -1>;\n    options?: {\n      name?: string;\n      unique?: boolean;\n      sparse?: boolean;\n    };\n  };\n}\n\nexport interface MongoDialect {\n  name: 'mongodb';\n  supportsTransactionalDDL: boolean;\n\n  mapType(type: ColumnType): string;\n  createTable(name: string, def: TableDefinition): MongoMigrationOperation;\n  dropTable(name: string): MongoMigrationOperation;\n  addColumn(table: string, column: string, def: ColumnDefinition): MongoMigrationOperation;\n  dropColumn(table: string, column: string): MongoMigrationOperation;\n  alterColumn(table: string, column: string, def: ColumnDefinition): MongoMigrationOperation;\n  createIndex(table: string, index: IndexDefinition): MongoMigrationOperation;\n  dropIndex(name: string, table: string): MongoMigrationOperation;\n}\n\nconst COLUMN_TYPE_TO_BSON: Record<ColumnType, string | string[]> = {\n  uuid: 'string',\n  string: 'string',\n  text: 'string',\n  integer: 'int',\n  bigint: 'long',\n  float: 'double',\n  decimal: 'decimal',\n  boolean: 'bool',\n  datetime: 'date',\n  date: 'date',\n  time: 'string',\n  json: 'object',\n  binary: 'binData',\n};\n\nfunction buildJsonSchema(def: TableDefinition): Record<string, unknown> {\n  const properties: Record<string, unknown> = {};\n  const required: string[] = [];\n\n  for (const [colName, colDef] of Object.entries(def.columns)) {\n    const bsonType = COLUMN_TYPE_TO_BSON[colDef.type];\n\n    properties[colName] = {\n      bsonType: colDef.nullable ? [bsonType, 'null'] : bsonType,\n    };\n\n    if (!colDef.nullable && colDef.default === undefined) {\n      required.push(colName);\n    }\n  }\n\n  return {\n    bsonType: 'object',\n    required: required.length > 0 ? required : undefined,\n    properties,\n  };\n}\n\nexport const mongoDialect: MongoDialect = {\n  name: 'mongodb',\n  supportsTransactionalDDL: true,\n\n  mapType(type: ColumnType): string {\n    const mapped = COLUMN_TYPE_TO_BSON[type];\n    return Array.isArray(mapped) ? mapped[0] : mapped;\n  },\n\n  createTable(name: string, def: TableDefinition): MongoMigrationOperation {\n    const jsonSchema = buildJsonSchema(def);\n\n    return {\n      operation: 'createCollection',\n      collection: name,\n      options: {\n        validator: {\n          $jsonSchema: jsonSchema,\n        },\n      },\n    };\n  },\n\n  dropTable(name: string): MongoMigrationOperation {\n    return {\n      operation: 'dropCollection',\n      collection: name,\n    };\n  },\n\n  addColumn(table: string, column: string, def: ColumnDefinition): MongoMigrationOperation {\n    const bsonType = this.mapType(def.type);\n    return {\n      operation: 'collMod',\n      collection: table,\n      options: {\n        validatorAction: 'addProperty',\n        property: column,\n        schema: {\n          bsonType: def.nullable ? [bsonType, 'null'] : bsonType,\n        },\n        required: !def.nullable && def.default === undefined,\n      },\n    };\n  },\n\n  dropColumn(table: string, column: string): MongoMigrationOperation {\n    return {\n      operation: 'collMod',\n      collection: table,\n      options: {\n        validatorAction: 'removeProperty',\n        property: column,\n      },\n    };\n  },\n\n  alterColumn(table: string, column: string, def: ColumnDefinition): MongoMigrationOperation {\n    const bsonType = this.mapType(def.type);\n    return {\n      operation: 'collMod',\n      collection: table,\n      options: {\n        validatorAction: 'modifyProperty',\n        property: column,\n        schema: {\n          bsonType: def.nullable ? [bsonType, 'null'] : bsonType,\n        },\n      },\n    };\n  },\n\n  createIndex(table: string, index: IndexDefinition): MongoMigrationOperation {\n    const keys: Record<string, 1 | -1> = {};\n    for (const col of index.columns) {\n      keys[col] = 1;\n    }\n\n    return {\n      operation: 'createIndex',\n      collection: table,\n      indexSpec: {\n        keys,\n        options: {\n          name: index.name ?? `idx_${table}_${index.columns.join('_')}`,\n          unique: index.unique ?? false,\n        },\n      },\n    };\n  },\n\n  dropIndex(name: string, table: string): MongoMigrationOperation {\n    return {\n      operation: 'dropIndex',\n      collection: table,\n      options: { indexName: name },\n    };\n  },\n};\n\nexport async function executeMongoMigration(\n  db: unknown,\n  operation: MongoMigrationOperation\n): Promise<void> {\n  const mongoDb = db as import('mongodb').Db;\n\n  switch (operation.operation) {\n    case 'createCollection': {\n      await mongoDb.createCollection(operation.collection, operation.options);\n      break;\n    }\n\n    case 'dropCollection': {\n      await mongoDb.dropCollection(operation.collection);\n      break;\n    }\n\n    case 'collMod': {\n      const opts = operation.options as {\n        validatorAction?: 'addProperty' | 'removeProperty' | 'modifyProperty';\n        property?: string;\n        schema?: Record<string, unknown>;\n        required?: boolean;\n      };\n\n      const collInfo = await mongoDb.listCollections({ name: operation.collection }).toArray();\n\n      if (collInfo.length === 0) {\n        throw new Error(`Collection ${operation.collection} does not exist`);\n      }\n\n      interface JsonSchema {\n        bsonType?: string;\n        properties?: Record<string, unknown>;\n        required?: string[];\n      }\n      const collOptions = collInfo[0] as { options?: { validator?: { $jsonSchema?: JsonSchema } } };\n      const existingValidator = collOptions.options?.validator ?? {};\n      const existingSchema: JsonSchema = existingValidator.$jsonSchema ?? {\n        bsonType: 'object',\n        properties: {},\n        required: [],\n      };\n\n      if (opts.validatorAction === 'addProperty' && opts.property && opts.schema) {\n        existingSchema.properties = existingSchema.properties || {};\n        existingSchema.properties[opts.property] = opts.schema;\n        if (opts.required) {\n          existingSchema.required = existingSchema.required || [];\n          if (!existingSchema.required.includes(opts.property)) {\n            existingSchema.required.push(opts.property);\n          }\n        }\n      } else if (opts.validatorAction === 'removeProperty' && opts.property) {\n        if (existingSchema.properties) {\n          delete existingSchema.properties[opts.property];\n        }\n        if (existingSchema.required) {\n          existingSchema.required = existingSchema.required.filter(\n            (r: string) => r !== opts.property\n          );\n        }\n      } else if (opts.validatorAction === 'modifyProperty' && opts.property && opts.schema) {\n        existingSchema.properties = existingSchema.properties || {};\n        existingSchema.properties[opts.property] = opts.schema;\n      }\n\n      await mongoDb.command({\n        collMod: operation.collection,\n        validator: { $jsonSchema: existingSchema },\n      });\n      break;\n    }\n\n    case 'createIndex': {\n      if (!operation.indexSpec) {\n        throw new Error('Index specification required for createIndex operation');\n      }\n      const collection = mongoDb.collection(operation.collection);\n      await collection.createIndex(operation.indexSpec.keys, operation.indexSpec.options);\n      break;\n    }\n\n    case 'dropIndex': {\n      const opts = operation.options as { indexName: string };\n      const collection = mongoDb.collection(operation.collection);\n      await collection.dropIndex(opts.indexName);\n      break;\n    }\n\n    default:\n      throw new Error(`Unsupported MongoDB migration operation: ${operation.operation}`);\n  }\n}\n","import type { DialectName } from '../../types/index.js';\nimport { mysqlDialect } from './mysql.js';\nimport { postgresDialect } from './postgresql.js';\nimport { sqliteDialect } from './sqlite.js';\nimport type { Dialect } from './types.js';\n\nexport type { Dialect } from './types.js';\nexport { mongoDialect, executeMongoMigration } from './mongodb.js';\nexport type { MongoDialect, MongoMigrationOperation } from './mongodb.js';\n\nexport function getDialect(name: DialectName): Dialect {\n  switch (name) {\n    case 'postgresql':\n      return postgresDialect;\n    case 'mysql':\n      return mysqlDialect;\n    case 'sqlite':\n      return sqliteDialect;\n    case 'mongodb':\n      throw new Error(\n        'MongoDB uses a different dialect interface. Use mongoDialect and executeMongoMigration instead.'\n      );\n    default:\n      throw new Error(`Unsupported dialect: ${name}`);\n  }\n}\n\nexport { postgresDialect, mysqlDialect, sqliteDialect };\n","import { createHash } from 'node:crypto';\nimport { readFile, readdir } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { Driver } from '../driver/types.js';\nimport type {\n  MigrationFile,\n  MigrationRecord,\n  MigrationResult,\n  MigrationStatus,\n} from '../types/index.js';\nimport { getDialect } from './dialects/index.js';\nimport type { Dialect } from './dialects/types.js';\n\nexport interface MigrationRunnerOptions {\n  migrationsPath: string;\n  tableName?: string;\n}\n\nexport interface MigrationRunOptions {\n  scope?: 'core' | 'template';\n  templateKey?: string;\n  moduleName?: string;\n  steps?: number;\n  toVersion?: number;\n  dryRun?: boolean;\n}\n\nexport class MigrationRunner {\n  private driver: Driver;\n  private dialect: Dialect;\n  private migrationsPath: string;\n  private tableName: string;\n\n  constructor(driver: Driver, options: MigrationRunnerOptions) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.migrationsPath = options.migrationsPath;\n    this.tableName = options.tableName ?? 'lp_migrations';\n  }\n\n  async ensureMigrationsTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          version BIGINT PRIMARY KEY,\n          name TEXT NOT NULL,\n          scope TEXT NOT NULL CHECK (scope IN ('core', 'template')),\n          template_key TEXT,\n          module_name TEXT,\n          checksum TEXT NOT NULL,\n          up_sql TEXT[] NOT NULL,\n          down_sql TEXT[],\n          applied_at TIMESTAMPTZ DEFAULT NOW(),\n          executed_by TEXT\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            version BIGINT PRIMARY KEY,\n            name VARCHAR(255) NOT NULL,\n            scope VARCHAR(20) NOT NULL,\n            template_key VARCHAR(255),\n            module_name VARCHAR(255),\n            checksum VARCHAR(64) NOT NULL,\n            up_sql JSON NOT NULL,\n            down_sql JSON,\n            applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            executed_by VARCHAR(255)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            version INTEGER PRIMARY KEY,\n            name TEXT NOT NULL,\n            scope TEXT NOT NULL CHECK (scope IN ('core', 'template')),\n            template_key TEXT,\n            module_name TEXT,\n            checksum TEXT NOT NULL,\n            up_sql TEXT NOT NULL,\n            down_sql TEXT,\n            applied_at TEXT DEFAULT (datetime('now')),\n            executed_by TEXT\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(`\n        CREATE UNIQUE INDEX IF NOT EXISTS idx_${this.tableName}_scope_version\n        ON \"${this.tableName}\" (scope, COALESCE(template_key, ''), version)\n      `);\n    }\n  }\n\n  async up(options: MigrationRunOptions = {}): Promise<MigrationResult[]> {\n    await this.ensureMigrationsTable();\n\n    const pending = await this.getPendingMigrations(options);\n    const results: MigrationResult[] = [];\n\n    let migrationsToRun = pending;\n    if (options.steps) {\n      migrationsToRun = pending.slice(0, options.steps);\n    }\n    if (options.toVersion) {\n      migrationsToRun = pending.filter((m) => m.version <= options.toVersion!);\n    }\n\n    for (const migration of migrationsToRun) {\n      const startTime = Date.now();\n\n      if (options.dryRun) {\n        console.log(`[DRY RUN] Would apply migration: ${migration.version}__${migration.name}`);\n        console.log(migration.up.join('\\n'));\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: 0,\n        });\n        continue;\n      }\n\n      try {\n        if (this.dialect.supportsTransactionalDDL) {\n          await this.driver.transaction(async (trx) => {\n            for (const sql of migration.up) {\n              await trx.execute(sql);\n            }\n            await this.recordMigration(trx, migration);\n          });\n        } else {\n          for (const sql of migration.up) {\n            await this.driver.execute(sql);\n          }\n          await this.recordMigration(this.driver, migration);\n        }\n\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: Date.now() - startTime,\n        });\n      } catch (error) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n        break;\n      }\n    }\n\n    return results;\n  }\n\n  async down(options: MigrationRunOptions = {}): Promise<MigrationResult[]> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const results: MigrationResult[] = [];\n\n    let migrationsToRollback = applied.reverse();\n    if (options.steps) {\n      migrationsToRollback = migrationsToRollback.slice(0, options.steps);\n    }\n    if (options.toVersion) {\n      migrationsToRollback = migrationsToRollback.filter((m) => m.version > options.toVersion!);\n    }\n\n    for (const migration of migrationsToRollback) {\n      if (!migration.downSql?.length) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: 'No down migration available',\n          duration: 0,\n        });\n        break;\n      }\n\n      const startTime = Date.now();\n\n      if (options.dryRun) {\n        console.log(`[DRY RUN] Would rollback migration: ${migration.version}__${migration.name}`);\n        console.log(migration.downSql.join('\\n'));\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: 0,\n        });\n        continue;\n      }\n\n      try {\n        if (this.dialect.supportsTransactionalDDL) {\n          await this.driver.transaction(async (trx) => {\n            for (const sql of migration.downSql) {\n              await trx.execute(sql);\n            }\n            await this.removeMigrationRecord(trx, migration.version);\n          });\n        } else {\n          for (const sql of migration.downSql) {\n            await this.driver.execute(sql);\n          }\n          await this.removeMigrationRecord(this.driver, migration.version);\n        }\n\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: true,\n          duration: Date.now() - startTime,\n        });\n      } catch (error) {\n        results.push({\n          version: migration.version,\n          name: migration.name,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n        break;\n      }\n    }\n\n    return results;\n  }\n\n  async status(options: MigrationRunOptions = {}): Promise<MigrationStatus> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const pending = await this.getPendingMigrations(options);\n    const current = applied.length ? applied[applied.length - 1].version : null;\n\n    return { applied, pending, current };\n  }\n\n  async verify(options: MigrationRunOptions = {}): Promise<{ valid: boolean; issues: string[] }> {\n    await this.ensureMigrationsTable();\n\n    const applied = await this.getAppliedMigrations(options);\n    const files = await this.loadMigrationFiles(options);\n    const issues: string[] = [];\n\n    for (const record of applied) {\n      const file = files.find((f) => f.version === record.version);\n      if (!file) {\n        issues.push(`Migration ${record.version}__${record.name} was applied but file is missing`);\n        continue;\n      }\n\n      const fileChecksum = this.computeChecksum(file.up);\n      if (fileChecksum !== record.checksum) {\n        issues.push(\n          `Migration ${record.version}__${record.name} checksum mismatch. File has been modified after being applied.`\n        );\n      }\n    }\n\n    return { valid: issues.length === 0, issues };\n  }\n\n  private sanitizeTemplateKey(templateKey: string): string {\n    if (!/^[a-zA-Z0-9_-]+$/.test(templateKey)) {\n      throw new Error(\n        `Invalid templateKey: \"${templateKey}\". Only alphanumeric characters, hyphens, and underscores are allowed.`\n      );\n    }\n    return templateKey;\n  }\n\n  private async loadMigrationFiles(options: MigrationRunOptions = {}): Promise<MigrationFile[]> {\n    const scope = options.scope ?? 'core';\n    let dirPath: string;\n\n    if (scope === 'template' && options.templateKey) {\n      const sanitizedKey = this.sanitizeTemplateKey(options.templateKey);\n      dirPath = join(this.migrationsPath, 'templates', sanitizedKey);\n    } else {\n      dirPath = join(this.migrationsPath, 'core');\n    }\n\n    try {\n      const files = await readdir(dirPath);\n      const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();\n\n      const migrations: MigrationFile[] = [];\n\n      for (const file of sqlFiles) {\n        const content = await readFile(join(dirPath, file), 'utf-8');\n        const parsed = this.parseMigrationFile(file, content, scope, options.templateKey);\n        if (parsed) {\n          migrations.push(parsed);\n        }\n      }\n\n      return migrations;\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  private parseMigrationFile(\n    filename: string,\n    content: string,\n    scope: 'core' | 'template',\n    templateKey?: string\n  ): MigrationFile | null {\n    const match = filename.match(/^(\\d+)__(.+)\\.sql$/);\n    if (!match) return null;\n\n    const [, versionStr, name] = match;\n    const version = Number.parseInt(versionStr, 10);\n\n    const upMatch = content.match(/--\\s*up\\s*\\n([\\s\\S]*?)(?=--\\s*down|$)/i);\n    const downMatch = content.match(/--\\s*down\\s*\\n([\\s\\S]*?)$/i);\n\n    const up = upMatch ? this.splitSqlStatements(upMatch[1]) : [];\n    const down = downMatch ? this.splitSqlStatements(downMatch[1]) : [];\n\n    if (!up.length) return null;\n\n    return {\n      version,\n      name,\n      up,\n      down,\n      scope,\n      templateKey,\n    };\n  }\n\n  private async getAppliedMigrations(\n    options: MigrationRunOptions = {}\n  ): Promise<MigrationRecord[]> {\n    const scope = options.scope ?? 'core';\n    const templateKey = options.templateKey ?? null;\n    const moduleName = options.moduleName ?? null;\n\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT version, name, scope, template_key, module_name, checksum, up_sql, down_sql, applied_at, executed_by\n        FROM \"${this.tableName}\"\n        WHERE scope = $1 AND (template_key = $2 OR (template_key IS NULL AND $2 IS NULL))\n          AND (module_name = $3 OR (module_name IS NULL AND $3 IS NULL))\n        ORDER BY version ASC\n      `;\n      params = [scope, templateKey, moduleName];\n    } else {\n      sql = `\n        SELECT version, name, scope, template_key, module_name, checksum, up_sql, down_sql, applied_at, executed_by\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE scope = ? AND (template_key = ? OR (template_key IS NULL AND ? IS NULL))\n          AND (module_name = ? OR (module_name IS NULL AND ? IS NULL))\n        ORDER BY version ASC\n      `;\n      params = [scope, templateKey, templateKey, moduleName, moduleName];\n    }\n\n    const result = await this.driver.query<{\n      version: number;\n      name: string;\n      scope: 'core' | 'template';\n      template_key: string | null;\n      module_name: string | null;\n      checksum: string;\n      up_sql: string[] | string;\n      down_sql: string[] | string | null;\n      applied_at: Date | string;\n      executed_by: string | null;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      version: Number(row.version),\n      name: row.name,\n      scope: row.scope,\n      templateKey: row.template_key,\n      moduleName: row.module_name,\n      checksum: row.checksum,\n      upSql: typeof row.up_sql === 'string' ? JSON.parse(row.up_sql) : row.up_sql,\n      downSql: row.down_sql\n        ? typeof row.down_sql === 'string'\n          ? JSON.parse(row.down_sql)\n          : row.down_sql\n        : [],\n      appliedAt: new Date(row.applied_at),\n      executedBy: row.executed_by,\n    }));\n  }\n\n  private async getPendingMigrations(options: MigrationRunOptions = {}): Promise<MigrationFile[]> {\n    const files = await this.loadMigrationFiles(options);\n    const applied = await this.getAppliedMigrations(options);\n    const appliedVersions = new Set(applied.map((m) => m.version));\n\n    return files.filter((f) => !appliedVersions.has(f.version));\n  }\n\n  private async recordMigration(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    migration: MigrationFile\n  ): Promise<void> {\n    const checksum = this.computeChecksum(migration.up);\n\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          migration.up,\n          migration.down.length ? migration.down : null,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await client.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          JSON.stringify(migration.up),\n          migration.down.length ? JSON.stringify(migration.down) : null,\n        ]\n      );\n    } else {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (version, name, scope, template_key, module_name, checksum, up_sql, down_sql)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n        [\n          migration.version,\n          migration.name,\n          migration.scope,\n          migration.templateKey ?? null,\n          migration.moduleName ?? null,\n          checksum,\n          JSON.stringify(migration.up),\n          migration.down.length ? JSON.stringify(migration.down) : null,\n        ]\n      );\n    }\n  }\n\n  private async removeMigrationRecord(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    version: number\n  ): Promise<void> {\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(`DELETE FROM \"${this.tableName}\" WHERE version = $1`, [version]);\n    } else {\n      await client.execute(\n        `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE version = ?`,\n        [version]\n      );\n    }\n  }\n\n  private computeChecksum(statements: string[]): string {\n    return createHash('sha256').update(statements.join('\\n')).digest('hex');\n  }\n\n  private splitSqlStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inSingleQuote) {\n        current += char;\n        if (char === \"'\" && next !== \"'\") {\n          inSingleQuote = false;\n        } else if (char === \"'\" && next === \"'\") {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (inDoubleQuote) {\n        current += char;\n        if (char === '\"' && next !== '\"') {\n          inDoubleQuote = false;\n        } else if (char === '\"' && next === '\"') {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\") {\n        inSingleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '\"') {\n        inDoubleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n\nexport function createMigrationRunner(\n  driver: Driver,\n  options: MigrationRunnerOptions\n): MigrationRunner {\n  return new MigrationRunner(driver, options);\n}\n","import { createHash } from 'node:crypto';\nimport type { Driver } from '../driver/types.js';\nimport { type Dialect, getDialect } from '../migrations/dialects/index.js';\nimport type { MigrationResult, SchemaDefinition, TableDefinition } from '../types/index.js';\n\nexport interface SchemaRegistryOptions {\n  tableName?: string;\n}\n\nexport interface RegisterSchemaOptions {\n  appId: string;\n  schemaName: string;\n  version: string;\n  schema: SchemaDefinition;\n}\n\nexport interface SchemaRecord {\n  app_id: string;\n  schema_name: string;\n  version: string;\n  schema: SchemaDefinition;\n  checksum: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport class SchemaRegistry {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: SchemaRegistryOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_schema_registry';\n  }\n\n  async ensureRegistryTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          app_id TEXT NOT NULL,\n          schema_name TEXT NOT NULL,\n          version TEXT NOT NULL,\n          schema JSONB NOT NULL,\n          checksum TEXT NOT NULL,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW(),\n          PRIMARY KEY (app_id, schema_name)\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            app_id VARCHAR(255) NOT NULL,\n            schema_name VARCHAR(255) NOT NULL,\n            version VARCHAR(50) NOT NULL,\n            schema JSON NOT NULL,\n            checksum VARCHAR(64) NOT NULL,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            PRIMARY KEY (app_id, schema_name)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            app_id TEXT NOT NULL,\n            schema_name TEXT NOT NULL,\n            version TEXT NOT NULL,\n            schema TEXT NOT NULL,\n            checksum TEXT NOT NULL,\n            created_at TEXT DEFAULT (datetime('now')),\n            updated_at TEXT DEFAULT (datetime('now')),\n            PRIMARY KEY (app_id, schema_name)\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n  }\n\n  async register(options: RegisterSchemaOptions): Promise<MigrationResult[]> {\n    await this.ensureRegistryTable();\n\n    this.validateSchema(options.schema);\n\n    const current = await this.getCurrentSchema(options.appId, options.schemaName);\n    const diff = this.computeDiff(current?.schema ?? null, options.schema);\n\n    if (diff.length === 0) {\n      return [];\n    }\n\n    const results: MigrationResult[] = [];\n    const checksum = this.computeChecksum(options.schema);\n\n    if (this.dialect.supportsTransactionalDDL) {\n      await this.driver.transaction(async (trx) => {\n        for (const change of diff) {\n          const startTime = Date.now();\n          try {\n            await trx.execute(change.sql);\n            results.push({\n              version: Date.now(),\n              name: change.description,\n              success: true,\n              duration: Date.now() - startTime,\n            });\n          } catch (error) {\n            results.push({\n              version: Date.now(),\n              name: change.description,\n              success: false,\n              error: error instanceof Error ? error.message : String(error),\n              duration: Date.now() - startTime,\n            });\n            throw error;\n          }\n        }\n\n        await this.upsertSchemaRecord(trx, {\n          appId: options.appId,\n          schemaName: options.schemaName,\n          version: options.version,\n          schema: options.schema,\n          checksum,\n        });\n      });\n    } else {\n      for (const change of diff) {\n        const startTime = Date.now();\n        try {\n          await this.driver.execute(change.sql);\n          results.push({\n            version: Date.now(),\n            name: change.description,\n            success: true,\n            duration: Date.now() - startTime,\n          });\n        } catch (error) {\n          results.push({\n            version: Date.now(),\n            name: change.description,\n            success: false,\n            error: error instanceof Error ? error.message : String(error),\n            duration: Date.now() - startTime,\n          });\n          throw error;\n        }\n      }\n\n      await this.upsertSchemaRecord(this.driver, {\n        appId: options.appId,\n        schemaName: options.schemaName,\n        version: options.version,\n        schema: options.schema,\n        checksum,\n      });\n    }\n\n    return results;\n  }\n\n  async getCurrentSchema(appId: string, schemaName: string): Promise<SchemaRecord | null> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT app_id, schema_name, version, schema, checksum, created_at, updated_at\n        FROM \"${this.tableName}\"\n        WHERE app_id = $1 AND schema_name = $2\n      `;\n      params = [appId, schemaName];\n    } else {\n      sql = `\n        SELECT app_id, schema_name, version, schema, checksum, created_at, updated_at\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE app_id = ? AND schema_name = ?\n      `;\n      params = [appId, schemaName];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      schema_name: string;\n      version: string;\n      schema: SchemaDefinition | string;\n      checksum: string;\n      created_at: Date | string;\n      updated_at: Date | string;\n    }>(sql, params);\n\n    if (!result.rows.length) return null;\n\n    const row = result.rows[0];\n    return {\n      app_id: row.app_id,\n      schema_name: row.schema_name,\n      version: row.version,\n      schema: typeof row.schema === 'string' ? JSON.parse(row.schema) : row.schema,\n      checksum: row.checksum,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    };\n  }\n\n  async listSchemas(appId?: string): Promise<SchemaRecord[]> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = appId\n        ? `SELECT * FROM \"${this.tableName}\" WHERE app_id = $1 ORDER BY schema_name`\n        : `SELECT * FROM \"${this.tableName}\" ORDER BY app_id, schema_name`;\n      params = appId ? [appId] : [];\n    } else {\n      const table = this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`;\n      sql = appId\n        ? `SELECT * FROM ${table} WHERE app_id = ? ORDER BY schema_name`\n        : `SELECT * FROM ${table} ORDER BY app_id, schema_name`;\n      params = appId ? [appId] : [];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      schema_name: string;\n      version: string;\n      schema: SchemaDefinition | string;\n      checksum: string;\n      created_at: Date | string;\n      updated_at: Date | string;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      app_id: row.app_id,\n      schema_name: row.schema_name,\n      version: row.version,\n      schema: typeof row.schema === 'string' ? JSON.parse(row.schema) : row.schema,\n      checksum: row.checksum,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n  }\n\n  private validateSchema(schema: SchemaDefinition): void {\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      if (!table.columns.app_id) {\n        throw new Error(`Table \"${tableName}\" must have an \"app_id\" column for multi-tenancy`);\n      }\n      if (!table.columns.organization_id) {\n        throw new Error(\n          `Table \"${tableName}\" must have an \"organization_id\" column for multi-tenancy`\n        );\n      }\n      if (!table.columns.id) {\n        throw new Error(`Table \"${tableName}\" must have an \"id\" column`);\n      }\n\n      const appIdCol = table.columns.app_id;\n      const orgIdCol = table.columns.organization_id;\n\n      if (!appIdCol.tenant) {\n        throw new Error(`Column \"app_id\" in table \"${tableName}\" must be marked as tenant column`);\n      }\n      if (!orgIdCol.tenant) {\n        throw new Error(\n          `Column \"organization_id\" in table \"${tableName}\" must be marked as tenant column`\n        );\n      }\n    }\n  }\n\n  private computeDiff(\n    current: SchemaDefinition | null,\n    desired: SchemaDefinition\n  ): Array<{ sql: string; description: string }> {\n    const changes: Array<{ sql: string; description: string }> = [];\n\n    for (const [tableName, desiredTable] of Object.entries(desired.tables)) {\n      const currentTable = current?.tables[tableName];\n\n      if (!currentTable) {\n        const sql = this.dialect.createTable(tableName, desiredTable);\n        changes.push({ sql, description: `Create table ${tableName}` });\n\n        if (desiredTable.indexes) {\n          for (const index of desiredTable.indexes) {\n            const indexSql = this.dialect.createIndex(tableName, index);\n            changes.push({\n              sql: indexSql,\n              description: `Create index on ${tableName}(${index.columns.join(', ')})`,\n            });\n          }\n        }\n\n        continue;\n      }\n\n      for (const [colName, desiredCol] of Object.entries(desiredTable.columns)) {\n        const currentCol = currentTable.columns[colName];\n\n        if (!currentCol) {\n          const sql = this.dialect.addColumn(tableName, colName, desiredCol);\n          changes.push({ sql, description: `Add column ${tableName}.${colName}` });\n        } else if (!this.columnsEqual(currentCol, desiredCol)) {\n          try {\n            const sql = this.dialect.alterColumn(tableName, colName, desiredCol);\n            changes.push({ sql, description: `Alter column ${tableName}.${colName}` });\n          } catch (error) {\n            console.warn(`Cannot alter column ${tableName}.${colName}: ${error}`);\n          }\n        }\n      }\n\n      for (const colName of Object.keys(currentTable.columns)) {\n        if (!desiredTable.columns[colName]) {\n          try {\n            const sql = this.dialect.dropColumn(tableName, colName);\n            changes.push({ sql, description: `Drop column ${tableName}.${colName}` });\n          } catch (error) {\n            console.warn(`Cannot drop column ${tableName}.${colName}: ${error}`);\n          }\n        }\n      }\n    }\n\n    if (current) {\n      for (const tableName of Object.keys(current.tables)) {\n        if (!desired.tables[tableName]) {\n          const sql = this.dialect.dropTable(tableName);\n          changes.push({ sql, description: `Drop table ${tableName}` });\n        }\n      }\n    }\n\n    return changes;\n  }\n\n  private columnsEqual(\n    a: TableDefinition['columns'][string],\n    b: TableDefinition['columns'][string]\n  ): boolean {\n    return (\n      a.type === b.type &&\n      a.nullable === b.nullable &&\n      a.unique === b.unique &&\n      a.default === b.default &&\n      JSON.stringify(a.references) === JSON.stringify(b.references)\n    );\n  }\n\n  private async upsertSchemaRecord(\n    client:\n      | Driver\n      | { execute: (sql: string, params?: unknown[]) => Promise<{ rowCount: number }> },\n    data: {\n      appId: string;\n      schemaName: string;\n      version: string;\n      schema: SchemaDefinition;\n      checksum: string;\n    }\n  ): Promise<void> {\n    const schemaJson = JSON.stringify(data.schema);\n\n    if (this.dialect.name === 'postgresql') {\n      await client.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (app_id, schema_name, version, schema, checksum)\n        VALUES ($1, $2, $3, $4, $5)\n        ON CONFLICT (app_id, schema_name) DO UPDATE SET\n          version = EXCLUDED.version,\n          schema = EXCLUDED.schema,\n          checksum = EXCLUDED.checksum,\n          updated_at = NOW()\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await client.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (app_id, schema_name, version, schema, checksum)\n        VALUES (?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          version = VALUES(version),\n          schema = VALUES(schema),\n          checksum = VALUES(checksum)\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    } else {\n      await client.execute(\n        `\n        INSERT OR REPLACE INTO \"${this.tableName}\" (app_id, schema_name, version, schema, checksum, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, datetime('now'), datetime('now'))\n        `,\n        [data.appId, data.schemaName, data.version, schemaJson, data.checksum]\n      );\n    }\n  }\n\n  private computeChecksum(schema: SchemaDefinition): string {\n    return createHash('sha256').update(JSON.stringify(schema)).digest('hex');\n  }\n}\n\nexport function createSchemaRegistry(\n  driver: Driver,\n  options?: SchemaRegistryOptions\n): SchemaRegistry {\n  return new SchemaRegistry(driver, options);\n}\n","import { MongoCompiler, SQLCompiler } from './compiler/index.js';\nimport { isMongoDriver } from './driver/mongodb.js';\nimport type { Driver, TransactionClient } from './driver/types.js';\nimport { type MigrationRunOptions, MigrationRunner } from './migrations/runner.js';\nimport { MongoTableBuilder, TableBuilder } from './query-builder/index.js';\nimport { type RegisterSchemaOptions, SchemaRegistry } from './schema/registry.js';\nimport type { QueryResult, TenantContext } from './types/index.js';\nimport { validateTenantContext } from './utils/tenant-validation.js';\n\nexport interface DbClientOptions {\n  migrationsPath?: string;\n  tenantColumns?: {\n    appId: string;\n    organizationId: string;\n  };\n  strictTenantMode?: boolean;\n}\n\nexport class DbClient {\n  private driver: Driver;\n  private compiler: SQLCompiler | MongoCompiler;\n  private migrationRunner?: MigrationRunner;\n  private schemaRegistry: SchemaRegistry;\n  private strictTenantMode: boolean;\n\n  constructor(driver: Driver, options: DbClientOptions = {}) {\n    this.driver = driver;\n\n    if (driver.dialect === 'mongodb') {\n      this.compiler = new MongoCompiler({\n        injectTenant: true,\n        tenantColumns: options.tenantColumns,\n      });\n    } else {\n      this.compiler = new SQLCompiler({\n        dialect: driver.dialect,\n        injectTenant: true,\n        tenantColumns: options.tenantColumns,\n      });\n    }\n\n    if (options.migrationsPath && driver.dialect !== 'mongodb') {\n      this.migrationRunner = new MigrationRunner(driver, {\n        migrationsPath: options.migrationsPath,\n      });\n    }\n\n    this.schemaRegistry = new SchemaRegistry(driver);\n    this.strictTenantMode = options.strictTenantMode ?? true;\n  }\n\n  table<T = Record<string, unknown>>(\n    name: string,\n    ctx: TenantContext\n  ): TableBuilder<T> | MongoTableBuilder<T> {\n    if (this.strictTenantMode) {\n      validateTenantContext(ctx, name);\n    }\n    if (isMongoDriver(this.driver)) {\n      return new MongoTableBuilder<T>(this.driver, this.compiler as MongoCompiler, name, ctx, true);\n    }\n    return new TableBuilder<T>(this.driver, this.compiler as SQLCompiler, name, ctx, true);\n  }\n\n  tableWithoutTenant<T = Record<string, unknown>>(\n    name: string\n  ): TableBuilder<T> | MongoTableBuilder<T> {\n    if (isMongoDriver(this.driver)) {\n      const compilerWithoutTenant = new MongoCompiler({ injectTenant: false });\n      return new MongoTableBuilder<T>(this.driver, compilerWithoutTenant, name, undefined, false);\n    }\n    const compilerWithoutTenant = new SQLCompiler({\n      dialect: this.driver.dialect,\n      injectTenant: false,\n    });\n    return new TableBuilder<T>(this.driver, compilerWithoutTenant, name, undefined, false);\n  }\n\n  async transaction<T>(\n    ctx: TenantContext,\n    fn: (trx: TransactionContext) => Promise<T>\n  ): Promise<T> {\n    return this.driver.transaction(async (trxClient) => {\n      if (this.driver.dialect === 'postgresql') {\n        await trxClient.execute(`SELECT set_config('app.current_app_id', $1, true)`, [ctx.appId]);\n        await trxClient.execute(`SELECT set_config('app.current_org_id', $1, true)`, [\n          ctx.organizationId,\n        ]);\n      }\n\n      const trxContext = new TransactionContext(trxClient, this.compiler, ctx);\n      return fn(trxContext);\n    });\n  }\n\n  async raw<T = Record<string, unknown>>(sql: string, params?: unknown[]): Promise<QueryResult<T>> {\n    return this.driver.query<T>(sql, params);\n  }\n\n  async rawWithTenant<T = Record<string, unknown>>(\n    ctx: TenantContext,\n    sql: string,\n    params: unknown[] = []\n  ): Promise<QueryResult<T>> {\n    const tenantParams = [ctx.appId, ctx.organizationId, ...params];\n    return this.driver.query<T>(sql, tenantParams);\n  }\n\n  async execute(sql: string, params?: unknown[]): Promise<{ rowCount: number }> {\n    return this.driver.execute(sql, params);\n  }\n\n  get migrations() {\n    if (!this.migrationRunner) {\n      throw new Error('Migrations path not configured. Pass migrationsPath to DbClient options.');\n    }\n    return {\n      up: (options?: MigrationRunOptions) => this.migrationRunner!.up(options),\n      down: (options?: MigrationRunOptions) => this.migrationRunner!.down(options),\n      status: (options?: MigrationRunOptions) => this.migrationRunner!.status(options),\n      verify: (options?: MigrationRunOptions) => this.migrationRunner!.verify(options),\n    };\n  }\n\n  get schema() {\n    return {\n      register: (options: RegisterSchemaOptions) => this.schemaRegistry.register(options),\n      get: (appId: string, schemaName: string) =>\n        this.schemaRegistry.getCurrentSchema(appId, schemaName),\n      list: (appId?: string) => this.schemaRegistry.listSchemas(appId),\n    };\n  }\n\n  get dialect() {\n    return this.driver.dialect;\n  }\n\n  async close(): Promise<void> {\n    return this.driver.close();\n  }\n}\n\nexport class TransactionContext {\n  private client: TransactionClient;\n  private compiler: SQLCompiler | MongoCompiler;\n  private ctx: TenantContext;\n\n  constructor(\n    client: TransactionClient,\n    compiler: SQLCompiler | MongoCompiler,\n    ctx: TenantContext\n  ) {\n    this.client = client;\n    this.compiler = compiler;\n    this.ctx = ctx;\n  }\n\n  table<T = Record<string, unknown>>(name: string): TableBuilder<T> {\n    return new TableBuilder<T>(this.client, this.compiler as SQLCompiler, name, this.ctx, true);\n  }\n\n  async raw<T = Record<string, unknown>>(sql: string, params?: unknown[]): Promise<QueryResult<T>> {\n    return this.client.query<T>(sql, params);\n  }\n\n  async execute(sql: string, params?: unknown[]): Promise<{ rowCount: number }> {\n    return this.client.execute(sql, params);\n  }\n}\n\nexport function createDbClient(driver: Driver, options?: DbClientOptions): DbClient {\n  return new DbClient(driver, options);\n}\n","import type { ColumnType, IndexDefinition } from '../types/index.js';\n\nexport interface EntityMetadata {\n  tableName: string;\n  columns: Map<string, ColumnMetadata>;\n  indexes: IndexDefinition[];\n  relations: Map<string, RelationMetadata>;\n}\n\nexport interface ColumnMetadata {\n  propertyName: string;\n  columnName: string;\n  type: ColumnType;\n  primaryKey: boolean;\n  nullable: boolean;\n  unique: boolean;\n  default?: string;\n  tenant: boolean;\n  references?: {\n    table: string;\n    column: string;\n    onDelete?: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n    onUpdate?: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n  };\n}\n\nexport interface RelationMetadata {\n  propertyName: string;\n  type: 'one-to-many' | 'many-to-one' | 'one-to-one' | 'many-to-many';\n  target: () => Function;\n  inverseSide?: string;\n  foreignKey?: string;\n  joinTable?: string;\n}\n\nexport type EntityConstructor<T = unknown> = new (...args: unknown[]) => T;\n\nclass MetadataStorage {\n  private entities: Map<Function, EntityMetadata> = new Map();\n\n  registerEntity(target: Function, tableName: string): void {\n    if (!this.entities.has(target)) {\n      this.entities.set(target, {\n        tableName,\n        columns: new Map(),\n        indexes: [],\n        relations: new Map(),\n      });\n    } else {\n      const metadata = this.entities.get(target)!;\n      metadata.tableName = tableName;\n    }\n  }\n\n  registerColumn(target: Function, propertyName: string, metadata: Partial<ColumnMetadata>): void {\n    this.ensureEntity(target);\n    const entity = this.entities.get(target)!;\n\n    const existing = entity.columns.get(propertyName) || {\n      propertyName,\n      columnName: this.toSnakeCase(propertyName),\n      type: 'string' as ColumnType,\n      primaryKey: false,\n      nullable: true,\n      unique: false,\n      tenant: false,\n    };\n\n    entity.columns.set(propertyName, { ...existing, ...metadata });\n  }\n\n  registerRelation(target: Function, propertyName: string, metadata: RelationMetadata): void {\n    this.ensureEntity(target);\n    const entity = this.entities.get(target)!;\n    entity.relations.set(propertyName, metadata);\n  }\n\n  registerIndex(target: Function, index: IndexDefinition): void {\n    this.ensureEntity(target);\n    const entity = this.entities.get(target)!;\n    entity.indexes.push(index);\n  }\n\n  getEntityMetadata(target: Function): EntityMetadata | undefined {\n    return this.entities.get(target);\n  }\n\n  getAllEntities(): Map<Function, EntityMetadata> {\n    return this.entities;\n  }\n\n  hasEntity(target: Function): boolean {\n    return this.entities.has(target);\n  }\n\n  private ensureEntity(target: Function): void {\n    if (!this.entities.has(target)) {\n      this.entities.set(target, {\n        tableName: this.toSnakeCase(target.name),\n        columns: new Map(),\n        indexes: [],\n        relations: new Map(),\n      });\n    }\n  }\n\n  private toSnakeCase(str: string): string {\n    return str\n      .replace(/([A-Z])/g, '_$1')\n      .toLowerCase()\n      .replace(/^_/, '');\n  }\n\n  clear(): void {\n    this.entities.clear();\n  }\n}\n\nexport const metadataStorage = new MetadataStorage();\n","import type { ColumnType } from '../types/index.js';\nimport { metadataStorage } from './metadata.js';\n\nexport interface ColumnOptions {\n  name?: string;\n  nullable?: boolean;\n  unique?: boolean;\n  default?: string;\n  references?: {\n    table: string;\n    column: string;\n    onDelete?: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n    onUpdate?: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n  };\n}\n\nexport interface EntityOptions {\n  name?: string;\n}\n\nexport interface IndexOptions {\n  name?: string;\n  columns: string[];\n  unique?: boolean;\n  where?: string;\n}\n\nexport function Entity(tableNameOrOptions?: string | EntityOptions): ClassDecorator {\n  return (target: Function) => {\n    const tableName =\n      typeof tableNameOrOptions === 'string'\n        ? tableNameOrOptions\n        : tableNameOrOptions?.name || toSnakeCase(target.name);\n\n    metadataStorage.registerEntity(target, tableName);\n  };\n}\n\nexport function Column(type: ColumnType, options?: ColumnOptions): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      propertyName,\n      columnName: options?.name || toSnakeCase(propertyName),\n      type,\n      nullable: options?.nullable ?? true,\n      unique: options?.unique ?? false,\n      default: options?.default,\n      references: options?.references,\n      primaryKey: false,\n      tenant: false,\n    });\n  };\n}\n\nexport function PrimaryKey(): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      primaryKey: true,\n      nullable: false,\n    });\n  };\n}\n\nexport function TenantColumn(): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      tenant: true,\n      nullable: false,\n    });\n  };\n}\n\nexport function Unique(): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      unique: true,\n    });\n  };\n}\n\nexport function Nullable(): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      nullable: true,\n    });\n  };\n}\n\nexport function Default(value: string): PropertyDecorator {\n  return (target: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerColumn(target.constructor, propertyName, {\n      default: value,\n    });\n  };\n}\n\nexport function Index(options: IndexOptions): ClassDecorator {\n  return (target: Function) => {\n    metadataStorage.registerIndex(target, {\n      name: options.name,\n      columns: options.columns,\n      unique: options.unique,\n      where: options.where,\n    });\n  };\n}\n\nexport function OneToMany(target: () => Function, inverseSide: string): PropertyDecorator {\n  return (targetClass: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerRelation(targetClass.constructor, propertyName, {\n      propertyName,\n      type: 'one-to-many',\n      target,\n      inverseSide,\n    });\n  };\n}\n\nexport function ManyToOne(\n  target: () => Function,\n  options?: { foreignKey?: string }\n): PropertyDecorator {\n  return (targetClass: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerRelation(targetClass.constructor, propertyName, {\n      propertyName,\n      type: 'many-to-one',\n      target,\n      foreignKey: options?.foreignKey,\n    });\n  };\n}\n\nexport function OneToOne(\n  target: () => Function,\n  options?: { foreignKey?: string; inverseSide?: string }\n): PropertyDecorator {\n  return (targetClass: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerRelation(targetClass.constructor, propertyName, {\n      propertyName,\n      type: 'one-to-one',\n      target,\n      foreignKey: options?.foreignKey,\n      inverseSide: options?.inverseSide,\n    });\n  };\n}\n\nexport function ManyToMany(\n  target: () => Function,\n  options?: { joinTable?: string; inverseSide?: string }\n): PropertyDecorator {\n  return (targetClass: object, propertyKey: string | symbol) => {\n    const propertyName = String(propertyKey);\n    metadataStorage.registerRelation(targetClass.constructor, propertyName, {\n      propertyName,\n      type: 'many-to-many',\n      target,\n      joinTable: options?.joinTable,\n      inverseSide: options?.inverseSide,\n    });\n  };\n}\n\nfunction toSnakeCase(str: string): string {\n  return str\n    .replace(/([A-Z])/g, '_$1')\n    .toLowerCase()\n    .replace(/^_/, '');\n}\n","import { metadataStorage } from './metadata.js';\n\nexport function applyTenantColumns(target: Function): void {\n  metadataStorage.registerColumn(target, 'app_id', {\n    propertyName: 'app_id',\n    columnName: 'app_id',\n    type: 'string',\n    primaryKey: false,\n    nullable: false,\n    unique: false,\n    tenant: true,\n  });\n\n  metadataStorage.registerColumn(target, 'organization_id', {\n    propertyName: 'organization_id',\n    columnName: 'organization_id',\n    type: 'uuid',\n    primaryKey: false,\n    nullable: false,\n    unique: false,\n    tenant: true,\n  });\n}\n\nexport function applyTimestampColumns(target: Function): void {\n  metadataStorage.registerColumn(target, 'created_at', {\n    propertyName: 'created_at',\n    columnName: 'created_at',\n    type: 'datetime',\n    primaryKey: false,\n    nullable: false,\n    unique: false,\n    tenant: false,\n    default: 'NOW()',\n  });\n\n  metadataStorage.registerColumn(target, 'updated_at', {\n    propertyName: 'updated_at',\n    columnName: 'updated_at',\n    type: 'datetime',\n    primaryKey: false,\n    nullable: false,\n    unique: false,\n    tenant: false,\n    default: 'NOW()',\n  });\n}\n\nexport function WithTenantColumns(): ClassDecorator {\n  return (target: Function) => {\n    applyTenantColumns(target);\n  };\n}\n\nexport function WithTimestamps(): ClassDecorator {\n  return (target: Function) => {\n    applyTimestampColumns(target);\n  };\n}\n\nexport abstract class TenantEntity {\n  app_id!: string;\n  organization_id!: string;\n}\n\nexport abstract class TimestampedEntity {\n  created_at!: Date;\n  updated_at!: Date;\n}\n\nexport abstract class TenantTimestampedEntity {\n  app_id!: string;\n  organization_id!: string;\n  created_at!: Date;\n  updated_at!: Date;\n}\n","import type {\n  ColumnDefinition,\n  IndexDefinition,\n  SchemaDefinition,\n  TableDefinition,\n} from '../types/index.js';\nimport { type EntityConstructor, type EntityMetadata, metadataStorage } from './metadata.js';\n\nexport interface ExtractSchemaOptions {\n  entities: EntityConstructor[];\n}\n\nexport function extractSchemaFromEntities(entities: EntityConstructor[]): SchemaDefinition {\n  const tables: Record<string, TableDefinition> = {};\n\n  for (const entity of entities) {\n    const metadata = metadataStorage.getEntityMetadata(entity);\n    if (!metadata) {\n      throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n    }\n\n    tables[metadata.tableName] = extractTableDefinition(metadata);\n  }\n\n  return { tables };\n}\n\nexport function extractSchemaFromEntity(entity: EntityConstructor): SchemaDefinition {\n  return extractSchemaFromEntities([entity]);\n}\n\nexport function extractTableDefinition(metadata: EntityMetadata): TableDefinition {\n  const columns: Record<string, ColumnDefinition> = {};\n  const primaryKeyColumns: string[] = [];\n\n  for (const [, columnMeta] of metadata.columns) {\n    const columnDef: ColumnDefinition = {\n      type: columnMeta.type,\n      nullable: columnMeta.nullable,\n    };\n\n    if (columnMeta.primaryKey) {\n      columnDef.primaryKey = true;\n      primaryKeyColumns.push(columnMeta.columnName);\n    }\n\n    if (columnMeta.unique) {\n      columnDef.unique = true;\n    }\n\n    if (columnMeta.default) {\n      columnDef.default = columnMeta.default;\n    }\n\n    if (columnMeta.tenant) {\n      columnDef.tenant = true;\n    }\n\n    if (columnMeta.references) {\n      columnDef.references = columnMeta.references;\n    }\n\n    columns[columnMeta.columnName] = columnDef;\n  }\n\n  const indexes: IndexDefinition[] = metadata.indexes.map((idx) => ({\n    name: idx.name,\n    columns: idx.columns,\n    unique: idx.unique,\n    where: idx.where,\n  }));\n\n  const tableDef: TableDefinition = {\n    columns,\n  };\n\n  if (indexes.length > 0) {\n    tableDef.indexes = indexes;\n  }\n\n  if (primaryKeyColumns.length > 1) {\n    tableDef.primaryKey = primaryKeyColumns;\n  }\n\n  return tableDef;\n}\n\nexport function getEntityTableName(entity: EntityConstructor): string {\n  const metadata = metadataStorage.getEntityMetadata(entity);\n  if (!metadata) {\n    throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n  }\n  return metadata.tableName;\n}\n\nexport function getEntityColumns(entity: EntityConstructor): Map<string, string> {\n  const metadata = metadataStorage.getEntityMetadata(entity);\n  if (!metadata) {\n    throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n  }\n\n  const columnMap = new Map<string, string>();\n  for (const [propertyName, columnMeta] of metadata.columns) {\n    columnMap.set(propertyName, columnMeta.columnName);\n  }\n  return columnMap;\n}\n\nexport function propertyToColumn(entity: EntityConstructor, propertyName: string): string {\n  const metadata = metadataStorage.getEntityMetadata(entity);\n  if (!metadata) {\n    throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n  }\n\n  const column = metadata.columns.get(propertyName);\n  if (!column) {\n    throw new Error(`Property ${propertyName} not found on entity ${entity.name}`);\n  }\n\n  return column.columnName;\n}\n\nexport function columnToProperty(entity: EntityConstructor, columnName: string): string {\n  const metadata = metadataStorage.getEntityMetadata(entity);\n  if (!metadata) {\n    throw new Error(`Entity ${entity.name} is not decorated with @Entity`);\n  }\n\n  for (const [propertyName, columnMeta] of metadata.columns) {\n    if (columnMeta.columnName === columnName) {\n      return propertyName;\n    }\n  }\n\n  throw new Error(`Column ${columnName} not found on entity ${entity.name}`);\n}\n","import type { DbClient, TransactionContext } from '../client.js';\nimport type { Operator, TenantContext } from '../types/index.js';\nimport type { EntityConstructor } from './metadata.js';\nimport { getEntityColumns, getEntityTableName } from './schema-extractor.js';\n\nexport type WhereCondition<T> = Partial<T> | [keyof T, Operator, unknown][];\n\nexport interface FindOptions<T> {\n  where?: WhereCondition<T>;\n  orderBy?: { [K in keyof T]?: 'asc' | 'desc' };\n  limit?: number;\n  offset?: number;\n  select?: (keyof T)[];\n}\n\nexport interface FindOneOptions<T> {\n  where?: WhereCondition<T>;\n  select?: (keyof T)[];\n}\n\nexport class Repository<T> {\n  private db: DbClient | TransactionContext;\n  private tenantContext?: TenantContext;\n  private tableName: string;\n  private columnMap: Map<string, string>;\n\n  constructor(\n    entity: EntityConstructor<T>,\n    db: DbClient | TransactionContext,\n    tenantContext?: TenantContext\n  ) {\n    this.db = db;\n    this.tenantContext = tenantContext;\n    this.tableName = getEntityTableName(entity);\n    this.columnMap = getEntityColumns(entity);\n  }\n\n  async find(options: FindOptions<T> = {}): Promise<T[]> {\n    const builder = this.createTableBuilder();\n\n    let selectBuilder = builder.select(\n      ...(options.select ? options.select.map((p) => this.toColumn(p as string)) : ['*'])\n    );\n\n    if (options.where) {\n      selectBuilder = this.applyWhere(selectBuilder, options.where);\n    }\n\n    if (options.orderBy) {\n      for (const [property, direction] of Object.entries(options.orderBy)) {\n        selectBuilder = selectBuilder.orderBy(this.toColumn(property), direction as 'asc' | 'desc');\n      }\n    }\n\n    if (options.limit !== undefined) {\n      selectBuilder = selectBuilder.limit(options.limit);\n    }\n\n    if (options.offset !== undefined) {\n      selectBuilder = selectBuilder.offset(options.offset);\n    }\n\n    const rows = await selectBuilder.execute();\n    return rows.map((row: Record<string, unknown>) => this.rowToEntity(row));\n  }\n\n  async findOne(options: FindOneOptions<T> = {}): Promise<T | null> {\n    const results = await this.find({ ...options, limit: 1 });\n    return results[0] || null;\n  }\n\n  async findById(id: string | number): Promise<T | null> {\n    return this.findOne({ where: { id } as unknown as WhereCondition<T> });\n  }\n\n  async create(data: Partial<T>): Promise<T> {\n    const builder = this.createTableBuilder();\n    const columnData = this.entityToRow(data);\n\n    const rows = await builder.insert().values(columnData).returning('*').execute();\n\n    if (rows.length === 0) {\n      throw new Error('Insert did not return any rows');\n    }\n\n    return this.rowToEntity(rows[0] as Record<string, unknown>);\n  }\n\n  async createMany(data: Partial<T>[]): Promise<T[]> {\n    const results: T[] = [];\n    for (const item of data) {\n      const created = await this.create(item);\n      results.push(created);\n    }\n    return results;\n  }\n\n  async update(where: WhereCondition<T>, data: Partial<T>): Promise<T[]> {\n    const builder = this.createTableBuilder();\n    const columnData = this.entityToRow(data);\n\n    let updateBuilder = builder.update().set(columnData);\n    updateBuilder = this.applyWhereToUpdate(updateBuilder, where);\n\n    const rows = await updateBuilder.returning('*').execute();\n    return rows.map((row: Record<string, unknown>) => this.rowToEntity(row));\n  }\n\n  async updateById(id: string | number, data: Partial<T>): Promise<T | null> {\n    const results = await this.update({ id } as unknown as WhereCondition<T>, data);\n    return results[0] || null;\n  }\n\n  async delete(where: WhereCondition<T>): Promise<number> {\n    const builder = this.createTableBuilder();\n    let deleteBuilder = builder.delete();\n    deleteBuilder = this.applyWhereToDelete(deleteBuilder, where);\n\n    const rows = await deleteBuilder.execute();\n    return rows.length;\n  }\n\n  async deleteById(id: string | number): Promise<boolean> {\n    const count = await this.delete({ id } as unknown as WhereCondition<T>);\n    return count > 0;\n  }\n\n  async count(where?: WhereCondition<T>): Promise<number> {\n    const builder = this.createTableBuilder();\n    const selectBuilder = builder.select();\n\n    if (where) {\n      this.applyWhere(selectBuilder, where);\n    }\n\n    const countResult = await selectBuilder.count();\n    return countResult;\n  }\n\n  async exists(where: WhereCondition<T>): Promise<boolean> {\n    const count = await this.count(where);\n    return count > 0;\n  }\n\n  private isDbClient(db: DbClient | TransactionContext): db is DbClient {\n    return 'tableWithoutTenant' in db;\n  }\n\n  private createTableBuilder() {\n    if (this.isDbClient(this.db)) {\n      if (!this.tenantContext) {\n        throw new Error(\n          'TenantContext is required when using Repository with DbClient. ' +\n            'Either provide tenantContext or use Repository within a transaction.'\n        );\n      }\n      return this.db.table(this.tableName, this.tenantContext);\n    }\n    return this.db.table(this.tableName);\n  }\n\n  private toColumn(propertyName: string): string {\n    return this.columnMap.get(propertyName) || propertyName;\n  }\n\n  private applyWhere<B extends { where: (col: string, op: Operator, val: unknown) => B }>(\n    builder: B,\n    where: WhereCondition<T>\n  ): B {\n    if (Array.isArray(where)) {\n      for (const [property, op, value] of where) {\n        builder = builder.where(this.toColumn(property as string), op, value);\n      }\n    } else {\n      for (const [property, value] of Object.entries(where)) {\n        if (value !== undefined) {\n          builder = builder.where(this.toColumn(property), '=', value);\n        }\n      }\n    }\n    return builder;\n  }\n\n  private applyWhereToUpdate<B extends { where: (col: string, op: Operator, val: unknown) => B }>(\n    builder: B,\n    where: WhereCondition<T>\n  ): B {\n    return this.applyWhere(builder, where);\n  }\n\n  private applyWhereToDelete<B extends { where: (col: string, op: Operator, val: unknown) => B }>(\n    builder: B,\n    where: WhereCondition<T>\n  ): B {\n    return this.applyWhere(builder, where);\n  }\n\n  private entityToRow(entity: Partial<T>): Record<string, unknown> {\n    const row: Record<string, unknown> = {};\n    for (const [property, value] of Object.entries(entity)) {\n      if (value !== undefined) {\n        const columnName = this.toColumn(property);\n        row[columnName] = value;\n      }\n    }\n    return row;\n  }\n\n  private rowToEntity(row: Record<string, unknown>): T {\n    const entity: Record<string, unknown> = {};\n    for (const [property, columnName] of this.columnMap) {\n      if (columnName in row) {\n        entity[property] = row[columnName];\n      }\n    }\n    for (const [key, value] of Object.entries(row)) {\n      if (!(key in entity)) {\n        entity[key] = value;\n      }\n    }\n    return entity as T;\n  }\n}\n\nexport function createRepository<T>(\n  entity: EntityConstructor<T>,\n  db: DbClient | TransactionContext,\n  tenantContext?: TenantContext\n): Repository<T> {\n  return new Repository(entity, db, tenantContext);\n}\n","export * from './types/index.js';\n\nexport * from './orm/index.js';\n\nexport {\n  createDriver,\n  detectDialect,\n  createHealthCheckResult,\n  getDefaultHealthCheckConfig,\n  createPoolMonitor,\n  isRetryableError,\n  withRetry,\n  createTimeoutPromise,\n  registerSignalHandlers,\n  QueryTracker,\n} from './driver/index.js';\nexport type {\n  Driver,\n  DriverConfig,\n  TransactionClient,\n  CreateDriverOptions,\n  PoolStats,\n  HealthCheckResult,\n  HealthCheckConfig,\n  PoolMonitorConfig,\n  PoolMonitor,\n  RetryConfig,\n  DrainOptions,\n  DrainProgress,\n  DrainResult,\n  DrainPhase,\n  QueryInfo,\n  SignalHandlerOptions,\n} from './driver/index.js';\n\nexport { SQLCompiler, createCompiler } from './compiler/index.js';\nexport type { CompilerOptions } from './compiler/index.js';\n\nexport {\n  SelectBuilder,\n  InsertBuilder,\n  UpdateBuilder,\n  DeleteBuilder,\n  TableBuilder,\n} from './query-builder/index.js';\n\nexport {\n  MigrationRunner,\n  createMigrationRunner,\n} from './migrations/index.js';\nexport type { MigrationRunnerOptions, MigrationRunOptions } from './migrations/index.js';\nexport { getDialect, postgresDialect, mysqlDialect, sqliteDialect } from './migrations/index.js';\nexport type { Dialect } from './migrations/index.js';\n\nexport {\n  ModuleRegistry,\n  createModuleRegistry,\n  MigrationCollector,\n  createMigrationCollector,\n} from './modules/index.js';\nexport type {\n  ModuleRegistryOptions,\n  MigrationCollectorOptions,\n  ModuleDefinition,\n  ModuleMigrationSource,\n} from './modules/index.js';\n\nexport { SchemaRegistry, createSchemaRegistry } from './schema/index.js';\nexport type { SchemaRegistryOptions, RegisterSchemaOptions } from './schema/index.js';\n\nexport {\n  SchemaIntrospector,\n  createSchemaIntrospector,\n  SchemaDiffEngine,\n  createSchemaDiffEngine,\n  SchemaSyncService,\n  createSchemaSyncService,\n  SyncMetadataManager,\n  createSyncMetadataManager,\n  SchemaRemoteError,\n  BreakingChangeError,\n  ConflictError,\n  AuthenticationError,\n  UserCancelledError,\n} from './schema/index.js';\nexport type {\n  SchemaDiffOptions,\n  SchemaSyncServiceOptions,\n  Logger,\n  SyncMetadataOptions,\n  IntrospectedColumn,\n  IntrospectedIndex,\n  IntrospectedForeignKey,\n  IntrospectedConstraint,\n  IntrospectedTable,\n  IntrospectedEnum,\n  SchemaIntrospectionResult,\n  IntrospectOptions,\n  ChangeType,\n  SchemaChange,\n  DiffSummary,\n  MigrationScript,\n  SchemaSyncDiff,\n  SyncStatus,\n  PullOptions,\n  PushOptions,\n  DiffOptions,\n  PullResult,\n  PushResult,\n  RemoteSchemaResponse,\n  RemotePushResult,\n  RemoteSyncStatus,\n} from './schema/index.js';\n\nexport {\n  SchemaRemoteClient,\n  createSchemaRemoteClient,\n  AuthHandler,\n  createAuthHandler,\n} from './remote/index.js';\nexport type {\n  SchemaRemoteClientOptions,\n  Credentials,\n  AuthConfig,\n  RemoteConfig,\n  RemotePushOptions,\n  RemoteHealthResponse,\n  RemoteApiError,\n} from './remote/index.js';\n\nexport { generateTypes, generateSchemaFromDefinition } from './types/generator.js';\nexport type { TypeGeneratorOptions } from './types/generator.js';\n\nexport { generateHooks } from './types/hooks-generator.js';\nexport type { HooksGeneratorOptions } from './types/hooks-generator.js';\n\nexport { DbClient, TransactionContext, createDbClient } from './client.js';\nexport type { DbClientOptions } from './client.js';\n\nexport {\n  TenantContextError,\n  validateTenantContext,\n  validateTenantContextOrWarn,\n} from './utils/tenant-validation.js';\n\nexport {\n  Seeder,\n  SeedRunner,\n  createSeedRunner,\n  SeedLoader,\n  SeedTracker,\n  SqlSeederAdapter,\n} from './seed/index.js';\nexport type {\n  SeedResult,\n  SeederMetadata,\n  SeederLogger,\n  LoadedSeeder,\n  SeedLoaderOptions,\n  SeederConstructor,\n  SeedRunnerOptions,\n  SeedRunOptions,\n  SeedRunResult,\n  SeederResult,\n  SeedTrackerOptions,\n  SeedRecord,\n} from './seed/index.js';\n\nexport {\n  BranchManager,\n  createBranchManager,\n  SchemaDiffer,\n  MigrationMerger,\n  ConnectionManager,\n  createConnectionManager,\n  CleanupScheduler,\n  createCleanupScheduler,\n} from './branch/index.js';\nexport type {\n  Branch,\n  BranchStatus,\n  CreateBranchOptions,\n  SwitchBranchResult,\n  SchemaDiff,\n  TableDiff,\n  ColumnDiff,\n  IndexDiff,\n  ConstraintDiff,\n  Conflict,\n  ConflictResolution,\n  MergeOptions,\n  MergeResult,\n  ListBranchesFilter,\n  CleanupOptions,\n  CleanupResult,\n  BranchManagerOptions,\n  ConnectionManagerOptions,\n  BranchConnection,\n  CleanupSchedulerOptions,\n  CleanupJob,\n  MigrationMergerOptions,\n  MigrationRecord,\n} from './branch/index.js';\n\nexport async function createDb(options: {\n  connectionString: string;\n  migrationsPath?: string;\n  tenantColumns?: { appId: string; organizationId: string };\n  strictTenantMode?: boolean;\n}) {\n  const { createDriver } = await import('./driver/index.js');\n  const { createDbClient } = await import('./client.js');\n\n  const driver = await createDriver({ connectionString: options.connectionString });\n  return createDbClient(driver, {\n    migrationsPath: options.migrationsPath,\n    tenantColumns: options.tenantColumns,\n    strictTenantMode: options.strictTenantMode,\n  });\n}\n","export { MigrationRunner, createMigrationRunner } from './runner.js';\nexport type { MigrationRunnerOptions, MigrationRunOptions } from './runner.js';\nexport { getDialect, postgresDialect, mysqlDialect, sqliteDialect } from './dialects/index.js';\nexport type { Dialect } from './dialects/types.js';\n","import type { Driver } from '../driver/types.js';\nimport { getDialect } from '../migrations/dialects/index.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { ModuleDefinition } from './types.js';\n\nexport interface ModuleRegistryOptions {\n  tableName?: string;\n}\n\nexport class ModuleRegistry {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: ModuleRegistryOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_module_registry';\n  }\n\n  async ensureTable(): Promise<void> {\n    const createTableSQL =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          name TEXT PRIMARY KEY,\n          display_name TEXT NOT NULL,\n          description TEXT,\n          version TEXT NOT NULL,\n          dependencies TEXT[] DEFAULT '{}',\n          migration_prefix TEXT NOT NULL UNIQUE,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW()\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            name VARCHAR(255) PRIMARY KEY,\n            display_name VARCHAR(255) NOT NULL,\n            description TEXT,\n            version VARCHAR(50) NOT NULL,\n            dependencies JSON DEFAULT ('[]'),\n            migration_prefix VARCHAR(255) NOT NULL UNIQUE,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            name TEXT PRIMARY KEY,\n            display_name TEXT NOT NULL,\n            description TEXT,\n            version TEXT NOT NULL,\n            dependencies TEXT DEFAULT '[]',\n            migration_prefix TEXT NOT NULL UNIQUE,\n            created_at TEXT DEFAULT (datetime('now')),\n            updated_at TEXT DEFAULT (datetime('now'))\n          )\n        `;\n\n    await this.driver.execute(createTableSQL);\n  }\n\n  async register(module: ModuleDefinition): Promise<void> {\n    await this.ensureTable();\n\n    const dependencies = module.dependencies ?? [];\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES ($1, $2, $3, $4, $5, $6)\n        ON CONFLICT (name) DO UPDATE SET\n          display_name = EXCLUDED.display_name,\n          description = EXCLUDED.description,\n          version = EXCLUDED.version,\n          dependencies = EXCLUDED.dependencies,\n          migration_prefix = EXCLUDED.migration_prefix,\n          updated_at = NOW()\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          dependencies,\n          module.migrationPrefix,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES (?, ?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          display_name = VALUES(display_name),\n          description = VALUES(description),\n          version = VALUES(version),\n          dependencies = VALUES(dependencies),\n          migration_prefix = VALUES(migration_prefix)\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          JSON.stringify(dependencies),\n          module.migrationPrefix,\n        ]\n      );\n    } else {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (name, display_name, description, version, dependencies, migration_prefix)\n        VALUES (?, ?, ?, ?, ?, ?)\n        ON CONFLICT (name) DO UPDATE SET\n          display_name = excluded.display_name,\n          description = excluded.description,\n          version = excluded.version,\n          dependencies = excluded.dependencies,\n          migration_prefix = excluded.migration_prefix,\n          updated_at = datetime('now')\n        `,\n        [\n          module.name,\n          module.displayName,\n          module.description ?? null,\n          module.version,\n          JSON.stringify(dependencies),\n          module.migrationPrefix,\n        ]\n      );\n    }\n  }\n\n  async get(name: string): Promise<ModuleDefinition | null> {\n    await this.ensureTable();\n\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM \"${this.tableName}\"\n        WHERE name = $1\n      `;\n      params = [name];\n    } else {\n      sql = `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        WHERE name = ?\n      `;\n      params = [name];\n    }\n\n    const result = await this.driver.query<{\n      name: string;\n      display_name: string;\n      description: string | null;\n      version: string;\n      dependencies: string[] | string;\n      migration_prefix: string;\n    }>(sql, params);\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0];\n    return {\n      name: row.name,\n      displayName: row.display_name,\n      description: row.description ?? undefined,\n      version: row.version,\n      dependencies:\n        typeof row.dependencies === 'string' ? JSON.parse(row.dependencies) : row.dependencies,\n      migrationPrefix: row.migration_prefix,\n    };\n  }\n\n  async list(): Promise<ModuleDefinition[]> {\n    await this.ensureTable();\n\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM \"${this.tableName}\"\n        ORDER BY name ASC\n      `\n        : `\n        SELECT name, display_name, description, version, dependencies, migration_prefix\n        FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`}\n        ORDER BY name ASC\n      `;\n\n    const result = await this.driver.query<{\n      name: string;\n      display_name: string;\n      description: string | null;\n      version: string;\n      dependencies: string[] | string;\n      migration_prefix: string;\n    }>(sql);\n\n    return result.rows.map((row) => ({\n      name: row.name,\n      displayName: row.display_name,\n      description: row.description ?? undefined,\n      version: row.version,\n      dependencies:\n        typeof row.dependencies === 'string' ? JSON.parse(row.dependencies) : row.dependencies,\n      migrationPrefix: row.migration_prefix,\n    }));\n  }\n\n  async unregister(name: string): Promise<void> {\n    await this.ensureTable();\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(`DELETE FROM \"${this.tableName}\" WHERE name = $1`, [name]);\n    } else {\n      await this.driver.execute(\n        `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE name = ?`,\n        [name]\n      );\n    }\n  }\n}\n\nexport function createModuleRegistry(\n  driver: Driver,\n  options: ModuleRegistryOptions = {}\n): ModuleRegistry {\n  return new ModuleRegistry(driver, options);\n}\n","import { readFile, readdir, stat } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { MigrationFile } from '../types/index.js';\nimport type { ModuleMigrationSource } from './types.js';\n\nexport interface MigrationCollectorOptions {\n  scope?: 'core' | 'template';\n}\n\nexport class MigrationCollector {\n  async discoverFromDirectory(basePath: string): Promise<ModuleMigrationSource[]> {\n    const sources: ModuleMigrationSource[] = [];\n\n    try {\n      const entries = await readdir(basePath);\n\n      for (const entry of entries) {\n        const entryPath = join(basePath, entry);\n        const entryStat = await stat(entryPath);\n\n        if (entryStat.isDirectory()) {\n          sources.push({\n            moduleName: entry,\n            migrationsPath: entryPath,\n          });\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n\n    return sources.sort((a, b) => a.moduleName.localeCompare(b.moduleName));\n  }\n\n  async collect(\n    sources: ModuleMigrationSource[],\n    options: MigrationCollectorOptions = {}\n  ): Promise<MigrationFile[]> {\n    const migrations: MigrationFile[] = [];\n\n    for (const source of sources) {\n      const sourceMigrations = await this.loadMigrationsFromSource(source, options);\n      migrations.push(...sourceMigrations);\n    }\n\n    return this.orderMigrations(migrations);\n  }\n\n  private async loadMigrationsFromSource(\n    source: ModuleMigrationSource,\n    options: MigrationCollectorOptions = {}\n  ): Promise<MigrationFile[]> {\n    const scope = options.scope ?? 'core';\n    const migrations: MigrationFile[] = [];\n\n    try {\n      const files = await readdir(source.migrationsPath);\n      const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();\n\n      for (const file of sqlFiles) {\n        const content = await readFile(join(source.migrationsPath, file), 'utf-8');\n        const parsed = this.parseMigrationFile(file, content, scope, source.moduleName);\n        if (parsed) {\n          migrations.push(parsed);\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n\n    return migrations;\n  }\n\n  private parseMigrationFile(\n    filename: string,\n    content: string,\n    scope: 'core' | 'template',\n    moduleName: string\n  ): MigrationFile | null {\n    const match = filename.match(/^(\\d+)__(.+)\\.sql$/);\n    if (!match) return null;\n\n    const [, versionStr, name] = match;\n    const version = Number.parseInt(versionStr, 10);\n\n    const upMatch = content.match(/--\\s*up\\s*\\n([\\s\\S]*?)(?=--\\s*down|$)/i);\n    const downMatch = content.match(/--\\s*down\\s*\\n([\\s\\S]*?)$/i);\n\n    const up = upMatch ? this.splitSqlStatements(upMatch[1]) : [];\n    const down = downMatch ? this.splitSqlStatements(downMatch[1]) : [];\n\n    if (!up.length) return null;\n\n    return {\n      version,\n      name,\n      up,\n      down,\n      scope,\n      moduleName,\n    };\n  }\n\n  private orderMigrations(migrations: MigrationFile[]): MigrationFile[] {\n    return migrations.sort((a, b) => {\n      if (a.version !== b.version) {\n        return a.version - b.version;\n      }\n      const moduleA = a.moduleName ?? '';\n      const moduleB = b.moduleName ?? '';\n      return moduleA.localeCompare(moduleB);\n    });\n  }\n\n  private splitSqlStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inSingleQuote) {\n        current += char;\n        if (char === \"'\" && next !== \"'\") {\n          inSingleQuote = false;\n        } else if (char === \"'\" && next === \"'\") {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (inDoubleQuote) {\n        current += char;\n        if (char === '\"' && next !== '\"') {\n          inDoubleQuote = false;\n        } else if (char === '\"' && next === '\"') {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\") {\n        inSingleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '\"') {\n        inDoubleQuote = true;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n\nexport function createMigrationCollector(): MigrationCollector {\n  return new MigrationCollector();\n}\n","export { SchemaRegistry, createSchemaRegistry } from './registry.js';\nexport type { SchemaRegistryOptions, RegisterSchemaOptions, SchemaRecord } from './registry.js';\n\nexport { SchemaIntrospector, createSchemaIntrospector } from './introspect.js';\n\nexport { SchemaDiffEngine, createSchemaDiffEngine } from './diff.js';\nexport type { SchemaDiffOptions } from './diff.js';\n\nexport { SchemaSyncService, createSchemaSyncService } from './sync.js';\nexport type { SchemaSyncServiceOptions, Logger } from './sync.js';\n\nexport { SyncMetadataManager, createSyncMetadataManager } from './sync-metadata.js';\nexport type { SyncMetadataOptions } from './sync-metadata.js';\n\nexport type {\n  IntrospectedColumn,\n  IntrospectedIndex,\n  IntrospectedForeignKey,\n  IntrospectedConstraint,\n  IntrospectedTable,\n  IntrospectedEnum,\n  SchemaIntrospectionResult,\n  IntrospectOptions,\n  ChangeType,\n  SchemaChange,\n  DiffSummary,\n  MigrationScript,\n  SchemaSyncDiff,\n  SyncStatus,\n  PullOptions,\n  PushOptions,\n  DiffOptions,\n  PullResult,\n  PushResult,\n  RemoteSchemaResponse,\n  RemotePushResult,\n  RemoteSyncStatus,\n} from './types.js';\n\nexport {\n  SchemaRemoteError,\n  BreakingChangeError,\n  ConflictError,\n  AuthenticationError,\n  UserCancelledError,\n} from './types.js';\n","import type { Driver } from '../driver/types.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type {\n  ColumnDefinition,\n  ColumnType,\n  SchemaDefinition,\n  TableDefinition,\n} from '../types/index.js';\nimport type {\n  IntrospectOptions,\n  IntrospectedColumn,\n  IntrospectedConstraint,\n  IntrospectedEnum,\n  IntrospectedForeignKey,\n  IntrospectedIndex,\n  IntrospectedTable,\n  SchemaIntrospectionResult,\n} from './types.js';\n\nexport class SchemaIntrospector {\n  constructor(\n    private driver: Driver,\n    private dialect: Dialect\n  ) {}\n\n  async introspect(options: IntrospectOptions = {}): Promise<SchemaIntrospectionResult> {\n    const tables = await this.introspectTables(options);\n    const enums = await this.introspectEnums();\n    const extensions = await this.introspectExtensions();\n    const databaseVersion = await this.getDatabaseVersion();\n\n    return {\n      tables,\n      enums,\n      extensions,\n      introspectedAt: new Date(),\n      databaseVersion,\n    };\n  }\n\n  async introspectTables(options: IntrospectOptions = {}): Promise<IntrospectedTable[]> {\n    const tableNames = await this.listTables(options);\n    const tables: IntrospectedTable[] = [];\n\n    for (const tableName of tableNames) {\n      const table = await this.introspectTable(tableName);\n      tables.push(table);\n    }\n\n    return tables;\n  }\n\n  async listTables(options: IntrospectOptions = {}): Promise<string[]> {\n    const excludePatterns = options.includeLaunchpadTables ? [] : ['lp_%', 'pg_%', 'sql_%'];\n    const additionalExcludes = options.excludeTables ?? [];\n\n    let sql: string;\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        SELECT table_name\n        FROM information_schema.tables\n        WHERE table_schema = 'public'\n          AND table_type = 'BASE TABLE'\n        ORDER BY table_name\n      `;\n    } else if (this.dialect.name === 'mysql') {\n      sql = `\n        SELECT table_name\n        FROM information_schema.tables\n        WHERE table_schema = DATABASE()\n          AND table_type = 'BASE TABLE'\n        ORDER BY table_name\n      `;\n    } else {\n      sql = `\n        SELECT name as table_name\n        FROM sqlite_master\n        WHERE type = 'table'\n          AND name NOT LIKE 'sqlite_%'\n        ORDER BY name\n      `;\n    }\n\n    const result = await this.driver.query<{ table_name: string }>(sql);\n\n    return result.rows\n      .map((row) => row.table_name)\n      .filter((name) => {\n        for (const pattern of excludePatterns) {\n          if (pattern.endsWith('%')) {\n            const prefix = pattern.slice(0, -1);\n            if (name.startsWith(prefix)) return false;\n          } else if (name === pattern) {\n            return false;\n          }\n        }\n        for (const exclude of additionalExcludes) {\n          if (name === exclude) return false;\n        }\n        return true;\n      });\n  }\n\n  async introspectTable(tableName: string): Promise<IntrospectedTable> {\n    const [columns, indexes, foreignKeys, constraints] = await Promise.all([\n      this.introspectColumns(tableName),\n      this.introspectIndexes(tableName),\n      this.introspectForeignKeys(tableName),\n      this.introspectConstraints(tableName),\n    ]);\n\n    const primaryKey = this.extractPrimaryKey(indexes);\n\n    return {\n      name: tableName,\n      schema: 'public',\n      columns,\n      primaryKey,\n      foreignKeys,\n      indexes: indexes.filter((i) => !i.isPrimary),\n      constraints,\n    };\n  }\n\n  async introspectColumns(tableName: string): Promise<IntrospectedColumn[]> {\n    if (this.dialect.name === 'postgresql') {\n      return this.introspectPostgresColumns(tableName);\n    }\n    if (this.dialect.name === 'mysql') {\n      return this.introspectMysqlColumns(tableName);\n    }\n    return this.introspectSqliteColumns(tableName);\n  }\n\n  private async introspectPostgresColumns(tableName: string): Promise<IntrospectedColumn[]> {\n    const sql = `\n      SELECT\n        column_name,\n        data_type,\n        udt_name,\n        is_nullable,\n        column_default,\n        character_maximum_length,\n        numeric_precision,\n        numeric_scale,\n        is_identity,\n        identity_generation\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = $1\n      ORDER BY ordinal_position\n    `;\n\n    const result = await this.driver.query<{\n      column_name: string;\n      data_type: string;\n      udt_name: string;\n      is_nullable: string;\n      column_default: string | null;\n      character_maximum_length: number | null;\n      numeric_precision: number | null;\n      numeric_scale: number | null;\n      is_identity: string;\n      identity_generation: string | null;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.column_name,\n      dataType: row.data_type,\n      udtName: row.udt_name,\n      isNullable: row.is_nullable === 'YES',\n      defaultValue: row.column_default,\n      maxLength: row.character_maximum_length,\n      numericPrecision: row.numeric_precision,\n      numericScale: row.numeric_scale,\n      isIdentity: row.is_identity === 'YES',\n      identityGeneration: row.identity_generation as 'ALWAYS' | 'BY DEFAULT' | null,\n    }));\n  }\n\n  private async introspectMysqlColumns(tableName: string): Promise<IntrospectedColumn[]> {\n    const sql = `\n      SELECT\n        column_name,\n        data_type,\n        column_type as udt_name,\n        is_nullable,\n        column_default,\n        character_maximum_length,\n        numeric_precision,\n        numeric_scale,\n        extra\n      FROM information_schema.columns\n      WHERE table_schema = DATABASE()\n        AND table_name = ?\n      ORDER BY ordinal_position\n    `;\n\n    const result = await this.driver.query<{\n      column_name: string;\n      data_type: string;\n      udt_name: string;\n      is_nullable: string;\n      column_default: string | null;\n      character_maximum_length: number | null;\n      numeric_precision: number | null;\n      numeric_scale: number | null;\n      extra: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.column_name,\n      dataType: row.data_type,\n      udtName: row.udt_name,\n      isNullable: row.is_nullable === 'YES',\n      defaultValue: row.column_default,\n      maxLength: row.character_maximum_length,\n      numericPrecision: row.numeric_precision,\n      numericScale: row.numeric_scale,\n      isIdentity: row.extra.includes('auto_increment'),\n      identityGeneration: row.extra.includes('auto_increment') ? 'ALWAYS' : null,\n    }));\n  }\n\n  private async introspectSqliteColumns(tableName: string): Promise<IntrospectedColumn[]> {\n    const sql = `PRAGMA table_info(\"${tableName}\")`;\n\n    const result = await this.driver.query<{\n      cid: number;\n      name: string;\n      type: string;\n      notnull: number;\n      dflt_value: string | null;\n      pk: number;\n    }>(sql);\n\n    return result.rows.map((row) => ({\n      name: row.name,\n      dataType: row.type.toLowerCase(),\n      udtName: row.type.toLowerCase(),\n      isNullable: row.notnull === 0,\n      defaultValue: row.dflt_value,\n      maxLength: null,\n      numericPrecision: null,\n      numericScale: null,\n      isIdentity: row.pk === 1 && row.type.toLowerCase() === 'integer',\n      identityGeneration: row.pk === 1 && row.type.toLowerCase() === 'integer' ? 'ALWAYS' : null,\n    }));\n  }\n\n  async introspectIndexes(tableName: string): Promise<IntrospectedIndex[]> {\n    if (this.dialect.name === 'postgresql') {\n      return this.introspectPostgresIndexes(tableName);\n    }\n    if (this.dialect.name === 'mysql') {\n      return this.introspectMysqlIndexes(tableName);\n    }\n    return this.introspectSqliteIndexes(tableName);\n  }\n\n  private async introspectPostgresIndexes(tableName: string): Promise<IntrospectedIndex[]> {\n    const sql = `\n      SELECT\n        i.relname AS index_name,\n        array_agg(a.attname ORDER BY array_position(ix.indkey, a.attnum)) AS columns,\n        ix.indisunique AS is_unique,\n        ix.indisprimary AS is_primary,\n        am.amname AS index_type,\n        pg_get_expr(ix.indexprs, ix.indrelid) AS expression\n      FROM pg_index ix\n      JOIN pg_class i ON ix.indexrelid = i.oid\n      JOIN pg_class t ON ix.indrelid = t.oid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      JOIN pg_am am ON i.relam = am.oid\n      WHERE t.relname = $1\n        AND t.relnamespace = 'public'::regnamespace\n      GROUP BY i.relname, ix.indisunique, ix.indisprimary, am.amname, ix.indexprs, ix.indrelid\n    `;\n\n    const result = await this.driver.query<{\n      index_name: string;\n      columns: string[];\n      is_unique: boolean;\n      is_primary: boolean;\n      index_type: string;\n      expression: string | null;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.index_name,\n      columns: row.columns,\n      isUnique: row.is_unique,\n      isPrimary: row.is_primary,\n      type: row.index_type as IntrospectedIndex['type'],\n      expression: row.expression,\n    }));\n  }\n\n  private async introspectMysqlIndexes(tableName: string): Promise<IntrospectedIndex[]> {\n    const sql = `\n      SELECT\n        index_name,\n        GROUP_CONCAT(column_name ORDER BY seq_in_index) as columns,\n        NOT non_unique as is_unique,\n        index_name = 'PRIMARY' as is_primary,\n        index_type\n      FROM information_schema.statistics\n      WHERE table_schema = DATABASE()\n        AND table_name = ?\n      GROUP BY index_name, non_unique, index_type\n    `;\n\n    const result = await this.driver.query<{\n      index_name: string;\n      columns: string;\n      is_unique: boolean;\n      is_primary: boolean;\n      index_type: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.index_name,\n      columns: row.columns.split(','),\n      isUnique: row.is_unique,\n      isPrimary: row.is_primary,\n      type: row.index_type.toLowerCase() as IntrospectedIndex['type'],\n      expression: null,\n    }));\n  }\n\n  private async introspectSqliteIndexes(tableName: string): Promise<IntrospectedIndex[]> {\n    const indexListSql = `PRAGMA index_list(\"${tableName}\")`;\n    const indexList = await this.driver.query<{\n      seq: number;\n      name: string;\n      unique: number;\n      origin: string;\n      partial: number;\n    }>(indexListSql);\n\n    const indexes: IntrospectedIndex[] = [];\n\n    for (const idx of indexList.rows) {\n      const indexInfoSql = `PRAGMA index_info(\"${idx.name}\")`;\n      const indexInfo = await this.driver.query<{\n        seqno: number;\n        cid: number;\n        name: string;\n      }>(indexInfoSql);\n\n      indexes.push({\n        name: idx.name,\n        columns: indexInfo.rows.map((row) => row.name),\n        isUnique: idx.unique === 1,\n        isPrimary: idx.origin === 'pk',\n        type: 'btree',\n        expression: null,\n      });\n    }\n\n    return indexes;\n  }\n\n  async introspectForeignKeys(tableName: string): Promise<IntrospectedForeignKey[]> {\n    if (this.dialect.name === 'postgresql') {\n      return this.introspectPostgresForeignKeys(tableName);\n    }\n    if (this.dialect.name === 'mysql') {\n      return this.introspectMysqlForeignKeys(tableName);\n    }\n    return this.introspectSqliteForeignKeys(tableName);\n  }\n\n  private async introspectPostgresForeignKeys(\n    tableName: string\n  ): Promise<IntrospectedForeignKey[]> {\n    const sql = `\n      SELECT\n        tc.constraint_name,\n        array_agg(kcu.column_name ORDER BY kcu.ordinal_position) AS columns,\n        ccu.table_name AS referenced_table,\n        array_agg(ccu.column_name ORDER BY kcu.ordinal_position) AS referenced_columns,\n        rc.delete_rule AS on_delete,\n        rc.update_rule AS on_update\n      FROM information_schema.table_constraints tc\n      JOIN information_schema.key_column_usage kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      JOIN information_schema.constraint_column_usage ccu\n        ON ccu.constraint_name = tc.constraint_name\n        AND ccu.table_schema = tc.table_schema\n      JOIN information_schema.referential_constraints rc\n        ON rc.constraint_name = tc.constraint_name\n        AND rc.constraint_schema = tc.table_schema\n      WHERE tc.table_name = $1\n        AND tc.table_schema = 'public'\n        AND tc.constraint_type = 'FOREIGN KEY'\n      GROUP BY tc.constraint_name, ccu.table_name, rc.delete_rule, rc.update_rule\n    `;\n\n    const result = await this.driver.query<{\n      constraint_name: string;\n      columns: string[];\n      referenced_table: string;\n      referenced_columns: string[];\n      on_delete: string;\n      on_update: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.constraint_name,\n      columns: row.columns,\n      referencedTable: row.referenced_table,\n      referencedColumns: row.referenced_columns,\n      onDelete: row.on_delete as IntrospectedForeignKey['onDelete'],\n      onUpdate: row.on_update as IntrospectedForeignKey['onUpdate'],\n    }));\n  }\n\n  private async introspectMysqlForeignKeys(tableName: string): Promise<IntrospectedForeignKey[]> {\n    const sql = `\n      SELECT\n        constraint_name,\n        GROUP_CONCAT(column_name ORDER BY ordinal_position) as columns,\n        referenced_table_name as referenced_table,\n        GROUP_CONCAT(referenced_column_name ORDER BY ordinal_position) as referenced_columns\n      FROM information_schema.key_column_usage\n      WHERE table_schema = DATABASE()\n        AND table_name = ?\n        AND referenced_table_name IS NOT NULL\n      GROUP BY constraint_name, referenced_table_name\n    `;\n\n    const result = await this.driver.query<{\n      constraint_name: string;\n      columns: string;\n      referenced_table: string;\n      referenced_columns: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.constraint_name,\n      columns: row.columns.split(','),\n      referencedTable: row.referenced_table,\n      referencedColumns: row.referenced_columns.split(','),\n      onDelete: 'NO ACTION' as const,\n      onUpdate: 'NO ACTION' as const,\n    }));\n  }\n\n  private async introspectSqliteForeignKeys(tableName: string): Promise<IntrospectedForeignKey[]> {\n    const sql = `PRAGMA foreign_key_list(\"${tableName}\")`;\n\n    const result = await this.driver.query<{\n      id: number;\n      seq: number;\n      table: string;\n      from: string;\n      to: string;\n      on_update: string;\n      on_delete: string;\n      match: string;\n    }>(sql);\n\n    const fkMap = new Map<number, IntrospectedForeignKey>();\n\n    for (const row of result.rows) {\n      if (!fkMap.has(row.id)) {\n        fkMap.set(row.id, {\n          name: `fk_${tableName}_${row.id}`,\n          columns: [],\n          referencedTable: row.table,\n          referencedColumns: [],\n          onDelete: row.on_delete.replace(' ', '_') as IntrospectedForeignKey['onDelete'],\n          onUpdate: row.on_update.replace(' ', '_') as IntrospectedForeignKey['onUpdate'],\n        });\n      }\n      const fk = fkMap.get(row.id)!;\n      fk.columns.push(row.from);\n      fk.referencedColumns.push(row.to);\n    }\n\n    return Array.from(fkMap.values());\n  }\n\n  async introspectConstraints(tableName: string): Promise<IntrospectedConstraint[]> {\n    if (this.dialect.name !== 'postgresql') {\n      return [];\n    }\n\n    const sql = `\n      SELECT\n        con.conname AS constraint_name,\n        CASE con.contype\n          WHEN 'c' THEN 'CHECK'\n          WHEN 'u' THEN 'UNIQUE'\n          WHEN 'p' THEN 'PRIMARY KEY'\n          WHEN 'f' THEN 'FOREIGN KEY'\n          WHEN 'x' THEN 'EXCLUDE'\n        END AS constraint_type,\n        pg_get_constraintdef(con.oid) AS definition\n      FROM pg_constraint con\n      JOIN pg_class rel ON rel.oid = con.conrelid\n      JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace\n      WHERE rel.relname = $1\n        AND nsp.nspname = 'public'\n        AND con.contype = 'c'\n    `;\n\n    const result = await this.driver.query<{\n      constraint_name: string;\n      constraint_type: string;\n      definition: string;\n    }>(sql, [tableName]);\n\n    return result.rows.map((row) => ({\n      name: row.constraint_name,\n      type: row.constraint_type as IntrospectedConstraint['type'],\n      definition: row.definition,\n    }));\n  }\n\n  async introspectEnums(): Promise<IntrospectedEnum[]> {\n    if (this.dialect.name !== 'postgresql') {\n      return [];\n    }\n\n    const sql = `\n      SELECT\n        t.typname AS name,\n        array_agg(e.enumlabel ORDER BY e.enumsortorder) AS values\n      FROM pg_type t\n      JOIN pg_enum e ON t.oid = e.enumtypid\n      JOIN pg_namespace n ON t.typnamespace = n.oid\n      WHERE n.nspname = 'public'\n      GROUP BY t.typname\n    `;\n\n    const result = await this.driver.query<{\n      name: string;\n      values: string[];\n    }>(sql);\n\n    return result.rows;\n  }\n\n  async introspectExtensions(): Promise<string[]> {\n    if (this.dialect.name !== 'postgresql') {\n      return [];\n    }\n\n    const sql = `SELECT extname FROM pg_extension WHERE extname != 'plpgsql'`;\n    const result = await this.driver.query<{ extname: string }>(sql);\n    return result.rows.map((row) => row.extname);\n  }\n\n  async getDatabaseVersion(): Promise<string> {\n    if (this.dialect.name === 'postgresql') {\n      const result = await this.driver.query<{ version: string }>('SELECT version()');\n      return result.rows[0]?.version ?? 'unknown';\n    }\n    if (this.dialect.name === 'mysql') {\n      const result = await this.driver.query<{ version: string }>('SELECT VERSION() as version');\n      return result.rows[0]?.version ?? 'unknown';\n    }\n    const result = await this.driver.query<{ 'sqlite_version()': string }>(\n      'SELECT sqlite_version()'\n    );\n    return result.rows[0]?.['sqlite_version()'] ?? 'unknown';\n  }\n\n  private extractPrimaryKey(indexes: IntrospectedIndex[]): string[] {\n    const pkIndex = indexes.find((i) => i.isPrimary);\n    return pkIndex?.columns ?? [];\n  }\n\n  toSchemaDefinition(result: SchemaIntrospectionResult): SchemaDefinition {\n    const tables: Record<string, TableDefinition> = {};\n\n    for (const table of result.tables) {\n      tables[table.name] = this.tableToDefinition(table);\n    }\n\n    return { tables };\n  }\n\n  private tableToDefinition(table: IntrospectedTable): TableDefinition {\n    const columns: Record<string, ColumnDefinition> = {};\n\n    for (const col of table.columns) {\n      columns[col.name] = this.columnToDefinition(col, table);\n    }\n\n    const indexes = table.indexes.map((idx) => ({\n      name: idx.name,\n      columns: idx.columns,\n      unique: idx.isUnique,\n    }));\n\n    return {\n      columns,\n      indexes: indexes.length > 0 ? indexes : undefined,\n      primaryKey: table.primaryKey.length > 1 ? table.primaryKey : undefined,\n    };\n  }\n\n  private columnToDefinition(col: IntrospectedColumn, table: IntrospectedTable): ColumnDefinition {\n    const type = this.mapDataTypeToColumnType(col.dataType, col.udtName);\n    const isPrimaryKey = table.primaryKey.length === 1 && table.primaryKey[0] === col.name;\n\n    const def: ColumnDefinition = {\n      type,\n      nullable: col.isNullable,\n    };\n\n    if (isPrimaryKey) {\n      def.primaryKey = true;\n    }\n\n    if (col.defaultValue !== null) {\n      def.default = col.defaultValue;\n    }\n\n    const fk = table.foreignKeys.find(\n      (fk) => fk.columns.length === 1 && fk.columns[0] === col.name\n    );\n    if (fk) {\n      def.references = {\n        table: fk.referencedTable,\n        column: fk.referencedColumns[0],\n        onDelete: fk.onDelete,\n        onUpdate: fk.onUpdate,\n      };\n    }\n\n    if (col.name === 'app_id' || col.name === 'organization_id') {\n      def.tenant = true;\n    }\n\n    return def;\n  }\n\n  private mapDataTypeToColumnType(dataType: string, udtName: string): ColumnType {\n    const normalized = dataType.toLowerCase();\n    const udt = udtName.toLowerCase();\n\n    if (udt === 'uuid' || normalized === 'uuid') return 'uuid';\n    if (normalized.includes('int') && normalized !== 'interval') return 'integer';\n    if (normalized === 'bigint' || udt === 'int8') return 'bigint';\n    if (normalized.includes('float') || normalized.includes('double') || normalized === 'real')\n      return 'float';\n    if (normalized.includes('numeric') || normalized.includes('decimal')) return 'decimal';\n    if (normalized === 'boolean' || normalized === 'bool') return 'boolean';\n    if (normalized.includes('timestamp') || normalized === 'datetime') return 'datetime';\n    if (normalized === 'date') return 'date';\n    if (normalized === 'time') return 'time';\n    if (normalized === 'json' || normalized === 'jsonb') return 'json';\n    if (normalized === 'bytea' || normalized.includes('blob') || normalized === 'binary')\n      return 'binary';\n    if (normalized === 'text' || udt === 'text') return 'text';\n    return 'string';\n  }\n}\n\nexport function createSchemaIntrospector(driver: Driver, dialect: Dialect): SchemaIntrospector {\n  return new SchemaIntrospector(driver, dialect);\n}\n","import { createHash } from 'node:crypto';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type {\n  ColumnDefinition,\n  IndexDefinition,\n  SchemaDefinition,\n  TableDefinition,\n} from '../types/index.js';\nimport type { DiffSummary, MigrationScript, SchemaChange, SchemaSyncDiff } from './types.js';\n\nexport interface SchemaDiffOptions {\n  generateMigration?: boolean;\n  treatColumnDropAsBreaking?: boolean;\n  treatTableDropAsBreaking?: boolean;\n  migrationName?: string;\n}\n\nexport class SchemaDiffEngine {\n  constructor(private dialect: Dialect) {}\n\n  computeDiff(\n    current: SchemaDefinition | null,\n    target: SchemaDefinition,\n    options: SchemaDiffOptions = {}\n  ): SchemaSyncDiff {\n    const changes: SchemaChange[] = [];\n    const currentTables = new Set(Object.keys(current?.tables ?? {}));\n    const targetTables = new Set(Object.keys(target.tables));\n\n    for (const tableName of targetTables) {\n      if (!currentTables.has(tableName)) {\n        const tableChanges = this.generateTableAddChanges(tableName, target.tables[tableName]);\n        changes.push(...tableChanges);\n      }\n    }\n\n    for (const tableName of currentTables) {\n      if (!targetTables.has(tableName)) {\n        changes.push(this.generateTableDropChange(tableName, current!.tables[tableName], options));\n      }\n    }\n\n    for (const tableName of currentTables) {\n      if (targetTables.has(tableName)) {\n        const columnChanges = this.compareColumns(\n          tableName,\n          current!.tables[tableName],\n          target.tables[tableName],\n          options\n        );\n        changes.push(...columnChanges);\n\n        const indexChanges = this.compareIndexes(\n          tableName,\n          current!.tables[tableName],\n          target.tables[tableName]\n        );\n        changes.push(...indexChanges);\n      }\n    }\n\n    const breakingChanges = changes.filter((c) => c.isBreaking);\n    const summary = this.summarizeChanges(changes);\n\n    let migration: MigrationScript | null = null;\n    if (options.generateMigration !== false && changes.length > 0) {\n      migration = this.generateMigration(changes, options.migrationName);\n    }\n\n    return {\n      hasDifferences: changes.length > 0,\n      summary,\n      changes,\n      breakingChanges,\n      migration,\n    };\n  }\n\n  private generateTableAddChanges(tableName: string, table: TableDefinition): SchemaChange[] {\n    const changes: SchemaChange[] = [];\n\n    const createSql = this.dialect.createTable(tableName, table);\n    const dropSql = this.dialect.dropTable(tableName);\n\n    changes.push({\n      type: 'table_add',\n      tableName,\n      isBreaking: false,\n      description: `Add table \"${tableName}\"`,\n      upSql: createSql,\n      downSql: dropSql,\n    });\n\n    if (table.indexes) {\n      for (const index of table.indexes) {\n        const indexSql = this.dialect.createIndex(tableName, index);\n        const dropIndexSql = this.dialect.dropIndex(\n          index.name ?? `idx_${tableName}_${index.columns.join('_')}`\n        );\n\n        changes.push({\n          type: 'index_add',\n          tableName,\n          objectName: index.name ?? `idx_${tableName}_${index.columns.join('_')}`,\n          isBreaking: false,\n          description: `Add index on \"${tableName}\"(${index.columns.join(', ')})`,\n          upSql: indexSql,\n          downSql: dropIndexSql,\n        });\n      }\n    }\n\n    return changes;\n  }\n\n  private generateTableDropChange(\n    tableName: string,\n    table: TableDefinition,\n    options: SchemaDiffOptions\n  ): SchemaChange {\n    const dropSql = this.dialect.dropTable(tableName);\n    const createSql = this.dialect.createTable(tableName, table);\n\n    return {\n      type: 'table_drop',\n      tableName,\n      isBreaking: options.treatTableDropAsBreaking !== false,\n      description: `Drop table \"${tableName}\"`,\n      upSql: dropSql,\n      downSql: createSql,\n      oldValue: table,\n    };\n  }\n\n  private compareColumns(\n    tableName: string,\n    current: TableDefinition,\n    target: TableDefinition,\n    options: SchemaDiffOptions\n  ): SchemaChange[] {\n    const changes: SchemaChange[] = [];\n    const currentCols = new Set(Object.keys(current.columns));\n    const targetCols = new Set(Object.keys(target.columns));\n\n    for (const colName of targetCols) {\n      if (!currentCols.has(colName)) {\n        const colDef = target.columns[colName];\n        const addSql = this.dialect.addColumn(tableName, colName, colDef);\n        const dropSql = this.dialect.dropColumn(tableName, colName);\n\n        changes.push({\n          type: 'column_add',\n          tableName,\n          objectName: colName,\n          isBreaking: false,\n          description: `Add column \"${tableName}\".\"${colName}\"`,\n          upSql: addSql,\n          downSql: dropSql,\n          newValue: colDef,\n        });\n\n        if (colDef.references) {\n          const fkName = `fk_${tableName}_${colName}_${colDef.references.table}`;\n          const addFkSql = this.dialect.addForeignKey(\n            tableName,\n            colName,\n            colDef.references.table,\n            colDef.references.column,\n            colDef.references.onDelete\n          );\n          const dropFkSql = this.dialect.dropForeignKey(tableName, fkName);\n\n          changes.push({\n            type: 'foreign_key_add',\n            tableName,\n            objectName: fkName,\n            isBreaking: false,\n            description: `Add foreign key \"${tableName}\".\"${colName}\" -> \"${colDef.references.table}\"`,\n            upSql: addFkSql,\n            downSql: dropFkSql,\n            newValue: colDef.references,\n          });\n        }\n      }\n    }\n\n    for (const colName of currentCols) {\n      if (!targetCols.has(colName)) {\n        const colDef = current.columns[colName];\n        const dropSql = this.dialect.dropColumn(tableName, colName);\n        const addSql = this.dialect.addColumn(tableName, colName, colDef);\n\n        changes.push({\n          type: 'column_drop',\n          tableName,\n          objectName: colName,\n          isBreaking: options.treatColumnDropAsBreaking !== false,\n          description: `Drop column \"${tableName}\".\"${colName}\"`,\n          upSql: dropSql,\n          downSql: addSql,\n          oldValue: colDef,\n        });\n      }\n    }\n\n    for (const colName of currentCols) {\n      if (targetCols.has(colName)) {\n        const currentCol = current.columns[colName];\n        const targetCol = target.columns[colName];\n\n        if (!this.columnsEqual(currentCol, targetCol)) {\n          const alteration = this.generateColumnAlteration(\n            tableName,\n            colName,\n            currentCol,\n            targetCol\n          );\n          if (alteration) {\n            changes.push(alteration);\n          }\n        }\n      }\n    }\n\n    return changes;\n  }\n\n  private compareIndexes(\n    tableName: string,\n    current: TableDefinition,\n    target: TableDefinition\n  ): SchemaChange[] {\n    const changes: SchemaChange[] = [];\n\n    const currentIndexes = new Map<string, IndexDefinition>();\n    const targetIndexes = new Map<string, IndexDefinition>();\n\n    for (const idx of current.indexes ?? []) {\n      const key = idx.name ?? `idx_${tableName}_${idx.columns.join('_')}`;\n      currentIndexes.set(key, idx);\n    }\n\n    for (const idx of target.indexes ?? []) {\n      const key = idx.name ?? `idx_${tableName}_${idx.columns.join('_')}`;\n      targetIndexes.set(key, idx);\n    }\n\n    for (const [name, idx] of targetIndexes) {\n      if (!currentIndexes.has(name)) {\n        const addSql = this.dialect.createIndex(tableName, idx);\n        const dropSql = this.dialect.dropIndex(name);\n\n        changes.push({\n          type: 'index_add',\n          tableName,\n          objectName: name,\n          isBreaking: false,\n          description: `Add index \"${name}\" on \"${tableName}\"`,\n          upSql: addSql,\n          downSql: dropSql,\n          newValue: idx,\n        });\n      }\n    }\n\n    for (const [name, idx] of currentIndexes) {\n      if (!targetIndexes.has(name)) {\n        const dropSql = this.dialect.dropIndex(name);\n        const addSql = this.dialect.createIndex(tableName, idx);\n\n        changes.push({\n          type: 'index_drop',\n          tableName,\n          objectName: name,\n          isBreaking: false,\n          description: `Drop index \"${name}\" from \"${tableName}\"`,\n          upSql: dropSql,\n          downSql: addSql,\n          oldValue: idx,\n        });\n      }\n    }\n\n    return changes;\n  }\n\n  private generateColumnAlteration(\n    tableName: string,\n    colName: string,\n    current: ColumnDefinition,\n    target: ColumnDefinition\n  ): SchemaChange | null {\n    const isBreaking = this.isColumnChangeBreaking(current, target);\n\n    try {\n      const alterSql = this.dialect.alterColumn(tableName, colName, target);\n      const revertSql = this.dialect.alterColumn(tableName, colName, current);\n\n      return {\n        type: 'column_modify',\n        tableName,\n        objectName: colName,\n        isBreaking,\n        description: `Modify column \"${tableName}\".\"${colName}\"`,\n        upSql: alterSql,\n        downSql: revertSql,\n        oldValue: current,\n        newValue: target,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  private isColumnChangeBreaking(current: ColumnDefinition, target: ColumnDefinition): boolean {\n    if (target.nullable === false && current.nullable === true) {\n      return true;\n    }\n\n    const typeOrder: Record<string, number> = {\n      uuid: 10,\n      boolean: 20,\n      integer: 30,\n      bigint: 40,\n      float: 50,\n      decimal: 60,\n      string: 70,\n      text: 80,\n      date: 90,\n      time: 100,\n      datetime: 110,\n      json: 120,\n      binary: 130,\n    };\n\n    const currentOrder = typeOrder[current.type] ?? 0;\n    const targetOrder = typeOrder[target.type] ?? 0;\n\n    if (targetOrder < currentOrder) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private columnsEqual(a: ColumnDefinition, b: ColumnDefinition): boolean {\n    return (\n      a.type === b.type &&\n      (a.nullable ?? false) === (b.nullable ?? false) &&\n      (a.unique ?? false) === (b.unique ?? false) &&\n      a.default === b.default &&\n      JSON.stringify(a.references) === JSON.stringify(b.references)\n    );\n  }\n\n  private summarizeChanges(changes: SchemaChange[]): DiffSummary {\n    const summary: DiffSummary = {\n      tablesAdded: 0,\n      tablesDropped: 0,\n      tablesModified: 0,\n      columnsAdded: 0,\n      columnsDropped: 0,\n      columnsModified: 0,\n      indexesAdded: 0,\n      indexesDropped: 0,\n      foreignKeysAdded: 0,\n      foreignKeysDropped: 0,\n    };\n\n    const modifiedTables = new Set<string>();\n\n    for (const change of changes) {\n      switch (change.type) {\n        case 'table_add':\n          summary.tablesAdded++;\n          break;\n        case 'table_drop':\n          summary.tablesDropped++;\n          break;\n        case 'column_add':\n          summary.columnsAdded++;\n          modifiedTables.add(change.tableName);\n          break;\n        case 'column_drop':\n          summary.columnsDropped++;\n          modifiedTables.add(change.tableName);\n          break;\n        case 'column_modify':\n          summary.columnsModified++;\n          modifiedTables.add(change.tableName);\n          break;\n        case 'index_add':\n          summary.indexesAdded++;\n          break;\n        case 'index_drop':\n          summary.indexesDropped++;\n          break;\n        case 'foreign_key_add':\n          summary.foreignKeysAdded++;\n          break;\n        case 'foreign_key_drop':\n          summary.foreignKeysDropped++;\n          break;\n      }\n    }\n\n    summary.tablesModified = modifiedTables.size;\n\n    return summary;\n  }\n\n  private generateMigration(changes: SchemaChange[], name?: string): MigrationScript {\n    const timestamp = new Date()\n      .toISOString()\n      .replace(/[-:T.Z]/g, '')\n      .slice(0, 14);\n\n    const migrationName = name ?? 'schema_sync';\n    const version = `${timestamp}`;\n\n    const upSql = changes.map((c) => c.upSql);\n    const downSql = changes\n      .slice()\n      .reverse()\n      .map((c) => c.downSql);\n\n    const content = [...upSql, ...downSql].join('\\n');\n    const checksum = createHash('sha256').update(content).digest('hex');\n\n    return {\n      version,\n      name: migrationName,\n      upSql,\n      downSql,\n      checksum,\n    };\n  }\n\n  formatDiff(diff: SchemaSyncDiff, format: 'text' | 'json' | 'sql' = 'text'): string {\n    if (format === 'json') {\n      return JSON.stringify(diff, null, 2);\n    }\n\n    if (format === 'sql') {\n      if (!diff.migration) return '-- No changes';\n      return `-- Up\\n${diff.migration.upSql.join(';\\n')};\\n\\n-- Down\\n${diff.migration.downSql.join(';\\n')};`;\n    }\n\n    const lines: string[] = [];\n\n    lines.push('');\n    lines.push('                     Schema Diff: local  remote                  ');\n    lines.push('');\n\n    if (!diff.hasDifferences) {\n      lines.push('  No differences found                                            ');\n      lines.push('');\n      return lines.join('\\n');\n    }\n\n    lines.push(' Summary:                                                          ');\n    if (diff.summary.tablesAdded > 0) {\n      lines.push(\n        `   + ${diff.summary.tablesAdded} table(s) added                                             `\n      );\n    }\n    if (diff.summary.tablesDropped > 0) {\n      lines.push(\n        `   - ${diff.summary.tablesDropped} table(s) dropped (BREAKING)                               `\n      );\n    }\n    if (diff.summary.columnsAdded > 0) {\n      lines.push(\n        `   + ${diff.summary.columnsAdded} column(s) added                                            `\n      );\n    }\n    if (diff.summary.columnsDropped > 0) {\n      lines.push(\n        `   - ${diff.summary.columnsDropped} column(s) dropped (BREAKING)                              `\n      );\n    }\n    if (diff.summary.columnsModified > 0) {\n      lines.push(\n        `   ~ ${diff.summary.columnsModified} column(s) modified                                        `\n      );\n    }\n    if (diff.summary.indexesAdded > 0) {\n      lines.push(\n        `   + ${diff.summary.indexesAdded} index(es) added                                             `\n      );\n    }\n    if (diff.summary.indexesDropped > 0) {\n      lines.push(\n        `   - ${diff.summary.indexesDropped} index(es) dropped                                          `\n      );\n    }\n\n    lines.push('');\n\n    for (const change of diff.changes) {\n      const prefix = change.type.includes('add') ? '+' : change.type.includes('drop') ? '-' : '~';\n      const breaking = change.isBreaking ? ' (BREAKING)' : '';\n      lines.push(` ${prefix} ${change.description}${breaking}`);\n    }\n\n    lines.push('');\n\n    if (diff.breakingChanges.length > 0) {\n      lines.push('');\n      lines.push(\n        `  ${diff.breakingChanges.length} breaking change(s) detected. Use --force to apply.`\n      );\n    }\n\n    return lines.join('\\n');\n  }\n}\n\nexport function createSchemaDiffEngine(dialect: Dialect): SchemaDiffEngine {\n  return new SchemaDiffEngine(dialect);\n}\n","import { createHash } from 'node:crypto';\nimport type { Driver } from '../driver/types.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { SchemaRemoteClient } from '../remote/client.js';\nimport type { SchemaDefinition } from '../types/index.js';\nimport { SchemaDiffEngine } from './diff.js';\nimport { SchemaIntrospector } from './introspect.js';\nimport { SyncMetadataManager } from './sync-metadata.js';\nimport {\n  BreakingChangeError,\n  type DiffOptions,\n  type PullOptions,\n  type PullResult,\n  type PushOptions,\n  type PushResult,\n  type SchemaSyncDiff,\n  type SyncStatus,\n  UserCancelledError,\n} from './types.js';\n\nexport interface SchemaSyncServiceOptions {\n  appId: string;\n  migrationsPath?: string;\n}\n\nexport interface Logger {\n  info(message: string): void;\n  warn(message: string): void;\n  error(message: string): void;\n}\n\nconst defaultLogger: Logger = {\n  info: (msg) => console.log(msg),\n  warn: (msg) => console.warn(msg),\n  error: (msg) => console.error(msg),\n};\n\nexport class SchemaSyncService {\n  private introspector: SchemaIntrospector;\n  private diffEngine: SchemaDiffEngine;\n  private syncMetadata: SyncMetadataManager;\n\n  constructor(\n    private driver: Driver,\n    private dialect: Dialect,\n    private remoteClient: SchemaRemoteClient,\n    private options: SchemaSyncServiceOptions,\n    private logger: Logger = defaultLogger\n  ) {\n    this.introspector = new SchemaIntrospector(driver, dialect);\n    this.diffEngine = new SchemaDiffEngine(dialect);\n    this.syncMetadata = new SyncMetadataManager(driver, dialect);\n  }\n\n  async pull(options: PullOptions = {}): Promise<PullResult> {\n    const environment = options.environment ?? 'production';\n    this.logger.info(`Fetching schema from ${environment}...`);\n\n    await this.syncMetadata.ensureSyncTable();\n\n    const remote = await this.remoteClient.fetchSchema(environment);\n\n    this.logger.info('Introspecting local database...');\n    const localIntrospection = await this.introspector.introspect();\n    const localSchema = this.introspector.toSchemaDefinition(localIntrospection);\n\n    const diff = this.diffEngine.computeDiff(localSchema, remote.schema, {\n      generateMigration: true,\n      migrationName: `sync_pull_${environment}`,\n    });\n\n    if (!diff.hasDifferences) {\n      this.logger.info('Local schema is up to date');\n      return { applied: false, diff };\n    }\n\n    this.logger.info(this.diffEngine.formatDiff(diff, 'text'));\n\n    if (options.dryRun) {\n      this.logger.info('(dry-run) No changes applied');\n      return { applied: false, diff };\n    }\n\n    if (diff.breakingChanges.length > 0 && !options.force) {\n      throw new BreakingChangeError(\n        `Pull would make ${diff.breakingChanges.length} breaking change(s). Use --force to apply anyway.`,\n        diff.breakingChanges\n      );\n    }\n\n    await this.applyMigration(diff);\n\n    const localChecksum = this.computeSchemaChecksum(localSchema);\n    await this.syncMetadata.updateSyncState(this.options.appId, 'pull', {\n      localChecksum,\n      localVersion: diff.migration?.version,\n      remoteChecksum: remote.checksum,\n      remoteVersion: remote.version,\n    });\n\n    this.logger.info(' Schema updated successfully');\n    return { applied: true, diff };\n  }\n\n  async push(options: PushOptions = {}): Promise<PushResult> {\n    const environment = options.environment ?? 'production';\n    this.logger.info('Introspecting local schema...');\n\n    await this.syncMetadata.ensureSyncTable();\n\n    const localIntrospection = await this.introspector.introspect();\n    const localSchema = this.introspector.toSchemaDefinition(localIntrospection);\n\n    this.logger.info(`Fetching remote schema from ${environment}...`);\n    const remote = await this.remoteClient.fetchSchema(environment);\n\n    const diff = this.diffEngine.computeDiff(remote.schema, localSchema, {\n      generateMigration: true,\n      migrationName: `sync_push_${environment}`,\n    });\n\n    if (!diff.hasDifferences) {\n      this.logger.info('Remote schema is up to date');\n      return { applied: false, diff };\n    }\n\n    this.logger.info(this.diffEngine.formatDiff(diff, 'text'));\n\n    if (options.dryRun) {\n      this.logger.info('(dry-run) No changes would be pushed');\n      return { applied: false, diff };\n    }\n\n    if (environment === 'production' && !options.force) {\n      this.logger.warn('  You are about to push schema changes to PRODUCTION');\n      this.logger.warn('This operation cannot be automatically undone.');\n      throw new UserCancelledError(\n        'Production push requires --force flag. Review changes carefully before proceeding.'\n      );\n    }\n\n    if (diff.breakingChanges.length > 0 && !options.force) {\n      throw new BreakingChangeError(\n        `Push would make ${diff.breakingChanges.length} breaking change(s). Use --force to apply anyway.`,\n        diff.breakingChanges\n      );\n    }\n\n    if (!diff.migration) {\n      return { applied: false, diff };\n    }\n\n    const remoteResult = await this.remoteClient.pushMigration(diff.migration, {\n      environment,\n      dryRun: false,\n      force: options.force,\n    });\n\n    if (remoteResult.success) {\n      const localChecksum = this.computeSchemaChecksum(localSchema);\n      await this.syncMetadata.updateSyncState(this.options.appId, 'push', {\n        localChecksum,\n        localVersion: diff.migration.version,\n        remoteChecksum: localChecksum,\n        remoteVersion: diff.migration.version,\n      });\n\n      this.logger.info(' Schema pushed successfully');\n    } else {\n      this.logger.error(' Push failed');\n      if (remoteResult.errors) {\n        for (const error of remoteResult.errors) {\n          this.logger.error(`  - ${error}`);\n        }\n      }\n    }\n\n    return { applied: remoteResult.success, diff, remoteResult };\n  }\n\n  async diff(options: DiffOptions = {}): Promise<SchemaSyncDiff> {\n    const environment = options.environment ?? 'production';\n\n    this.logger.info('Introspecting local schema...');\n    const localIntrospection = await this.introspector.introspect();\n    const localSchema = this.introspector.toSchemaDefinition(localIntrospection);\n\n    this.logger.info(`Fetching remote schema from ${environment}...`);\n    const remote = await this.remoteClient.fetchSchema(environment);\n\n    const diff = this.diffEngine.computeDiff(localSchema, remote.schema, {\n      generateMigration: true,\n      migrationName: `diff_${environment}`,\n    });\n\n    return diff;\n  }\n\n  async getSyncStatus(): Promise<SyncStatus | null> {\n    await this.syncMetadata.ensureSyncTable();\n    return this.syncMetadata.getSyncState(this.options.appId, '__global__');\n  }\n\n  async introspectLocal(): Promise<SchemaDefinition> {\n    const introspection = await this.introspector.introspect();\n    return this.introspector.toSchemaDefinition(introspection);\n  }\n\n  formatDiff(diff: SchemaSyncDiff, format: 'text' | 'json' | 'sql' = 'text'): string {\n    return this.diffEngine.formatDiff(diff, format);\n  }\n\n  private async applyMigration(diff: SchemaSyncDiff): Promise<void> {\n    if (!diff.migration) return;\n\n    if (this.dialect.supportsTransactionalDDL) {\n      await this.driver.transaction(async (trx) => {\n        for (const sql of diff.migration!.upSql) {\n          await trx.execute(sql);\n        }\n      });\n    } else {\n      for (const sql of diff.migration.upSql) {\n        await this.driver.execute(sql);\n      }\n    }\n  }\n\n  private computeSchemaChecksum(schema: SchemaDefinition): string {\n    const normalized = JSON.stringify(schema, Object.keys(schema).sort());\n    return createHash('sha256').update(normalized).digest('hex');\n  }\n}\n\nexport function createSchemaSyncService(\n  driver: Driver,\n  dialect: Dialect,\n  remoteClient: SchemaRemoteClient,\n  options: SchemaSyncServiceOptions,\n  logger?: Logger\n): SchemaSyncService {\n  return new SchemaSyncService(driver, dialect, remoteClient, options, logger);\n}\n","import type { Driver } from '../driver/types.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { SyncStatus } from './types.js';\n\nexport interface SyncMetadataOptions {\n  tableName?: string;\n}\n\nexport class SyncMetadataManager {\n  private tableName: string;\n\n  constructor(\n    private driver: Driver,\n    private dialect: Dialect,\n    options: SyncMetadataOptions = {}\n  ) {\n    this.tableName = options.tableName ?? 'lp_schema_sync';\n  }\n\n  async ensureSyncTable(): Promise<void> {\n    let sql: string;\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n          app_id TEXT NOT NULL,\n          table_name TEXT NOT NULL,\n          local_checksum TEXT,\n          local_version TEXT,\n          local_updated_at TIMESTAMPTZ,\n          remote_checksum TEXT,\n          remote_version TEXT,\n          remote_updated_at TIMESTAMPTZ,\n          sync_status TEXT NOT NULL DEFAULT 'unknown',\n          last_sync_at TIMESTAMPTZ,\n          last_sync_direction TEXT,\n          last_sync_by TEXT,\n          base_checksum TEXT,\n          conflict_details JSONB,\n          created_at TIMESTAMPTZ DEFAULT NOW(),\n          updated_at TIMESTAMPTZ DEFAULT NOW(),\n          UNIQUE(app_id, table_name)\n        )\n      `;\n    } else if (this.dialect.name === 'mysql') {\n      sql = `\n        CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n          id CHAR(36) PRIMARY KEY,\n          app_id VARCHAR(255) NOT NULL,\n          table_name VARCHAR(255) NOT NULL,\n          local_checksum VARCHAR(64),\n          local_version VARCHAR(50),\n          local_updated_at DATETIME,\n          remote_checksum VARCHAR(64),\n          remote_version VARCHAR(50),\n          remote_updated_at DATETIME,\n          sync_status VARCHAR(20) NOT NULL DEFAULT 'unknown',\n          last_sync_at DATETIME,\n          last_sync_direction VARCHAR(10),\n          last_sync_by VARCHAR(255),\n          base_checksum VARCHAR(64),\n          conflict_details JSON,\n          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n          UNIQUE KEY unique_app_table (app_id, table_name)\n        )\n      `;\n    } else {\n      sql = `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          id TEXT PRIMARY KEY,\n          app_id TEXT NOT NULL,\n          table_name TEXT NOT NULL,\n          local_checksum TEXT,\n          local_version TEXT,\n          local_updated_at TEXT,\n          remote_checksum TEXT,\n          remote_version TEXT,\n          remote_updated_at TEXT,\n          sync_status TEXT NOT NULL DEFAULT 'unknown',\n          last_sync_at TEXT,\n          last_sync_direction TEXT,\n          last_sync_by TEXT,\n          base_checksum TEXT,\n          conflict_details TEXT,\n          created_at TEXT DEFAULT (datetime('now')),\n          updated_at TEXT DEFAULT (datetime('now')),\n          UNIQUE(app_id, table_name)\n        )\n      `;\n    }\n\n    await this.driver.execute(sql);\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver\n        .execute(`\n        CREATE INDEX IF NOT EXISTS idx_${this.tableName}_status\n        ON \"${this.tableName}\"(app_id, sync_status)\n      `)\n        .catch(() => {});\n    }\n  }\n\n  async getSyncState(appId: string, tableName: string): Promise<SyncStatus | null> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `SELECT * FROM \"${this.tableName}\" WHERE app_id = $1 AND table_name = $2`;\n      params = [appId, tableName];\n    } else {\n      sql = `SELECT * FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE app_id = ? AND table_name = ?`;\n      params = [appId, tableName];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      table_name: string;\n      local_checksum: string | null;\n      local_version: string | null;\n      local_updated_at: Date | string | null;\n      remote_checksum: string | null;\n      remote_version: string | null;\n      remote_updated_at: Date | string | null;\n      sync_status: string;\n      last_sync_at: Date | string | null;\n      last_sync_direction: string | null;\n      last_sync_by: string | null;\n      base_checksum: string | null;\n      conflict_details: Record<string, unknown> | string | null;\n    }>(sql, params);\n\n    if (!result.rows.length) return null;\n\n    const row = result.rows[0];\n\n    return {\n      appId: row.app_id,\n      tableName: row.table_name,\n      localChecksum: row.local_checksum,\n      localVersion: row.local_version,\n      localUpdatedAt: row.local_updated_at ? new Date(row.local_updated_at) : null,\n      remoteChecksum: row.remote_checksum,\n      remoteVersion: row.remote_version,\n      remoteUpdatedAt: row.remote_updated_at ? new Date(row.remote_updated_at) : null,\n      syncStatus: row.sync_status as SyncStatus['syncStatus'],\n      lastSyncAt: row.last_sync_at ? new Date(row.last_sync_at) : null,\n      lastSyncDirection: row.last_sync_direction as SyncStatus['lastSyncDirection'],\n      lastSyncBy: row.last_sync_by,\n      baseChecksum: row.base_checksum,\n      conflictDetails:\n        typeof row.conflict_details === 'string'\n          ? JSON.parse(row.conflict_details)\n          : row.conflict_details,\n    };\n  }\n\n  async getAllSyncStates(appId: string): Promise<SyncStatus[]> {\n    let sql: string;\n    let params: unknown[];\n\n    if (this.dialect.name === 'postgresql') {\n      sql = `SELECT * FROM \"${this.tableName}\" WHERE app_id = $1 ORDER BY table_name`;\n      params = [appId];\n    } else {\n      sql = `SELECT * FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE app_id = ? ORDER BY table_name`;\n      params = [appId];\n    }\n\n    const result = await this.driver.query<{\n      app_id: string;\n      table_name: string;\n      local_checksum: string | null;\n      local_version: string | null;\n      local_updated_at: Date | string | null;\n      remote_checksum: string | null;\n      remote_version: string | null;\n      remote_updated_at: Date | string | null;\n      sync_status: string;\n      last_sync_at: Date | string | null;\n      last_sync_direction: string | null;\n      last_sync_by: string | null;\n      base_checksum: string | null;\n      conflict_details: Record<string, unknown> | string | null;\n    }>(sql, params);\n\n    return result.rows.map((row) => ({\n      appId: row.app_id,\n      tableName: row.table_name,\n      localChecksum: row.local_checksum,\n      localVersion: row.local_version,\n      localUpdatedAt: row.local_updated_at ? new Date(row.local_updated_at) : null,\n      remoteChecksum: row.remote_checksum,\n      remoteVersion: row.remote_version,\n      remoteUpdatedAt: row.remote_updated_at ? new Date(row.remote_updated_at) : null,\n      syncStatus: row.sync_status as SyncStatus['syncStatus'],\n      lastSyncAt: row.last_sync_at ? new Date(row.last_sync_at) : null,\n      lastSyncDirection: row.last_sync_direction as SyncStatus['lastSyncDirection'],\n      lastSyncBy: row.last_sync_by,\n      baseChecksum: row.base_checksum,\n      conflictDetails:\n        typeof row.conflict_details === 'string'\n          ? JSON.parse(row.conflict_details)\n          : row.conflict_details,\n    }));\n  }\n\n  async updateSyncState(\n    appId: string,\n    direction: 'push' | 'pull',\n    data: {\n      localChecksum?: string;\n      localVersion?: string;\n      remoteChecksum?: string;\n      remoteVersion?: string;\n      syncBy?: string;\n    }\n  ): Promise<void> {\n    const now = new Date().toISOString();\n    const status = 'synced';\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(\n        `\n        INSERT INTO \"${this.tableName}\" (\n          app_id, table_name, local_checksum, local_version, local_updated_at,\n          remote_checksum, remote_version, remote_updated_at, sync_status,\n          last_sync_at, last_sync_direction, last_sync_by, base_checksum\n        )\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)\n        ON CONFLICT (app_id, table_name) DO UPDATE SET\n          local_checksum = COALESCE($3, \"${this.tableName}\".local_checksum),\n          local_version = COALESCE($4, \"${this.tableName}\".local_version),\n          local_updated_at = $5,\n          remote_checksum = COALESCE($6, \"${this.tableName}\".remote_checksum),\n          remote_version = COALESCE($7, \"${this.tableName}\".remote_version),\n          remote_updated_at = $8,\n          sync_status = $9,\n          last_sync_at = $10,\n          last_sync_direction = $11,\n          last_sync_by = $12,\n          base_checksum = COALESCE($13, \"${this.tableName}\".base_checksum),\n          updated_at = NOW()\n        `,\n        [\n          appId,\n          '__global__',\n          data.localChecksum ?? null,\n          data.localVersion ?? null,\n          now,\n          data.remoteChecksum ?? null,\n          data.remoteVersion ?? null,\n          now,\n          status,\n          now,\n          direction,\n          data.syncBy ?? null,\n          data.localChecksum ?? data.remoteChecksum ?? null,\n        ]\n      );\n    } else if (this.dialect.name === 'mysql') {\n      const id = this.generateUUID();\n      await this.driver.execute(\n        `\n        INSERT INTO \\`${this.tableName}\\` (\n          id, app_id, table_name, local_checksum, local_version, local_updated_at,\n          remote_checksum, remote_version, remote_updated_at, sync_status,\n          last_sync_at, last_sync_direction, last_sync_by, base_checksum\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n          local_checksum = COALESCE(VALUES(local_checksum), local_checksum),\n          local_version = COALESCE(VALUES(local_version), local_version),\n          local_updated_at = VALUES(local_updated_at),\n          remote_checksum = COALESCE(VALUES(remote_checksum), remote_checksum),\n          remote_version = COALESCE(VALUES(remote_version), remote_version),\n          remote_updated_at = VALUES(remote_updated_at),\n          sync_status = VALUES(sync_status),\n          last_sync_at = VALUES(last_sync_at),\n          last_sync_direction = VALUES(last_sync_direction),\n          last_sync_by = VALUES(last_sync_by),\n          base_checksum = COALESCE(VALUES(base_checksum), base_checksum)\n        `,\n        [\n          id,\n          appId,\n          '__global__',\n          data.localChecksum ?? null,\n          data.localVersion ?? null,\n          now,\n          data.remoteChecksum ?? null,\n          data.remoteVersion ?? null,\n          now,\n          status,\n          now,\n          direction,\n          data.syncBy ?? null,\n          data.localChecksum ?? data.remoteChecksum ?? null,\n        ]\n      );\n    } else {\n      const id = this.generateUUID();\n      await this.driver.execute(\n        `\n        INSERT OR REPLACE INTO \"${this.tableName}\" (\n          id, app_id, table_name, local_checksum, local_version, local_updated_at,\n          remote_checksum, remote_version, remote_updated_at, sync_status,\n          last_sync_at, last_sync_direction, last_sync_by, base_checksum,\n          created_at, updated_at\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))\n        `,\n        [\n          id,\n          appId,\n          '__global__',\n          data.localChecksum ?? null,\n          data.localVersion ?? null,\n          now,\n          data.remoteChecksum ?? null,\n          data.remoteVersion ?? null,\n          now,\n          status,\n          now,\n          direction,\n          data.syncBy ?? null,\n          data.localChecksum ?? data.remoteChecksum ?? null,\n        ]\n      );\n    }\n  }\n\n  async markConflict(\n    appId: string,\n    tableName: string,\n    conflictDetails: Record<string, unknown>\n  ): Promise<void> {\n    const detailsJson = JSON.stringify(conflictDetails);\n\n    if (this.dialect.name === 'postgresql') {\n      await this.driver.execute(\n        `\n        UPDATE \"${this.tableName}\"\n        SET sync_status = 'conflict', conflict_details = $1, updated_at = NOW()\n        WHERE app_id = $2 AND table_name = $3\n        `,\n        [detailsJson, appId, tableName]\n      );\n    } else {\n      const table = this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`;\n      await this.driver.execute(\n        `UPDATE ${table} SET sync_status = 'conflict', conflict_details = ? WHERE app_id = ? AND table_name = ?`,\n        [detailsJson, appId, tableName]\n      );\n    }\n  }\n\n  async detectConflicts(appId: string): Promise<SyncStatus[]> {\n    const states = await this.getAllSyncStates(appId);\n\n    return states.filter((state) => {\n      if (!state.localChecksum || !state.remoteChecksum || !state.baseChecksum) {\n        return false;\n      }\n\n      const localChanged = state.localChecksum !== state.baseChecksum;\n      const remoteChanged = state.remoteChecksum !== state.baseChecksum;\n\n      return localChanged && remoteChanged && state.localChecksum !== state.remoteChecksum;\n    });\n  }\n\n  private generateUUID(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n      const r = (Math.random() * 16) | 0;\n      const v = c === 'x' ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n}\n\nexport function createSyncMetadataManager(\n  driver: Driver,\n  dialect: Dialect,\n  options?: SyncMetadataOptions\n): SyncMetadataManager {\n  return new SyncMetadataManager(driver, dialect, options);\n}\n","import type { SchemaDefinition } from '../types/index.js';\n\nexport interface IntrospectedColumn {\n  name: string;\n  dataType: string;\n  udtName: string;\n  isNullable: boolean;\n  defaultValue: string | null;\n  maxLength: number | null;\n  numericPrecision: number | null;\n  numericScale: number | null;\n  isIdentity: boolean;\n  identityGeneration: 'ALWAYS' | 'BY DEFAULT' | null;\n}\n\nexport interface IntrospectedIndex {\n  name: string;\n  columns: string[];\n  isUnique: boolean;\n  isPrimary: boolean;\n  type: 'btree' | 'hash' | 'gin' | 'gist' | 'brin';\n  expression: string | null;\n}\n\nexport interface IntrospectedForeignKey {\n  name: string;\n  columns: string[];\n  referencedTable: string;\n  referencedColumns: string[];\n  onDelete: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n  onUpdate: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';\n}\n\nexport interface IntrospectedConstraint {\n  name: string;\n  type: 'CHECK' | 'UNIQUE' | 'PRIMARY KEY' | 'FOREIGN KEY' | 'EXCLUDE';\n  definition: string;\n}\n\nexport interface IntrospectedTable {\n  name: string;\n  schema: string;\n  columns: IntrospectedColumn[];\n  primaryKey: string[];\n  foreignKeys: IntrospectedForeignKey[];\n  indexes: IntrospectedIndex[];\n  constraints: IntrospectedConstraint[];\n}\n\nexport interface IntrospectedEnum {\n  name: string;\n  values: string[];\n}\n\nexport interface SchemaIntrospectionResult {\n  tables: IntrospectedTable[];\n  enums: IntrospectedEnum[];\n  extensions: string[];\n  introspectedAt: Date;\n  databaseVersion: string;\n}\n\nexport interface IntrospectOptions {\n  schemaPattern?: string;\n  excludeTables?: string[];\n  includeLaunchpadTables?: boolean;\n}\n\nexport type ChangeType =\n  | 'table_add'\n  | 'table_drop'\n  | 'column_add'\n  | 'column_drop'\n  | 'column_modify'\n  | 'index_add'\n  | 'index_drop'\n  | 'constraint_add'\n  | 'constraint_drop'\n  | 'foreign_key_add'\n  | 'foreign_key_drop';\n\nexport interface SchemaChange {\n  type: ChangeType;\n  tableName: string;\n  objectName?: string;\n  isBreaking: boolean;\n  description: string;\n  upSql: string;\n  downSql: string;\n  oldValue?: unknown;\n  newValue?: unknown;\n}\n\nexport interface DiffSummary {\n  tablesAdded: number;\n  tablesDropped: number;\n  tablesModified: number;\n  columnsAdded: number;\n  columnsDropped: number;\n  columnsModified: number;\n  indexesAdded: number;\n  indexesDropped: number;\n  foreignKeysAdded: number;\n  foreignKeysDropped: number;\n}\n\nexport interface MigrationScript {\n  version: string;\n  name: string;\n  upSql: string[];\n  downSql: string[];\n  checksum: string;\n}\n\nexport interface SchemaSyncDiff {\n  hasDifferences: boolean;\n  summary: DiffSummary;\n  changes: SchemaChange[];\n  breakingChanges: SchemaChange[];\n  migration: MigrationScript | null;\n}\n\nexport interface SyncStatus {\n  appId: string;\n  tableName: string;\n  localChecksum: string | null;\n  localVersion: string | null;\n  localUpdatedAt: Date | null;\n  remoteChecksum: string | null;\n  remoteVersion: string | null;\n  remoteUpdatedAt: Date | null;\n  syncStatus: 'synced' | 'pending' | 'behind' | 'conflict' | 'unknown';\n  lastSyncAt: Date | null;\n  lastSyncDirection: 'push' | 'pull' | null;\n  lastSyncBy: string | null;\n  baseChecksum: string | null;\n  conflictDetails: Record<string, unknown> | null;\n}\n\nexport interface PullOptions {\n  environment?: string;\n  dryRun?: boolean;\n  force?: boolean;\n}\n\nexport interface PushOptions {\n  environment?: string;\n  dryRun?: boolean;\n  force?: boolean;\n}\n\nexport interface DiffOptions {\n  environment?: string;\n  outputFormat?: 'text' | 'json' | 'sql';\n}\n\nexport interface PullResult {\n  applied: boolean;\n  diff: SchemaSyncDiff;\n}\n\nexport interface PushResult {\n  applied: boolean;\n  diff: SchemaSyncDiff;\n  remoteResult?: RemotePushResult;\n}\n\nexport interface RemoteSchemaResponse {\n  schema: SchemaDefinition;\n  version: string;\n  checksum: string;\n  updatedAt: string;\n  environment: string;\n}\n\nexport interface RemotePushResult {\n  success: boolean;\n  applied: boolean;\n  migration?: MigrationScript;\n  errors?: string[];\n  warnings?: string[];\n}\n\nexport interface RemoteSyncStatus {\n  version: string;\n  checksum: string;\n  updatedAt: string;\n  environment: string;\n}\n\nexport class SchemaRemoteError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number\n  ) {\n    super(message);\n    this.name = 'SchemaRemoteError';\n  }\n}\n\nexport class BreakingChangeError extends Error {\n  constructor(\n    message: string,\n    public changes: SchemaChange[] = []\n  ) {\n    super(message);\n    this.name = 'BreakingChangeError';\n  }\n}\n\nexport class ConflictError extends Error {\n  constructor(\n    message: string,\n    public conflicts: SchemaChange[] = []\n  ) {\n    super(message);\n    this.name = 'ConflictError';\n  }\n}\n\nexport class AuthenticationError extends Error {\n  constructor(message = 'Authentication failed. Run `launchpad login` to authenticate.') {\n    super(message);\n    this.name = 'AuthenticationError';\n  }\n}\n\nexport class UserCancelledError extends Error {\n  constructor(message = 'Operation cancelled by user.') {\n    super(message);\n    this.name = 'UserCancelledError';\n  }\n}\n","import type { MigrationScript } from '../schema/types.js';\nimport { AuthenticationError, SchemaRemoteError } from '../schema/types.js';\nimport type {\n  RemoteConfig,\n  RemoteHealthResponse,\n  RemotePushOptions,\n  RemotePushResult,\n  RemoteSchemaResponse,\n  RemoteSyncStatus,\n} from './types.js';\n\nexport interface SchemaRemoteClientOptions {\n  timeout?: number;\n  retries?: number;\n}\n\nexport class SchemaRemoteClient {\n  private apiUrl: string;\n  private projectId: string;\n  private authToken: string;\n  private timeout: number;\n  private retries: number;\n\n  private schemaCache: Map<string, { schema: RemoteSchemaResponse; cachedAt: number }> = new Map();\n  private readonly CACHE_TTL = 5 * 60 * 1000;\n\n  constructor(config: RemoteConfig, options: SchemaRemoteClientOptions = {}) {\n    this.apiUrl = config.apiUrl.replace(/\\/$/, '');\n    this.projectId = config.projectId;\n    this.authToken = config.authToken;\n    this.timeout = options.timeout ?? 30000;\n    this.retries = options.retries ?? 3;\n  }\n\n  async fetchSchema(environment = 'production'): Promise<RemoteSchemaResponse> {\n    const cacheKey = `${this.projectId}-${environment}`;\n    const cached = this.schemaCache.get(cacheKey);\n\n    if (cached && Date.now() - cached.cachedAt < this.CACHE_TTL) {\n      return cached.schema;\n    }\n\n    const response = await this.request<RemoteSchemaResponse>(\n      'GET',\n      `/v1/projects/${this.projectId}/schema`,\n      undefined,\n      { 'X-Environment': environment }\n    );\n\n    this.schemaCache.set(cacheKey, {\n      schema: response,\n      cachedAt: Date.now(),\n    });\n\n    return response;\n  }\n\n  async pushMigration(\n    migration: MigrationScript,\n    options: RemotePushOptions = {}\n  ): Promise<RemotePushResult> {\n    const environment = options.environment ?? 'production';\n\n    this.schemaCache.delete(`${this.projectId}-${environment}`);\n\n    return this.request<RemotePushResult>(\n      'POST',\n      `/v1/projects/${this.projectId}/schema/migrations`,\n      {\n        migration,\n        dryRun: options.dryRun ?? false,\n        force: options.force ?? false,\n      },\n      { 'X-Environment': environment }\n    );\n  }\n\n  async getSyncStatus(environment = 'production'): Promise<RemoteSyncStatus> {\n    return this.request<RemoteSyncStatus>(\n      'GET',\n      `/v1/projects/${this.projectId}/schema/sync-status`,\n      undefined,\n      { 'X-Environment': environment }\n    );\n  }\n\n  async healthCheck(): Promise<RemoteHealthResponse> {\n    return this.request<RemoteHealthResponse>('GET', '/v1/health');\n  }\n\n  clearCache(): void {\n    this.schemaCache.clear();\n  }\n\n  private async request<T>(\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    path: string,\n    body?: unknown,\n    additionalHeaders?: Record<string, string>\n  ): Promise<T> {\n    const url = `${this.apiUrl}${path}`;\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${this.authToken}`,\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n      ...additionalHeaders,\n    };\n\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt < this.retries; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n        const response = await fetch(url, {\n          method,\n          headers,\n          body: body ? JSON.stringify(body) : undefined,\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          if (response.status === 401) {\n            throw new AuthenticationError('Invalid or expired authentication token.');\n          }\n\n          if (response.status === 403) {\n            throw new SchemaRemoteError('Permission denied. Check your API key permissions.', 403);\n          }\n\n          if (response.status === 404) {\n            throw new SchemaRemoteError(`Project not found: ${this.projectId}`, 404);\n          }\n\n          if (response.status >= 500 && attempt < this.retries - 1) {\n            await this.delay(2 ** attempt * 1000);\n            continue;\n          }\n\n          const errorBody = await response.text();\n          let errorMessage: string;\n\n          try {\n            const parsed = JSON.parse(errorBody);\n            errorMessage = parsed.message || parsed.error || errorBody;\n          } catch {\n            errorMessage = errorBody || response.statusText;\n          }\n\n          throw new SchemaRemoteError(errorMessage, response.status);\n        }\n\n        return (await response.json()) as T;\n      } catch (error) {\n        if (error instanceof AuthenticationError || error instanceof SchemaRemoteError) {\n          throw error;\n        }\n\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (error instanceof Error && error.name === 'AbortError') {\n          lastError = new SchemaRemoteError(`Request timeout after ${this.timeout}ms`);\n        }\n\n        if (attempt < this.retries - 1) {\n          await this.delay(2 ** attempt * 1000);\n        }\n      }\n    }\n\n    throw lastError ?? new SchemaRemoteError('Request failed after retries');\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\nexport function createSchemaRemoteClient(\n  config: RemoteConfig,\n  options?: SchemaRemoteClientOptions\n): SchemaRemoteClient {\n  return new SchemaRemoteClient(config, options);\n}\n","import { mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { homedir } from 'node:os';\nimport { dirname, join } from 'node:path';\nimport { AuthenticationError } from '../schema/types.js';\n\nexport interface Credentials {\n  token: string;\n  refreshToken?: string;\n  expiresAt?: string;\n  projectId?: string;\n}\n\nexport interface AuthConfig {\n  credentialsPath?: string;\n}\n\nconst DEFAULT_CREDENTIALS_PATH = join(homedir(), '.launchpad', 'credentials.json');\n\nexport class AuthHandler {\n  private credentialsPath: string;\n  private cachedCredentials: Credentials | null = null;\n\n  constructor(config: AuthConfig = {}) {\n    this.credentialsPath = config.credentialsPath ?? DEFAULT_CREDENTIALS_PATH;\n  }\n\n  async getToken(): Promise<string> {\n    const credentials = await this.loadCredentials();\n\n    if (!credentials?.token) {\n      throw new AuthenticationError(\n        'No authentication token found. Run `launchpad login` to authenticate.'\n      );\n    }\n\n    if (credentials.expiresAt) {\n      const expiresAt = new Date(credentials.expiresAt);\n      if (expiresAt <= new Date()) {\n        if (credentials.refreshToken) {\n          return this.refreshToken(credentials.refreshToken);\n        }\n        throw new AuthenticationError(\n          'Authentication token has expired. Run `launchpad login` to re-authenticate.'\n        );\n      }\n    }\n\n    return credentials.token;\n  }\n\n  async getProjectId(): Promise<string | undefined> {\n    const credentials = await this.loadCredentials();\n    return credentials?.projectId;\n  }\n\n  async saveCredentials(credentials: Credentials): Promise<void> {\n    await mkdir(dirname(this.credentialsPath), { recursive: true });\n    await writeFile(this.credentialsPath, JSON.stringify(credentials, null, 2), 'utf-8');\n    this.cachedCredentials = credentials;\n  }\n\n  async clearCredentials(): Promise<void> {\n    try {\n      await writeFile(this.credentialsPath, '{}', 'utf-8');\n      this.cachedCredentials = null;\n    } catch {}\n  }\n\n  async isAuthenticated(): Promise<boolean> {\n    try {\n      await this.getToken();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async loadCredentials(): Promise<Credentials | null> {\n    if (this.cachedCredentials) {\n      return this.cachedCredentials;\n    }\n\n    try {\n      const content = await readFile(this.credentialsPath, 'utf-8');\n      this.cachedCredentials = JSON.parse(content) as Credentials;\n      return this.cachedCredentials;\n    } catch {\n      return null;\n    }\n  }\n\n  private async refreshToken(_refreshToken: string): Promise<string> {\n    throw new AuthenticationError(\n      'Token refresh not implemented. Run `launchpad login` to re-authenticate.'\n    );\n  }\n}\n\nexport function createAuthHandler(config?: AuthConfig): AuthHandler {\n  return new AuthHandler(config);\n}\n","import type { ColumnDefinition, ColumnType, SchemaDefinition } from './index.js';\n\nexport interface TypeGeneratorOptions {\n  includeInsertTypes?: boolean;\n  includeUpdateTypes?: boolean;\n  includeZodSchemas?: boolean;\n  omitTenantColumns?: boolean;\n  insertSuffix?: string;\n  updateSuffix?: string;\n}\n\nfunction pascalCase(str: string): string {\n  return str\n    .split(/[-_]/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\nfunction camelCase(str: string): string {\n  const pascal = pascalCase(str);\n  return pascal.charAt(0).toLowerCase() + pascal.slice(1);\n}\n\nfunction pgTypeToTs(type: ColumnType): string {\n  const map: Record<ColumnType, string> = {\n    uuid: 'string',\n    string: 'string',\n    text: 'string',\n    integer: 'number',\n    bigint: 'number',\n    float: 'number',\n    decimal: 'number',\n    boolean: 'boolean',\n    datetime: 'Date',\n    date: 'Date',\n    time: 'string',\n    json: 'Record<string, unknown>',\n    binary: 'Buffer',\n  };\n  return map[type] || 'unknown';\n}\n\nfunction pgTypeToZod(type: ColumnType): string {\n  const map: Record<ColumnType, string> = {\n    uuid: 'z.string().uuid()',\n    string: 'z.string()',\n    text: 'z.string()',\n    integer: 'z.number().int()',\n    bigint: 'z.number().int()',\n    float: 'z.number()',\n    decimal: 'z.number()',\n    boolean: 'z.boolean()',\n    datetime: 'z.coerce.date()',\n    date: 'z.coerce.date()',\n    time: 'z.string()',\n    json: 'z.record(z.unknown())',\n    binary: 'z.instanceof(Buffer)',\n  };\n  return map[type] || 'z.unknown()';\n}\n\nfunction isAutoGeneratedColumn(colName: string, col: ColumnDefinition): boolean {\n  if (colName === 'id' && col.default) return true;\n  if (colName === 'created_at' && col.default) return true;\n  if (colName === 'updated_at' && col.default) return true;\n  return false;\n}\n\nexport function generateTypes(\n  schemas: Map<string, SchemaDefinition>,\n  options: TypeGeneratorOptions = {}\n): string {\n  const {\n    includeInsertTypes = true,\n    includeUpdateTypes = true,\n    omitTenantColumns = true,\n    insertSuffix = 'Insert',\n    updateSuffix = 'Update',\n  } = options;\n\n  const lines: string[] = [\n    '// Auto-generated by @launchpad/db-engine',\n    '// Do not edit this file manually',\n    '',\n  ];\n\n  for (const [schemaName, schema] of schemas) {\n    const namespace = pascalCase(schemaName);\n    lines.push(`export namespace ${namespace} {`);\n\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      const typeName = pascalCase(tableName);\n\n      lines.push(`  /** Row type for ${tableName} table */`);\n      lines.push(`  export interface ${typeName} {`);\n\n      for (const [colName, col] of Object.entries(table.columns)) {\n        const tsType = pgTypeToTs(col.type);\n        const nullable = col.nullable ? ' | null' : '';\n        lines.push(`    ${colName}: ${tsType}${nullable};`);\n      }\n\n      lines.push('  }');\n      lines.push('');\n\n      if (includeInsertTypes) {\n        lines.push(`  /** Insert type for ${tableName} table (omits auto-generated fields) */`);\n        lines.push(`  export interface ${typeName}${insertSuffix} {`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (isAutoGeneratedColumn(colName, col)) continue;\n          if (omitTenantColumns && col.tenant) continue;\n\n          const tsType = pgTypeToTs(col.type);\n          const optional = col.nullable || col.default ? '?' : '';\n          lines.push(`    ${colName}${optional}: ${tsType};`);\n        }\n\n        lines.push('  }');\n        lines.push('');\n      }\n\n      if (includeUpdateTypes) {\n        lines.push(`  /** Update type for ${tableName} table (all fields optional) */`);\n        lines.push(`  export interface ${typeName}${updateSuffix} {`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (colName === 'id') continue;\n          if (colName === 'created_at') continue;\n\n          if (omitTenantColumns && col.tenant) continue;\n\n          const tsType = pgTypeToTs(col.type);\n          lines.push(`    ${colName}?: ${tsType} | null;`);\n        }\n\n        lines.push('  }');\n        lines.push('');\n      }\n    }\n\n    const tableNames = Object.keys(schema.tables)\n      .map((t) => `'${t}'`)\n      .join(' | ');\n    lines.push(`  export type TableName = ${tableNames};`);\n    lines.push('');\n\n    lines.push('  export interface Tables {');\n    for (const tableName of Object.keys(schema.tables)) {\n      const typeName = pascalCase(tableName);\n      lines.push(`    ${tableName}: ${typeName};`);\n    }\n    lines.push('  }');\n\n    lines.push('}');\n    lines.push('');\n  }\n\n  lines.push('export type AllSchemas = {');\n  for (const schemaName of schemas.keys()) {\n    const namespace = pascalCase(schemaName);\n    lines.push(`  ${schemaName}: typeof ${namespace};`);\n  }\n  lines.push('};');\n\n  return lines.join('\\n');\n}\n\nexport function generateZodSchemas(\n  schemas: Map<string, SchemaDefinition>,\n  options: TypeGeneratorOptions = {}\n): string {\n  const {\n    includeInsertTypes = true,\n    includeUpdateTypes = true,\n    omitTenantColumns = true,\n    insertSuffix = 'Insert',\n    updateSuffix = 'Update',\n  } = options;\n\n  const lines: string[] = [\n    '// Auto-generated by @launchpad/db-engine',\n    '// Do not edit this file manually',\n    '',\n    \"import { z } from 'zod';\",\n    '',\n  ];\n\n  for (const [schemaName, schema] of schemas) {\n    const schemaPrefix = camelCase(schemaName);\n    lines.push(`// ==================== ${pascalCase(schemaName)} Schema ====================`);\n    lines.push('');\n\n    for (const [tableName, table] of Object.entries(schema.tables)) {\n      const typeName = pascalCase(tableName);\n\n      lines.push(`/** Zod schema for ${tableName} row */`);\n      lines.push(`export const ${schemaPrefix}${typeName}Schema = z.object({`);\n\n      for (const [colName, col] of Object.entries(table.columns)) {\n        let zodType = pgTypeToZod(col.type);\n        if (col.nullable) {\n          zodType += '.nullable()';\n        }\n        lines.push(`  ${colName}: ${zodType},`);\n      }\n\n      lines.push('});');\n      lines.push('');\n\n      if (includeInsertTypes) {\n        lines.push(`/** Zod schema for ${tableName} insert (omits auto-generated fields) */`);\n        lines.push(`export const ${schemaPrefix}${typeName}${insertSuffix}Schema = z.object({`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (isAutoGeneratedColumn(colName, col)) continue;\n          if (omitTenantColumns && col.tenant) continue;\n\n          let zodType = pgTypeToZod(col.type);\n          if (col.nullable || col.default) {\n            zodType += '.optional()';\n          }\n          lines.push(`  ${colName}: ${zodType},`);\n        }\n\n        lines.push('});');\n        lines.push('');\n      }\n\n      if (includeUpdateTypes) {\n        lines.push(`/** Zod schema for ${tableName} update (all fields optional) */`);\n        lines.push(`export const ${schemaPrefix}${typeName}${updateSuffix}Schema = z.object({`);\n\n        for (const [colName, col] of Object.entries(table.columns)) {\n          if (colName === 'id') continue;\n          if (colName === 'created_at') continue;\n\n          if (omitTenantColumns && col.tenant) continue;\n\n          let zodType = pgTypeToZod(col.type);\n          zodType += '.nullable().optional()';\n          lines.push(`  ${colName}: ${zodType},`);\n        }\n\n        lines.push('});');\n        lines.push('');\n      }\n\n      lines.push('/** Inferred types from Zod schemas */');\n      lines.push(`export type ${typeName} = z.infer<typeof ${schemaPrefix}${typeName}Schema>;`);\n      if (includeInsertTypes) {\n        lines.push(\n          `export type ${typeName}${insertSuffix} = z.infer<typeof ${schemaPrefix}${typeName}${insertSuffix}Schema>;`\n        );\n      }\n      if (includeUpdateTypes) {\n        lines.push(\n          `export type ${typeName}${updateSuffix} = z.infer<typeof ${schemaPrefix}${typeName}${updateSuffix}Schema>;`\n        );\n      }\n      lines.push('');\n    }\n  }\n\n  return lines.join('\\n');\n}\n\nexport function generateSchemaFromDefinition(schema: SchemaDefinition): string {\n  const lines: string[] = [\n    \"import type { SchemaDefinition } from '@launchpad/db-engine';\",\n    '',\n    'export const schema: SchemaDefinition = {',\n    '  tables: {',\n  ];\n\n  for (const [tableName, table] of Object.entries(schema.tables)) {\n    lines.push(`    ${tableName}: {`);\n    lines.push('      columns: {');\n\n    for (const [colName, col] of Object.entries(table.columns)) {\n      const colDef: string[] = [];\n      colDef.push(`type: '${col.type}'`);\n\n      if (col.primaryKey) colDef.push('primaryKey: true');\n      if (col.nullable) colDef.push('nullable: true');\n      if (col.unique) colDef.push('unique: true');\n      if (col.default) colDef.push(`default: '${col.default}'`);\n      if (col.tenant) colDef.push('tenant: true');\n\n      if (col.references) {\n        colDef.push(\n          `references: { table: '${col.references.table}', column: '${col.references.column}'${col.references.onDelete ? `, onDelete: '${col.references.onDelete}'` : ''} }`\n        );\n      }\n\n      lines.push(`        ${colName}: { ${colDef.join(', ')} },`);\n    }\n\n    lines.push('      },');\n\n    if (table.indexes?.length) {\n      lines.push('      indexes: [');\n      for (const index of table.indexes) {\n        const indexDef: string[] = [];\n        indexDef.push(`columns: [${index.columns.map((c) => `'${c}'`).join(', ')}]`);\n        if (index.name) indexDef.push(`name: '${index.name}'`);\n        if (index.unique) indexDef.push('unique: true');\n        if (index.where) indexDef.push(`where: '${index.where}'`);\n        lines.push(`        { ${indexDef.join(', ')} },`);\n      }\n      lines.push('      ],');\n    }\n\n    lines.push('    },');\n  }\n\n  lines.push('  },');\n  lines.push('};');\n\n  return lines.join('\\n');\n}\n","import type { SchemaDefinition } from './index.js';\n\nexport interface HooksGeneratorOptions {\n  includeQueryHooks?: boolean;\n  includeMutationHooks?: boolean;\n  typesImportPath?: string;\n}\n\nfunction pascalCase(str: string): string {\n  return str\n    .split(/[-_]/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\nfunction singularize(word: string): string {\n  if (word.endsWith('ies')) {\n    return `${word.slice(0, -3)}y`;\n  }\n  if (\n    word.endsWith('ses') ||\n    word.endsWith('xes') ||\n    word.endsWith('zes') ||\n    word.endsWith('ches') ||\n    word.endsWith('shes')\n  ) {\n    return word.slice(0, -2);\n  }\n  if (word.endsWith('s') && !word.endsWith('ss')) {\n    return word.slice(0, -1);\n  }\n  return word;\n}\n\nfunction getHookNames(tableName: string): {\n  pluralName: string;\n  singularName: string;\n  listHook: string;\n  singleHook: string;\n  createHook: string;\n  updateHook: string;\n  deleteHook: string;\n} {\n  const pluralPascal = pascalCase(tableName);\n  const singularPascal = pascalCase(singularize(tableName));\n\n  return {\n    pluralName: pluralPascal,\n    singularName: singularPascal,\n    listHook: `use${pluralPascal}`,\n    singleHook: `use${singularPascal}`,\n    createHook: `useCreate${singularPascal}`,\n    updateHook: `useUpdate${singularPascal}`,\n    deleteHook: `useDelete${singularPascal}`,\n  };\n}\n\nfunction generateTableHooks(\n  tableName: string,\n  typeName: string,\n  options: HooksGeneratorOptions\n): string[] {\n  const lines: string[] = [];\n  const hooks = getHookNames(tableName);\n  const { includeQueryHooks = true, includeMutationHooks = true } = options;\n\n  lines.push(`// ==================== ${hooks.pluralName} ====================`);\n  lines.push('');\n\n  if (includeQueryHooks) {\n    lines.push(`/** Query hook for fetching all ${tableName} */`);\n    lines.push(\n      `export function ${hooks.listHook}(options?: Omit<UseQueryOptions<${typeName}>, 'table'>) {`\n    );\n    lines.push(`  return useQuery<${typeName}>({ ...options, table: '${tableName}' });`);\n    lines.push('}');\n    lines.push('');\n\n    lines.push(`/** Query hook for fetching a single ${singularize(tableName)} by ID */`);\n    lines.push(\n      `export function ${hooks.singleHook}(id: string, options?: Omit<UseQueryOptions<${typeName}>, 'table' | 'where'>) {`\n    );\n    lines.push(\n      `  return useQueryOne<${typeName}>({ ...options, table: '${tableName}', where: { id: { eq: id } } });`\n    );\n    lines.push('}');\n    lines.push('');\n  }\n\n  if (includeMutationHooks) {\n    lines.push(`/** Mutation hook for creating a ${singularize(tableName)} */`);\n    lines.push(\n      `export function ${hooks.createHook}(options?: UseMutationOptions<${typeName} | ${typeName}[], InsertVariables<${typeName}>>) {`\n    );\n    lines.push(`  const mutation = useInsert<${typeName}>(options);`);\n    lines.push('  return {');\n    lines.push('    ...mutation,');\n    lines.push(\n      `    mutate: (data: InsertVariables<${typeName}>['data']) => mutation.mutate({ table: '${tableName}', data }),`\n    );\n    lines.push(\n      `    mutateAsync: (data: InsertVariables<${typeName}>['data']) => mutation.mutateAsync({ table: '${tableName}', data }),`\n    );\n    lines.push('  };');\n    lines.push('}');\n    lines.push('');\n\n    lines.push(`/** Mutation hook for updating a ${singularize(tableName)} */`);\n    lines.push(\n      `export function ${hooks.updateHook}(options?: UseMutationOptions<${typeName}[], UpdateVariables<${typeName}>>) {`\n    );\n    lines.push(`  const mutation = useUpdate<${typeName}>(options);`);\n    lines.push('  return {');\n    lines.push('    ...mutation,');\n    lines.push(\n      `    mutate: (args: { where: UpdateVariables<${typeName}>['where']; data: UpdateVariables<${typeName}>['data'] }) =>`\n    );\n    lines.push(`      mutation.mutate({ table: '${tableName}', ...args }),`);\n    lines.push(\n      `    mutateAsync: (args: { where: UpdateVariables<${typeName}>['where']; data: UpdateVariables<${typeName}>['data'] }) =>`\n    );\n    lines.push(`      mutation.mutateAsync({ table: '${tableName}', ...args }),`);\n    lines.push('  };');\n    lines.push('}');\n    lines.push('');\n\n    lines.push(`/** Mutation hook for deleting a ${singularize(tableName)} */`);\n    lines.push(\n      `export function ${hooks.deleteHook}(options?: UseMutationOptions<{ deleted: number }, DeleteVariables<${typeName}>>) {`\n    );\n    lines.push(`  const mutation = useDelete<${typeName}>(options);`);\n    lines.push('  return {');\n    lines.push('    ...mutation,');\n    lines.push(\n      `    mutate: (where: DeleteVariables<${typeName}>['where']) => mutation.mutate({ table: '${tableName}', where }),`\n    );\n    lines.push(\n      `    mutateAsync: (where: DeleteVariables<${typeName}>['where']) => mutation.mutateAsync({ table: '${tableName}', where }),`\n    );\n    lines.push('  };');\n    lines.push('}');\n    lines.push('');\n  }\n\n  return lines;\n}\n\nexport function generateHooks(\n  schemas: Map<string, SchemaDefinition>,\n  options: HooksGeneratorOptions = {}\n): string {\n  const {\n    typesImportPath = './types',\n    includeQueryHooks = true,\n    includeMutationHooks = true,\n  } = options;\n\n  const lines: string[] = [\n    '// Auto-generated by @launchpad/db-engine',\n    '// Do not edit this file manually',\n    '',\n  ];\n\n  if (includeQueryHooks) {\n    lines.push(\"import { useQuery, useQueryOne } from '@launchpad/db/react';\");\n    lines.push(\"import type { UseQueryOptions } from '@launchpad/db/react';\");\n  }\n\n  if (includeMutationHooks) {\n    lines.push(\"import { useInsert, useUpdate, useDelete } from '@launchpad/db/react';\");\n    lines.push(\n      \"import type { UseMutationOptions, InsertVariables, UpdateVariables, DeleteVariables } from '@launchpad/db/react';\"\n    );\n  }\n\n  const typeImports: string[] = [];\n  for (const [schemaName, schema] of schemas) {\n    const namespace = pascalCase(schemaName);\n    for (const tableName of Object.keys(schema.tables)) {\n      const typeName = pascalCase(tableName);\n      typeImports.push(`${namespace}.${typeName}`);\n      if (includeMutationHooks) {\n        typeImports.push(`${namespace}.${typeName}Insert`);\n        typeImports.push(`${namespace}.${typeName}Update`);\n      }\n    }\n  }\n\n  if (typeImports.length > 0) {\n    const namespaces = new Set<string>();\n    for (const [schemaName] of schemas) {\n      namespaces.add(pascalCase(schemaName));\n    }\n    lines.push(`import type { ${Array.from(namespaces).join(', ')} } from '${typesImportPath}';`);\n  }\n\n  lines.push('');\n\n  for (const [schemaName, schema] of schemas) {\n    const namespace = pascalCase(schemaName);\n\n    for (const tableName of Object.keys(schema.tables)) {\n      const typeName = `${namespace}.${pascalCase(tableName)}`;\n      const tableHooks = generateTableHooks(tableName, typeName, {\n        includeQueryHooks,\n        includeMutationHooks,\n        typesImportPath,\n      });\n      lines.push(...tableHooks);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","import type { Driver, TransactionClient } from '../driver/types.js';\nimport type { QueryResult } from '../types/index.js';\n\nexport interface SeedResult {\n  count: number;\n  details?: Record<string, number>;\n}\n\nexport interface SeederMetadata {\n  name: string;\n  order: number;\n  dependencies: string[];\n  version: number;\n}\n\nexport interface SeederLogger {\n  info(message: string): void;\n  warn(message: string): void;\n  error(message: string): void;\n}\n\nconst defaultLogger: SeederLogger = {\n  info: (msg) => console.log(msg),\n  warn: (msg) => console.warn(msg),\n  error: (msg) => console.error(msg),\n};\n\nexport abstract class Seeder {\n  static order = 0;\n  static dependencies: string[] = [];\n  static version = 1;\n\n  protected driver: Driver;\n  protected logger: SeederLogger;\n\n  constructor(driver: Driver, logger?: SeederLogger) {\n    this.driver = driver;\n    this.logger = logger ?? defaultLogger;\n  }\n\n  abstract run(): Promise<SeedResult>;\n\n  async rollback(): Promise<void> {\n    throw new Error('Rollback not implemented');\n  }\n\n  get metadata(): SeederMetadata {\n    const ctor = this.constructor as typeof Seeder;\n    return {\n      name: this.constructor.name.replace(/Seeder$/, '').toLowerCase(),\n      order: ctor.order,\n      dependencies: ctor.dependencies,\n      version: ctor.version,\n    };\n  }\n\n  protected async query<T = Record<string, unknown>>(\n    sql: string,\n    params?: unknown[]\n  ): Promise<QueryResult<T>> {\n    return this.driver.query<T>(sql, params);\n  }\n\n  protected async execute(sql: string, params?: unknown[]): Promise<{ rowCount: number }> {\n    return this.driver.execute(sql, params);\n  }\n\n  protected async transaction<T>(fn: (trx: TransactionClient) => Promise<T>): Promise<T> {\n    return this.driver.transaction(fn);\n  }\n}\n","import { readFile, readdir } from 'node:fs/promises';\nimport { basename, join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport type { Driver } from '../driver/types.js';\nimport type { Seeder, SeederLogger } from './base.js';\nimport { SqlSeederAdapter } from './sql-adapter.js';\n\nexport type SeederConstructor = new (driver: Driver, logger?: SeederLogger) => Seeder;\n\nexport interface LoadedSeeder {\n  name: string;\n  path: string;\n  type: 'typescript' | 'sql';\n  order: number;\n  dependencies: string[];\n  SeederClass?: SeederConstructor & { order?: number; dependencies?: string[]; version?: number };\n  sqlContent?: string;\n}\n\nexport interface SeedLoaderOptions {\n  seedsPath?: string;\n}\n\nexport class SeedLoader {\n  private seedsPath: string;\n\n  constructor(options: SeedLoaderOptions = {}) {\n    this.seedsPath = options.seedsPath ?? './seeds';\n  }\n\n  async discover(): Promise<LoadedSeeder[]> {\n    const files = await this.findSeedFiles();\n    const seeders: LoadedSeeder[] = [];\n\n    for (const file of files) {\n      if (file.endsWith('.ts') || file.endsWith('.js')) {\n        seeders.push(await this.loadTypeScriptSeeder(file));\n      } else if (file.endsWith('.sql')) {\n        seeders.push(await this.loadSqlSeeder(file));\n      }\n    }\n\n    return this.sortByDependencies(seeders);\n  }\n\n  private async findSeedFiles(): Promise<string[]> {\n    try {\n      const files = await readdir(this.seedsPath);\n      return files\n        .filter((f) => f.endsWith('.ts') || f.endsWith('.js') || f.endsWith('.sql'))\n        .filter((f) => !f.endsWith('.test.ts') && !f.endsWith('.spec.ts'))\n        .filter((f) => f !== 'index.ts' && f !== 'index.js')\n        .sort();\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  private async loadTypeScriptSeeder(filename: string): Promise<LoadedSeeder> {\n    const fullPath = join(this.seedsPath, filename);\n    const fileUrl = pathToFileURL(fullPath).href;\n    const module = await import(fileUrl);\n    const SeederClass = module.default as SeederConstructor & {\n      order?: number;\n      dependencies?: string[];\n      version?: number;\n    };\n\n    if (!SeederClass || typeof SeederClass !== 'function') {\n      throw new Error(`Seeder file ${filename} must export a default class extending Seeder`);\n    }\n\n    const name = this.extractName(filename);\n    const order = SeederClass.order ?? this.extractOrderFromFilename(filename);\n    const dependencies = SeederClass.dependencies ?? [];\n\n    return {\n      name,\n      path: fullPath,\n      type: 'typescript',\n      order,\n      dependencies,\n      SeederClass,\n    };\n  }\n\n  private async loadSqlSeeder(filename: string): Promise<LoadedSeeder> {\n    const fullPath = join(this.seedsPath, filename);\n    const sqlContent = await readFile(fullPath, 'utf-8');\n\n    const name = this.extractName(filename);\n    const order = this.extractOrderFromFilename(filename);\n\n    return {\n      name,\n      path: fullPath,\n      type: 'sql',\n      order,\n      dependencies: [],\n      sqlContent,\n    };\n  }\n\n  private extractName(filename: string): string {\n    const base = basename(filename).replace(/\\.(ts|js|sql)$/, '');\n    return base.replace(/^\\d+[-_]/, '');\n  }\n\n  private extractOrderFromFilename(filename: string): number {\n    const match = filename.match(/^(\\d+)[-_]/);\n    return match ? Number.parseInt(match[1], 10) : 999;\n  }\n\n  private sortByDependencies(seeders: LoadedSeeder[]): LoadedSeeder[] {\n    return this.topologicalSort(seeders);\n  }\n\n  private topologicalSort(seeders: LoadedSeeder[]): LoadedSeeder[] {\n    const seederMap = new Map(seeders.map((s) => [s.name, s]));\n    const inDegree = new Map<string, number>();\n    const graph = new Map<string, string[]>();\n\n    for (const seeder of seeders) {\n      inDegree.set(seeder.name, seeder.dependencies.length);\n      graph.set(seeder.name, []);\n    }\n\n    for (const seeder of seeders) {\n      for (const dep of seeder.dependencies) {\n        if (!seederMap.has(dep)) {\n          throw new Error(`Seeder \"${seeder.name}\" depends on unknown seeder \"${dep}\"`);\n        }\n        graph.get(dep)!.push(seeder.name);\n      }\n    }\n\n    const queue = seeders.filter((s) => inDegree.get(s.name) === 0);\n    queue.sort((a, b) => a.order - b.order);\n    const result: LoadedSeeder[] = [];\n\n    while (queue.length > 0) {\n      queue.sort((a, b) => a.order - b.order);\n      const current = queue.shift()!;\n      result.push(current);\n\n      for (const dependent of graph.get(current.name)!) {\n        const newDegree = inDegree.get(dependent)! - 1;\n        inDegree.set(dependent, newDegree);\n        if (newDegree === 0) {\n          queue.push(seederMap.get(dependent)!);\n        }\n      }\n    }\n\n    if (result.length !== seeders.length) {\n      const remaining = seeders.filter((s) => !result.includes(s)).map((s) => s.name);\n      throw new Error(`Circular dependency detected in seeders: ${remaining.join(', ')}`);\n    }\n\n    return result;\n  }\n\n  createInstance(loaded: LoadedSeeder, driver: Driver, logger?: SeederLogger): Seeder {\n    if (loaded.type === 'typescript' && loaded.SeederClass) {\n      return new loaded.SeederClass(driver, logger);\n    }\n    if (loaded.type === 'sql' && loaded.sqlContent) {\n      return new SqlSeederAdapter(driver, loaded.sqlContent, loaded.name, logger);\n    }\n    throw new Error(`Cannot create instance for seeder: ${loaded.name}`);\n  }\n}\n","import type { Driver } from '../driver/types.js';\nimport { type SeedResult, Seeder, type SeederLogger } from './base.js';\n\nexport class SqlSeederAdapter extends Seeder {\n  private sqlContent: string;\n  private seederName: string;\n\n  constructor(driver: Driver, sqlContent: string, name: string, logger?: SeederLogger) {\n    super(driver, logger);\n    this.sqlContent = sqlContent;\n    this.seederName = name;\n  }\n\n  get name(): string {\n    return this.seederName;\n  }\n\n  async run(): Promise<SeedResult> {\n    const statements = this.splitStatements(this.sqlContent);\n    let totalCount = 0;\n\n    for (const sql of statements) {\n      if (sql.trim()) {\n        const result = await this.execute(sql);\n        totalCount += result.rowCount;\n      }\n    }\n\n    return { count: totalCount };\n  }\n\n  private splitStatements(sql: string): string[] {\n    const statements: string[] = [];\n    let current = '';\n    let inQuote = false;\n    let quoteChar = '';\n    let inDollarQuote = false;\n    let dollarTag = '';\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    for (let i = 0; i < sql.length; i++) {\n      const char = sql[i];\n      const next = sql[i + 1] || '';\n\n      if (inLineComment) {\n        current += char;\n        if (char === '\\n') {\n          inLineComment = false;\n        }\n        continue;\n      }\n\n      if (inBlockComment) {\n        current += char;\n        if (char === '*' && next === '/') {\n          current += next;\n          i++;\n          inBlockComment = false;\n        }\n        continue;\n      }\n\n      if (inDollarQuote) {\n        current += char;\n        if (char === '$') {\n          const endTag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n          if (endTag && endTag[0] === dollarTag) {\n            current += sql.slice(i + 1, i + dollarTag.length);\n            i += dollarTag.length - 1;\n            inDollarQuote = false;\n            dollarTag = '';\n          }\n        }\n        continue;\n      }\n\n      if (inQuote) {\n        current += char;\n        if (char === quoteChar && next !== quoteChar) {\n          inQuote = false;\n        } else if (char === quoteChar && next === quoteChar) {\n          current += next;\n          i++;\n        }\n        continue;\n      }\n\n      if (char === '-' && next === '-') {\n        inLineComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '/' && next === '*') {\n        inBlockComment = true;\n        current += char;\n        continue;\n      }\n\n      if (char === '$') {\n        const tag = sql.slice(i).match(/^\\$[a-zA-Z0-9_]*\\$/);\n        if (tag) {\n          inDollarQuote = true;\n          dollarTag = tag[0];\n          current += dollarTag;\n          i += dollarTag.length - 1;\n          continue;\n        }\n      }\n\n      if (char === \"'\" || char === '\"') {\n        inQuote = true;\n        quoteChar = char;\n        current += char;\n        continue;\n      }\n\n      if (char === ';') {\n        const trimmed = current.trim();\n        if (trimmed) {\n          statements.push(trimmed);\n        }\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    const trimmed = current.trim();\n    if (trimmed) {\n      statements.push(trimmed);\n    }\n\n    return statements;\n  }\n}\n","import type { Driver } from '../driver/types.js';\nimport { getDialect } from '../migrations/dialects/index.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { SeedResult, Seeder, SeederLogger } from './base.js';\nimport { type LoadedSeeder, SeedLoader } from './loader.js';\nimport { SeedTracker } from './tracker.js';\n\nexport interface SeedRunnerOptions {\n  seedsPath?: string;\n  tableName?: string;\n}\n\nexport interface SeedRunOptions {\n  only?: string;\n  fresh?: boolean;\n  dryRun?: boolean;\n  force?: boolean;\n  allowProduction?: boolean;\n}\n\nexport interface SeederResult {\n  name: string;\n  status: 'success' | 'skipped' | 'failed';\n  count: number;\n  duration: number;\n  error?: string;\n}\n\nexport interface SeedRunResult {\n  success: boolean;\n  seeders: SeederResult[];\n  totalCount: number;\n  totalDuration: number;\n}\n\nconst defaultLogger: SeederLogger = {\n  info: (msg) => console.log(msg),\n  warn: (msg) => console.warn(msg),\n  error: (msg) => console.error(msg),\n};\n\nexport class SeedRunner {\n  private driver: Driver;\n  private dialect: Dialect;\n  private loader: SeedLoader;\n  private tracker: SeedTracker;\n  private logger: SeederLogger;\n\n  constructor(driver: Driver, options: SeedRunnerOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.loader = new SeedLoader({ seedsPath: options.seedsPath });\n    this.tracker = new SeedTracker(driver, { tableName: options.tableName });\n    this.logger = defaultLogger;\n  }\n\n  async run(options: SeedRunOptions = {}): Promise<SeedRunResult> {\n    if (process.env.NODE_ENV === 'production' && !options.allowProduction) {\n      throw new Error(\n        'Seeding in production is disabled by default. ' +\n          'Use --allow-production flag to override (dangerous!).'\n      );\n    }\n\n    await this.tracker.ensureTable();\n\n    const allSeeders = await this.loader.discover();\n    const filtered = this.filterSeeders(allSeeders, options);\n\n    if (filtered.length === 0) {\n      return { success: true, seeders: [], totalCount: 0, totalDuration: 0 };\n    }\n\n    if (options.fresh) {\n      await this.truncateTables(filtered);\n    }\n\n    const result: SeedRunResult = {\n      success: true,\n      seeders: [],\n      totalCount: 0,\n      totalDuration: 0,\n    };\n\n    const startTime = Date.now();\n\n    for (const loaded of filtered) {\n      const seederResult = await this.executeSeeder(loaded, options);\n      result.seeders.push(seederResult);\n      result.totalCount += seederResult.count;\n\n      if (seederResult.status === 'failed') {\n        result.success = false;\n        break;\n      }\n    }\n\n    result.totalDuration = Date.now() - startTime;\n    return result;\n  }\n\n  async rollback(seederName?: string): Promise<void> {\n    const allSeeders = await this.loader.discover();\n    const toRollback = seederName\n      ? allSeeders.filter((s) => s.name === seederName)\n      : allSeeders.reverse();\n\n    for (const loaded of toRollback) {\n      const instance = this.loader.createInstance(loaded, this.driver, this.logger);\n      try {\n        await instance.rollback();\n        await this.tracker.remove(loaded.name);\n        this.logger.info(`Rolled back: ${loaded.name}`);\n      } catch {\n        this.logger.warn(`Rollback not implemented for: ${loaded.name}`);\n      }\n    }\n  }\n\n  async status(): Promise<SeedRunResult> {\n    await this.tracker.ensureTable();\n    const records = await this.tracker.list();\n\n    const seeders: SeederResult[] = records.map((r) => ({\n      name: r.name,\n      status: 'success' as const,\n      count: r.record_count,\n      duration: r.execution_time_ms,\n    }));\n\n    return {\n      success: true,\n      seeders,\n      totalCount: seeders.reduce((sum, s) => sum + s.count, 0),\n      totalDuration: seeders.reduce((sum, s) => sum + s.duration, 0),\n    };\n  }\n\n  private filterSeeders(seeders: LoadedSeeder[], options: SeedRunOptions): LoadedSeeder[] {\n    if (!options.only) return seeders;\n\n    const target = seeders.find((s) => s.name.toLowerCase() === options.only!.toLowerCase());\n    if (!target) {\n      throw new Error(`Seeder not found: ${options.only}`);\n    }\n\n    const required = this.resolveDependencies(target, seeders);\n    return required;\n  }\n\n  private resolveDependencies(target: LoadedSeeder, all: LoadedSeeder[]): LoadedSeeder[] {\n    const result: LoadedSeeder[] = [];\n    const visited = new Set<string>();\n\n    const visit = (seeder: LoadedSeeder) => {\n      if (visited.has(seeder.name)) return;\n      visited.add(seeder.name);\n\n      for (const depName of seeder.dependencies) {\n        const dep = all.find((s) => s.name === depName);\n        if (dep) visit(dep);\n      }\n      result.push(seeder);\n    };\n\n    visit(target);\n    return result;\n  }\n\n  private async executeSeeder(\n    loaded: LoadedSeeder,\n    options: SeedRunOptions\n  ): Promise<SeederResult> {\n    const startTime = Date.now();\n\n    if (!options.force) {\n      const version = loaded.SeederClass?.version ?? 1;\n      const hasRun = await this.tracker.hasRun(loaded.name, version);\n      if (hasRun) {\n        return {\n          name: loaded.name,\n          status: 'skipped',\n          count: 0,\n          duration: 0,\n        };\n      }\n    }\n\n    try {\n      const instance = this.loader.createInstance(loaded, this.driver, this.logger);\n      let seedResult: SeedResult;\n\n      if (options.dryRun) {\n        seedResult = await this.dryRunSeeder(instance);\n      } else {\n        seedResult = await this.runWithTransaction(instance);\n        const version = loaded.SeederClass?.version ?? 1;\n        await this.tracker.record(loaded.name, version, seedResult, Date.now() - startTime);\n      }\n\n      return {\n        name: loaded.name,\n        status: 'success',\n        count: seedResult.count,\n        duration: Date.now() - startTime,\n      };\n    } catch (error) {\n      return {\n        name: loaded.name,\n        status: 'failed',\n        count: 0,\n        duration: Date.now() - startTime,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  private async runWithTransaction(seeder: Seeder): Promise<SeedResult> {\n    if (this.dialect.supportsTransactionalDDL) {\n      return this.driver.transaction(async () => {\n        return seeder.run();\n      });\n    }\n    return seeder.run();\n  }\n\n  private async dryRunSeeder(seeder: Seeder): Promise<SeedResult> {\n    await this.driver.execute('BEGIN');\n    try {\n      const result = await seeder.run();\n      return result;\n    } finally {\n      await this.driver.execute('ROLLBACK');\n    }\n  }\n\n  private async truncateTables(seeders: LoadedSeeder[]): Promise<void> {\n    const tables = seeders.map((s) => s.name).reverse();\n    for (const table of tables) {\n      try {\n        if (this.dialect.name === 'postgresql') {\n          await this.driver.execute(`TRUNCATE TABLE \"${table}\" CASCADE`);\n        } else if (this.dialect.name === 'mysql') {\n          await this.driver.execute('SET FOREIGN_KEY_CHECKS = 0');\n          await this.driver.execute(`TRUNCATE TABLE \\`${table}\\``);\n          await this.driver.execute('SET FOREIGN_KEY_CHECKS = 1');\n        } else {\n          await this.driver.execute(`DELETE FROM \"${table}\"`);\n        }\n      } catch {\n        // Table may not exist, continue\n      }\n    }\n    await this.tracker.clear();\n  }\n}\n\nexport function createSeedRunner(driver: Driver, options?: SeedRunnerOptions): SeedRunner {\n  return new SeedRunner(driver, options);\n}\n","import type { Driver } from '../driver/types.js';\nimport { getDialect } from '../migrations/dialects/index.js';\nimport type { Dialect } from '../migrations/dialects/types.js';\nimport type { SeedResult } from './base.js';\n\nexport interface SeedTrackerOptions {\n  tableName?: string;\n}\n\nexport interface SeedRecord {\n  id: number;\n  name: string;\n  version: number;\n  executed_at: Date;\n  execution_time_ms: number;\n  record_count: number;\n  checksum?: string;\n}\n\nexport class SeedTracker {\n  private driver: Driver;\n  private dialect: Dialect;\n  private tableName: string;\n\n  constructor(driver: Driver, options: SeedTrackerOptions = {}) {\n    this.driver = driver;\n    this.dialect = getDialect(driver.dialect);\n    this.tableName = options.tableName ?? 'lp_seeds';\n  }\n\n  async ensureTable(): Promise<void> {\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `\n        CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n          id SERIAL PRIMARY KEY,\n          name VARCHAR(255) NOT NULL,\n          version INTEGER NOT NULL DEFAULT 1,\n          executed_at TIMESTAMPTZ DEFAULT NOW(),\n          execution_time_ms INTEGER,\n          record_count INTEGER,\n          checksum VARCHAR(64),\n          UNIQUE(name, version)\n        )\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          CREATE TABLE IF NOT EXISTS \\`${this.tableName}\\` (\n            id INT AUTO_INCREMENT PRIMARY KEY,\n            name VARCHAR(255) NOT NULL,\n            version INT NOT NULL DEFAULT 1,\n            executed_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            execution_time_ms INT,\n            record_count INT,\n            checksum VARCHAR(64),\n            UNIQUE KEY unique_name_version (name, version)\n          )\n        `\n          : `\n          CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL,\n            version INTEGER NOT NULL DEFAULT 1,\n            executed_at TEXT DEFAULT (datetime('now')),\n            execution_time_ms INTEGER,\n            record_count INTEGER,\n            checksum TEXT,\n            UNIQUE(name, version)\n          )\n        `;\n\n    await this.driver.execute(sql);\n  }\n\n  async hasRun(name: string, version: number): Promise<boolean> {\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `SELECT 1 FROM \"${this.tableName}\" WHERE name = $1 AND version = $2`\n        : `SELECT 1 FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE name = ? AND version = ?`;\n\n    const params = [name, version];\n    const result = await this.driver.query(sql, params);\n    return result.rows.length > 0;\n  }\n\n  async record(name: string, version: number, result: SeedResult, duration: number): Promise<void> {\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `\n        INSERT INTO \"${this.tableName}\" (name, version, execution_time_ms, record_count)\n        VALUES ($1, $2, $3, $4)\n        ON CONFLICT (name, version) DO UPDATE SET\n          execution_time_ms = EXCLUDED.execution_time_ms,\n          record_count = EXCLUDED.record_count,\n          executed_at = NOW()\n      `\n        : this.dialect.name === 'mysql'\n          ? `\n          INSERT INTO \\`${this.tableName}\\` (name, version, execution_time_ms, record_count)\n          VALUES (?, ?, ?, ?)\n          ON DUPLICATE KEY UPDATE\n            execution_time_ms = VALUES(execution_time_ms),\n            record_count = VALUES(record_count),\n            executed_at = CURRENT_TIMESTAMP\n        `\n          : `\n          INSERT OR REPLACE INTO \"${this.tableName}\" (name, version, execution_time_ms, record_count)\n          VALUES (?, ?, ?, ?)\n        `;\n\n    const params = [name, version, duration, result.count];\n    await this.driver.execute(sql, params);\n  }\n\n  async remove(name: string): Promise<void> {\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `DELETE FROM \"${this.tableName}\" WHERE name = $1`\n        : `DELETE FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} WHERE name = ?`;\n\n    await this.driver.execute(sql, [name]);\n  }\n\n  async clear(): Promise<void> {\n    const sql =\n      this.dialect.name === 'mysql'\n        ? `TRUNCATE TABLE \\`${this.tableName}\\``\n        : `DELETE FROM \"${this.tableName}\"`;\n\n    await this.driver.execute(sql);\n  }\n\n  async list(): Promise<SeedRecord[]> {\n    const sql =\n      this.dialect.name === 'postgresql'\n        ? `SELECT * FROM \"${this.tableName}\" ORDER BY executed_at DESC`\n        : `SELECT * FROM ${this.dialect.name === 'mysql' ? `\\`${this.tableName}\\`` : `\"${this.tableName}\"`} ORDER BY executed_at DESC`;\n\n    const result = await this.driver.query<SeedRecord>(sql);\n    return result.rows;\n  }\n}\n","import type { Driver } from '../driver/types.js';\nimport type {\n  ColumnDiff,\n  Conflict,\n  ConstraintDiff,\n  IndexDiff,\n  SchemaColumnInfo,\n  SchemaConstraintInfo,\n  SchemaDiff,\n  SchemaIndexInfo,\n  SchemaInfo,\n  SchemaTableInfo,\n  TableDiff,\n} from './types.js';\n\nexport class SchemaDiffer {\n  constructor(private driver: Driver) {}\n\n  async diff(sourceSchema: string, targetSchema: string): Promise<SchemaDiff> {\n    const [sourceInfo, targetInfo] = await Promise.all([\n      this.getSchemaInfo(sourceSchema),\n      this.getSchemaInfo(targetSchema),\n    ]);\n\n    const tables = this.diffTables(sourceInfo, targetInfo);\n    const columns = this.diffColumns(sourceInfo, targetInfo);\n    const indexes = this.diffIndexes(sourceInfo, targetInfo);\n    const constraints = this.diffConstraints(sourceInfo, targetInfo);\n    const conflicts = this.detectConflicts(columns, constraints);\n\n    const hasChanges =\n      tables.length > 0 || columns.length > 0 || indexes.length > 0 || constraints.length > 0;\n\n    return {\n      source: sourceSchema,\n      target: targetSchema,\n      generatedAt: new Date(),\n      hasChanges,\n      canAutoMerge: conflicts.length === 0,\n      tables,\n      columns,\n      indexes,\n      constraints,\n      conflicts,\n      forwardSql: this.generateMigrationSql(\n        sourceSchema,\n        targetSchema,\n        tables,\n        columns,\n        indexes,\n        constraints,\n        'forward'\n      ),\n      reverseSql: this.generateMigrationSql(\n        targetSchema,\n        sourceSchema,\n        tables,\n        columns,\n        indexes,\n        constraints,\n        'reverse'\n      ),\n    };\n  }\n\n  private async getSchemaInfo(schemaName: string): Promise<SchemaInfo> {\n    const [tables, columns, indexes, constraints] = await Promise.all([\n      this.driver.query<SchemaTableInfo>(\n        `\n        SELECT table_name, table_type\n        FROM information_schema.tables\n        WHERE table_schema = $1 AND table_name NOT LIKE 'lp_%'\n        ORDER BY table_name\n      `,\n        [schemaName]\n      ),\n\n      this.driver.query<SchemaColumnInfo>(\n        `\n        SELECT\n          table_name, column_name, data_type,\n          character_maximum_length, numeric_precision, numeric_scale,\n          is_nullable, column_default, udt_name, ordinal_position\n        FROM information_schema.columns\n        WHERE table_schema = $1 AND table_name NOT LIKE 'lp_%'\n        ORDER BY table_name, ordinal_position\n      `,\n        [schemaName]\n      ),\n\n      this.driver.query<SchemaIndexInfo>(\n        `\n        SELECT\n          schemaname, tablename, indexname, indexdef\n        FROM pg_indexes\n        WHERE schemaname = $1 AND tablename NOT LIKE 'lp_%'\n        ORDER BY tablename, indexname\n      `,\n        [schemaName]\n      ),\n\n      this.driver.query<SchemaConstraintInfo>(\n        `\n        SELECT\n          tc.table_name, tc.constraint_name, tc.constraint_type,\n          kcu.column_name, ccu.table_name AS foreign_table_name,\n          ccu.column_name AS foreign_column_name\n        FROM information_schema.table_constraints tc\n        LEFT JOIN information_schema.key_column_usage kcu\n          ON tc.constraint_name = kcu.constraint_name\n          AND tc.table_schema = kcu.table_schema\n        LEFT JOIN information_schema.constraint_column_usage ccu\n          ON tc.constraint_name = ccu.constraint_name\n          AND tc.table_schema = ccu.table_schema\n        WHERE tc.table_schema = $1 AND tc.table_name NOT LIKE 'lp_%'\n        ORDER BY tc.table_name, tc.constraint_name\n      `,\n        [schemaName]\n      ),\n    ]);\n\n    return {\n      tables: tables.rows,\n      columns: columns.rows,\n      indexes: indexes.rows,\n      constraints: constraints.rows,\n    };\n  }\n\n  private diffTables(source: SchemaInfo, target: SchemaInfo): TableDiff[] {\n    const diffs: TableDiff[] = [];\n    const sourceNames = new Set(source.tables.map((t) => t.table_name));\n    const targetNames = new Set(target.tables.map((t) => t.table_name));\n\n    for (const table of source.tables) {\n      if (!targetNames.has(table.table_name)) {\n        diffs.push({\n          name: table.table_name,\n          action: 'added',\n          sourceDefinition: this.getTableDefinition(table.table_name, source),\n        });\n      }\n    }\n\n    for (const table of target.tables) {\n      if (!sourceNames.has(table.table_name)) {\n        diffs.push({\n          name: table.table_name,\n          action: 'removed',\n          targetDefinition: this.getTableDefinition(table.table_name, target),\n        });\n      }\n    }\n\n    return diffs;\n  }\n\n  private diffColumns(source: SchemaInfo, target: SchemaInfo): ColumnDiff[] {\n    const diffs: ColumnDiff[] = [];\n    const sourceTableNames = new Set(source.tables.map((t) => t.table_name));\n    const targetTableNames = new Set(target.tables.map((t) => t.table_name));\n    const commonTables = [...sourceTableNames].filter((t) => targetTableNames.has(t));\n\n    for (const tableName of commonTables) {\n      const sourceCols = source.columns.filter((c) => c.table_name === tableName);\n      const targetCols = target.columns.filter((c) => c.table_name === tableName);\n      const sourceColMap = new Map(sourceCols.map((c) => [c.column_name, c]));\n      const targetColMap = new Map(targetCols.map((c) => [c.column_name, c]));\n\n      diffs.push(...this.findAddedColumns(tableName, sourceCols, targetColMap));\n      diffs.push(...this.findRemovedColumns(tableName, targetCols, sourceColMap));\n      diffs.push(...this.findModifiedColumns(tableName, sourceCols, targetColMap));\n    }\n\n    return diffs;\n  }\n\n  private findAddedColumns(\n    tableName: string,\n    sourceCols: SchemaColumnInfo[],\n    targetColMap: Map<string, SchemaColumnInfo>\n  ): ColumnDiff[] {\n    return sourceCols\n      .filter((col) => !targetColMap.has(col.column_name))\n      .map((col) => ({\n        tableName,\n        columnName: col.column_name,\n        action: 'added' as const,\n        sourceType: this.getColumnType(col),\n        sourceNullable: col.is_nullable === 'YES',\n        sourceDefault: col.column_default ?? undefined,\n        isBreaking: false,\n      }));\n  }\n\n  private findRemovedColumns(\n    tableName: string,\n    targetCols: SchemaColumnInfo[],\n    sourceColMap: Map<string, SchemaColumnInfo>\n  ): ColumnDiff[] {\n    return targetCols\n      .filter((col) => !sourceColMap.has(col.column_name))\n      .map((col) => ({\n        tableName,\n        columnName: col.column_name,\n        action: 'removed' as const,\n        targetType: this.getColumnType(col),\n        targetNullable: col.is_nullable === 'YES',\n        targetDefault: col.column_default ?? undefined,\n        isBreaking: true,\n      }));\n  }\n\n  private findModifiedColumns(\n    tableName: string,\n    sourceCols: SchemaColumnInfo[],\n    targetColMap: Map<string, SchemaColumnInfo>\n  ): ColumnDiff[] {\n    const diffs: ColumnDiff[] = [];\n    for (const col of sourceCols) {\n      const targetCol = targetColMap.get(col.column_name);\n      if (targetCol && this.hasColumnChanges(col, targetCol)) {\n        const sourceType = this.getColumnType(col);\n        const targetType = this.getColumnType(targetCol);\n        diffs.push({\n          tableName,\n          columnName: col.column_name,\n          action: 'modified',\n          sourceType,\n          targetType,\n          sourceNullable: col.is_nullable === 'YES',\n          targetNullable: targetCol.is_nullable === 'YES',\n          sourceDefault: col.column_default ?? undefined,\n          targetDefault: targetCol.column_default ?? undefined,\n          isBreaking: this.isBreakingTypeChange(sourceType, targetType),\n        });\n      }\n    }\n    return diffs;\n  }\n\n  private diffIndexes(source: SchemaInfo, target: SchemaInfo): IndexDiff[] {\n    const diffs: IndexDiff[] = [];\n\n    const sourceMap = new Map(source.indexes.map((i) => [`${i.tablename}.${i.indexname}`, i]));\n    const targetMap = new Map(target.indexes.map((i) => [`${i.tablename}.${i.indexname}`, i]));\n\n    for (const [key, idx] of sourceMap) {\n      if (!targetMap.has(key)) {\n        diffs.push({\n          tableName: idx.tablename,\n          indexName: idx.indexname,\n          action: 'added',\n          sourceDefinition: idx.indexdef,\n        });\n      }\n    }\n\n    for (const [key, idx] of targetMap) {\n      if (!sourceMap.has(key)) {\n        diffs.push({\n          tableName: idx.tablename,\n          indexName: idx.indexname,\n          action: 'removed',\n          targetDefinition: idx.indexdef,\n        });\n      }\n    }\n\n    for (const [key, sourceIdx] of sourceMap) {\n      const targetIdx = targetMap.get(key);\n      if (targetIdx) {\n        const normalizedSource = this.normalizeIndexDef(sourceIdx.indexdef);\n        const normalizedTarget = this.normalizeIndexDef(targetIdx.indexdef);\n\n        if (normalizedSource !== normalizedTarget) {\n          diffs.push({\n            tableName: sourceIdx.tablename,\n            indexName: sourceIdx.indexname,\n            action: 'modified',\n            sourceDefinition: sourceIdx.indexdef,\n            targetDefinition: targetIdx.indexdef,\n          });\n        }\n      }\n    }\n\n    return diffs;\n  }\n\n  private diffConstraints(source: SchemaInfo, target: SchemaInfo): ConstraintDiff[] {\n    const diffs: ConstraintDiff[] = [];\n\n    const sourceMap = new Map(\n      source.constraints.map((c) => [`${c.table_name}.${c.constraint_name}`, c])\n    );\n    const targetMap = new Map(\n      target.constraints.map((c) => [`${c.table_name}.${c.constraint_name}`, c])\n    );\n\n    for (const [key, con] of sourceMap) {\n      if (!targetMap.has(key) && !this.isAutoGeneratedConstraint(con.constraint_name)) {\n        diffs.push({\n          tableName: con.table_name,\n          constraintName: con.constraint_name,\n          constraintType: this.mapConstraintType(con.constraint_type),\n          action: 'added',\n          isBreaking: false,\n          sourceDefinition: this.getConstraintDefinition(con),\n        });\n      }\n    }\n\n    for (const [key, con] of targetMap) {\n      if (!sourceMap.has(key) && !this.isAutoGeneratedConstraint(con.constraint_name)) {\n        diffs.push({\n          tableName: con.table_name,\n          constraintName: con.constraint_name,\n          constraintType: this.mapConstraintType(con.constraint_type),\n          action: 'removed',\n          isBreaking: con.constraint_type !== 'CHECK',\n          targetDefinition: this.getConstraintDefinition(con),\n        });\n      }\n    }\n\n    return diffs;\n  }\n\n  private detectConflicts(columns: ColumnDiff[], constraints: ConstraintDiff[]): Conflict[] {\n    const conflicts: Conflict[] = [];\n\n    for (const col of columns.filter((c) => c.action === 'modified')) {\n      if (col.sourceType !== col.targetType) {\n        conflicts.push({\n          type: 'column_type_mismatch',\n          description: `Column ${col.tableName}.${col.columnName} has different types: ${col.sourceType} vs ${col.targetType}`,\n          sourcePath: `${col.tableName}.${col.columnName}`,\n          targetPath: `${col.tableName}.${col.columnName}`,\n          resolution: ['keep_source', 'keep_target', 'manual'],\n        });\n      }\n    }\n\n    for (const con of constraints.filter(\n      (c) => c.action === 'removed' && c.constraintType === 'foreign_key'\n    )) {\n      conflicts.push({\n        type: 'constraint_conflict',\n        description: `Foreign key ${con.constraintName} on ${con.tableName} would be removed`,\n        sourcePath: `${con.tableName}.${con.constraintName}`,\n        targetPath: `${con.tableName}.${con.constraintName}`,\n        resolution: ['keep_source', 'keep_target', 'manual'],\n      });\n    }\n\n    return conflicts;\n  }\n\n  private generateMigrationSql(\n    sourceSchema: string,\n    targetSchema: string,\n    tables: TableDiff[],\n    columns: ColumnDiff[],\n    indexes: IndexDiff[],\n    constraints: ConstraintDiff[],\n    direction: 'forward' | 'reverse'\n  ): string[] {\n    const schema = direction === 'forward' ? targetSchema : sourceSchema;\n    const ctx = { sourceSchema, targetSchema, schema, direction };\n\n    return [\n      ...this.generateTableSql(tables, ctx),\n      ...this.generateColumnSql(columns, ctx),\n      ...this.generateIndexSql(indexes, ctx),\n      ...this.generateConstraintSql(constraints, ctx),\n    ];\n  }\n\n  private generateTableSql(\n    tables: TableDiff[],\n    ctx: { sourceSchema: string; schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    const sql: string[] = [];\n    for (const table of tables) {\n      const isCreate =\n        (ctx.direction === 'forward' && table.action === 'added') ||\n        (ctx.direction === 'reverse' && table.action === 'removed');\n      const isDrop =\n        (ctx.direction === 'forward' && table.action === 'removed') ||\n        (ctx.direction === 'reverse' && table.action === 'added');\n\n      if (isCreate && table.sourceDefinition) {\n        sql.push(table.sourceDefinition.replace(ctx.sourceSchema, ctx.schema));\n      } else if (isDrop) {\n        sql.push(`DROP TABLE IF EXISTS \"${ctx.schema}\".\"${table.name}\" CASCADE`);\n      }\n    }\n    return sql;\n  }\n\n  private shouldCreate(action: string, direction: 'forward' | 'reverse'): boolean {\n    return (\n      (direction === 'forward' && action === 'added') ||\n      (direction === 'reverse' && action === 'removed')\n    );\n  }\n\n  private shouldDrop(action: string, direction: 'forward' | 'reverse'): boolean {\n    return (\n      (direction === 'forward' && action === 'removed') ||\n      (direction === 'reverse' && action === 'added')\n    );\n  }\n\n  private generateColumnSql(\n    columns: ColumnDiff[],\n    ctx: { schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    return columns.flatMap((col) => this.generateSingleColumnSql(col, ctx));\n  }\n\n  private generateSingleColumnSql(\n    col: ColumnDiff,\n    ctx: { schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    const tableName = `\"${ctx.schema}\".\"${col.tableName}\"`;\n    if (this.shouldCreate(col.action, ctx.direction)) {\n      const type = ctx.direction === 'forward' ? col.sourceType : col.targetType;\n      return [`ALTER TABLE ${tableName} ADD COLUMN \"${col.columnName}\" ${type}`];\n    }\n    if (this.shouldDrop(col.action, ctx.direction)) {\n      return [`ALTER TABLE ${tableName} DROP COLUMN IF EXISTS \"${col.columnName}\"`];\n    }\n    if (col.action === 'modified') {\n      const type = ctx.direction === 'forward' ? col.sourceType : col.targetType;\n      return [`ALTER TABLE ${tableName} ALTER COLUMN \"${col.columnName}\" TYPE ${type}`];\n    }\n    return [];\n  }\n\n  private generateIndexSql(\n    indexes: IndexDiff[],\n    ctx: {\n      sourceSchema: string;\n      targetSchema: string;\n      schema: string;\n      direction: 'forward' | 'reverse';\n    }\n  ): string[] {\n    return indexes.flatMap((idx) => this.generateSingleIndexSql(idx, ctx));\n  }\n\n  private generateSingleIndexSql(\n    idx: IndexDiff,\n    ctx: {\n      sourceSchema: string;\n      targetSchema: string;\n      schema: string;\n      direction: 'forward' | 'reverse';\n    }\n  ): string[] {\n    if (this.shouldCreate(idx.action, ctx.direction)) {\n      const def = ctx.direction === 'forward' ? idx.sourceDefinition : idx.targetDefinition;\n      if (def) {\n        return [def.replace(ctx.sourceSchema, ctx.schema).replace(ctx.targetSchema, ctx.schema)];\n      }\n    }\n    if (this.shouldDrop(idx.action, ctx.direction)) {\n      return [`DROP INDEX IF EXISTS \"${ctx.schema}\".\"${idx.indexName}\"`];\n    }\n    return [];\n  }\n\n  private generateConstraintSql(\n    constraints: ConstraintDiff[],\n    ctx: { schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    return constraints.flatMap((con) => this.generateSingleConstraintSql(con, ctx));\n  }\n\n  private generateSingleConstraintSql(\n    con: ConstraintDiff,\n    ctx: { schema: string; direction: 'forward' | 'reverse' }\n  ): string[] {\n    const tableName = `\"${ctx.schema}\".\"${con.tableName}\"`;\n    if (this.shouldCreate(con.action, ctx.direction)) {\n      const def = ctx.direction === 'forward' ? con.sourceDefinition : con.targetDefinition;\n      if (def) {\n        return [`ALTER TABLE ${tableName} ADD ${def}`];\n      }\n    }\n    if (this.shouldDrop(con.action, ctx.direction)) {\n      return [`ALTER TABLE ${tableName} DROP CONSTRAINT IF EXISTS \"${con.constraintName}\"`];\n    }\n    return [];\n  }\n\n  private getTableDefinition(tableName: string, schema: SchemaInfo): string {\n    const columns = schema.columns.filter((c) => c.table_name === tableName);\n    const colDefs = columns.map((c) => {\n      let def = `\"${c.column_name}\" ${this.getColumnType(c)}`;\n      if (c.is_nullable === 'NO') {\n        def += ' NOT NULL';\n      }\n      if (c.column_default) {\n        def += ` DEFAULT ${c.column_default}`;\n      }\n      return def;\n    });\n\n    return `CREATE TABLE \"${tableName}\" (\\n  ${colDefs.join(',\\n  ')}\\n)`;\n  }\n\n  private getColumnType(col: SchemaColumnInfo): string {\n    let type = col.data_type;\n\n    if (col.character_maximum_length) {\n      type = `${col.udt_name}(${col.character_maximum_length})`;\n    } else if (col.numeric_precision && col.numeric_scale !== null) {\n      type = `${col.udt_name}(${col.numeric_precision},${col.numeric_scale})`;\n    } else if (col.udt_name && col.udt_name !== col.data_type) {\n      type = col.udt_name;\n    }\n\n    return type.toUpperCase();\n  }\n\n  private hasColumnChanges(source: SchemaColumnInfo, target: SchemaColumnInfo): boolean {\n    return (\n      this.getColumnType(source) !== this.getColumnType(target) ||\n      source.is_nullable !== target.is_nullable ||\n      this.normalizeDefault(source.column_default) !== this.normalizeDefault(target.column_default)\n    );\n  }\n\n  private normalizeDefault(value: string | null): string | null {\n    if (!value) return value;\n    return value.replace(/nextval\\('[^']+\\./g, \"nextval('\");\n  }\n\n  private isBreakingTypeChange(sourceType: string, targetType: string): boolean {\n    const breakingChanges = [\n      { from: 'TEXT', to: 'VARCHAR' },\n      { from: 'VARCHAR', to: 'INTEGER' },\n      { from: 'INTEGER', to: 'SMALLINT' },\n      { from: 'BIGINT', to: 'INTEGER' },\n      { from: 'TIMESTAMP', to: 'DATE' },\n    ];\n\n    const source = sourceType.toUpperCase();\n    const target = targetType.toUpperCase();\n\n    return breakingChanges.some(\n      (change) => source.includes(change.from) && target.includes(change.to)\n    );\n  }\n\n  private isAutoGeneratedConstraint(name: string): boolean {\n    // PostgreSQL auto-generates NOT NULL constraint names with OID patterns like \"17095_17098_1_not_null\"\n    return /^\\d+_\\d+_\\d+_not_null$/.test(name);\n  }\n\n  private normalizeIndexDef(indexdef: string): string {\n    return indexdef\n      .replace(/\\s+/g, ' ')\n      .replace(/\\s*,\\s*/g, ', ')\n      .replace(/\\bON\\s+\\S+\\./gi, 'ON ') // Remove schema prefix from table name\n      .toLowerCase()\n      .trim();\n  }\n\n  private mapConstraintType(type: string): 'primary_key' | 'foreign_key' | 'unique' | 'check' {\n    switch (type) {\n      case 'PRIMARY KEY':\n        return 'primary_key';\n      case 'FOREIGN KEY':\n        return 'foreign_key';\n      case 'UNIQUE':\n        return 'unique';\n      case 'CHECK':\n        return 'check';\n      default:\n        return 'check';\n    }\n  }\n\n  private getConstraintDefinition(con: SchemaConstraintInfo): string {\n    if (\n      con.constraint_type === 'FOREIGN KEY' &&\n      con.foreign_table_name &&\n      con.foreign_column_name\n    ) {\n      return `CONSTRAINT \"${con.constraint_name}\" FOREIGN KEY (\"${con.column_name}\") REFERENCES \"${con.foreign_table_name}\"(\"${con.foreign_column_name}\")`;\n    }\n    if (con.constraint_type === 'PRIMARY KEY') {\n      return `CONSTRAINT \"${con.constraint_name}\" PRIMARY KEY (\"${con.column_name}\")`;\n    }\n    if (con.constraint_type === 'UNIQUE') {\n      return `CONSTRAINT \"${con.constraint_name}\" UNIQUE (\"${con.column_name}\")`;\n    }\n    return `CONSTRAINT \"${con.constraint_name}\"`;\n  }\n}\n","import type { Driver } from '../driver/types.js';\nimport { SchemaDiffer } from './schema-differ.js';\nimport type { Conflict, ConflictResolution, MergeOptions, MergeResult } from './types.js';\n\nexport interface MigrationRecord {\n  version: number;\n  name: string;\n  scope: 'core' | 'template';\n  checksum: string;\n  upSql: string[];\n  downSql: string[];\n  appliedAt: Date;\n}\n\nexport interface MigrationMergerOptions {\n  mainSchema?: string;\n  branchPrefix?: string;\n  migrationsTable?: string;\n}\n\nexport class MigrationMerger {\n  private driver: Driver;\n  private mainSchema: string;\n  private migrationsTable: string;\n\n  constructor(driver: Driver, options: MigrationMergerOptions = {}) {\n    this.driver = driver;\n    this.mainSchema = options.mainSchema ?? 'public';\n    this.migrationsTable = options.migrationsTable ?? 'lp_migrations';\n  }\n\n  async merge(options: MergeOptions): Promise<MergeResult> {\n    const { sourceBranch, targetBranch, dryRun, conflictResolution } = options;\n\n    const sourceSchema = await this.resolveSchemaName(sourceBranch);\n    const targetSchema = await this.resolveSchemaName(targetBranch);\n\n    const differ = new SchemaDiffer(this.driver);\n    const diff = await differ.diff(sourceSchema, targetSchema);\n\n    if (!diff.hasChanges) {\n      return {\n        success: true,\n        migrationsApplied: 0,\n        conflicts: [],\n        errors: [],\n        rollbackAvailable: false,\n      };\n    }\n\n    if (\n      diff.conflicts.length > 0 &&\n      !this.allConflictsResolved(diff.conflicts, conflictResolution)\n    ) {\n      return {\n        success: false,\n        migrationsApplied: 0,\n        conflicts: diff.conflicts,\n        errors: ['Unresolved conflicts detected. Provide conflict resolutions.'],\n        rollbackAvailable: false,\n      };\n    }\n\n    if (dryRun) {\n      return {\n        success: true,\n        migrationsApplied: diff.forwardSql.length,\n        conflicts: [],\n        errors: [],\n        rollbackAvailable: false,\n      };\n    }\n\n    try {\n      await this.driver.transaction(async (trx) => {\n        for (const sql of diff.forwardSql) {\n          const adjustedSql = sql.replace(\n            new RegExp(`\"${sourceSchema}\"`, 'g'),\n            `\"${targetSchema}\"`\n          );\n          await trx.execute(adjustedSql);\n        }\n\n        await trx.execute(\n          `\n          INSERT INTO ${this.quoteIdent(this.migrationsTable)} (\n            version, name, scope, checksum, up_sql, down_sql\n          ) VALUES (\n            EXTRACT(EPOCH FROM NOW())::BIGINT * 1000 + (random() * 1000)::INT,\n            $1,\n            'core',\n            $2,\n            $3,\n            $4\n          )\n        `,\n          [\n            `merge_${sourceBranch}_to_${targetBranch}`,\n            this.computeChecksum(diff.forwardSql),\n            diff.forwardSql,\n            diff.reverseSql,\n          ]\n        );\n      });\n\n      return {\n        success: true,\n        migrationsApplied: diff.forwardSql.length,\n        conflicts: [],\n        errors: [],\n        rollbackAvailable: true,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        migrationsApplied: 0,\n        conflicts: [],\n        errors: [error instanceof Error ? error.message : String(error)],\n        rollbackAvailable: false,\n      };\n    }\n  }\n\n  async getPendingMigrations(\n    _sourceBranch: string,\n    _targetBranch: string\n  ): Promise<MigrationRecord[]> {\n    const result = await this.driver.query<{\n      version: string | number;\n      name: string;\n      scope: 'core' | 'template';\n      checksum: string;\n      up_sql: string[] | string;\n      down_sql: string[] | string | null;\n      applied_at: Date | string;\n    }>(`\n      SELECT s.version, s.name, s.scope, s.checksum, s.up_sql, s.down_sql, s.applied_at\n      FROM ${this.quoteIdent(this.migrationsTable)} s\n      WHERE NOT EXISTS (\n        SELECT 1 FROM ${this.quoteIdent(this.migrationsTable)} t\n        WHERE t.version = s.version\n      )\n      ORDER BY s.version ASC\n    `);\n\n    return result.rows.map((row) => ({\n      version: typeof row.version === 'string' ? Number.parseInt(row.version, 10) : row.version,\n      name: row.name,\n      scope: row.scope,\n      checksum: row.checksum,\n      upSql: typeof row.up_sql === 'string' ? JSON.parse(row.up_sql) : row.up_sql,\n      downSql: row.down_sql\n        ? typeof row.down_sql === 'string'\n          ? JSON.parse(row.down_sql)\n          : row.down_sql\n        : [],\n      appliedAt: new Date(row.applied_at),\n    }));\n  }\n\n  async detectMigrationConflicts(\n    migrations: MigrationRecord[],\n    targetBranch: string\n  ): Promise<Conflict[]> {\n    const conflicts: Conflict[] = [];\n    const targetSchema = await this.resolveSchemaName(targetBranch);\n\n    const tableNames = new Set<string>();\n    for (const migration of migrations) {\n      for (const sql of migration.upSql) {\n        const createMatch = sql.match(/CREATE TABLE\\s+(?:\"[^\"]+\"\\.)?\"([^\"]+)\"/i);\n        const alterMatch = sql.match(/ALTER TABLE\\s+(?:\"[^\"]+\"\\.)?\"([^\"]+)\"/i);\n\n        const tableName = createMatch?.[1] || alterMatch?.[1];\n        if (tableName) {\n          tableNames.add(tableName);\n        }\n      }\n    }\n\n    for (const tableName of tableNames) {\n      const exists = await this.tableExists(targetSchema, tableName);\n\n      if (exists) {\n        const willBeCreated = migrations.some((m) =>\n          m.upSql.some((sql) =>\n            sql.match(new RegExp(`CREATE TABLE\\\\s+(?:\"[^\"]+\"\\\\.)?[\"']?${tableName}[\"']?`, 'i'))\n          )\n        );\n\n        if (willBeCreated) {\n          conflicts.push({\n            type: 'table_removed',\n            description: `Table ${tableName} already exists in target branch but will be created by migration`,\n            sourcePath: tableName,\n            targetPath: tableName,\n            resolution: ['keep_source', 'keep_target', 'manual'],\n          });\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  private allConflictsResolved(\n    conflicts: Conflict[],\n    resolution?: Record<string, ConflictResolution>\n  ): boolean {\n    if (!resolution) {\n      return conflicts.length === 0;\n    }\n\n    for (const conflict of conflicts) {\n      const key = conflict.sourcePath;\n      if (!resolution[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private async resolveSchemaName(branchName: string): Promise<string> {\n    if (branchName === 'main' || branchName === 'public') {\n      return this.mainSchema;\n    }\n\n    const result = await this.driver.query<{ schema_name: string }>(\n      `\n      SELECT schema_name FROM lp_branch_metadata\n      WHERE slug = $1 AND deleted_at IS NULL\n    `,\n      [branchName]\n    );\n\n    if (result.rows.length === 0) {\n      throw new Error(`Branch '${branchName}' not found`);\n    }\n\n    return result.rows[0].schema_name;\n  }\n\n  private async tableExists(schema: string, tableName: string): Promise<boolean> {\n    const result = await this.driver.query<{ exists: boolean }>(\n      `\n      SELECT EXISTS (\n        SELECT 1 FROM information_schema.tables\n        WHERE table_schema = $1 AND table_name = $2\n      ) as exists\n    `,\n      [schema, tableName]\n    );\n\n    return result.rows[0]?.exists ?? false;\n  }\n\n  private computeChecksum(statements: string[]): string {\n    const { createHash } = require('node:crypto');\n    return createHash('sha256').update(statements.join('\\n')).digest('hex');\n  }\n\n  private quoteIdent(identifier: string): string {\n    return `\"${identifier.replace(/\"/g, '\"\"')}\"`;\n  }\n}\n","import type { Driver, TransactionClient } from '../driver/types.js';\nimport { MigrationMerger } from './migration-merger.js';\nimport { SchemaDiffer } from './schema-differ.js';\nimport type {\n  Branch,\n  BranchRow,\n  BranchStatus,\n  CleanupOptions,\n  CleanupResult,\n  CreateBranchOptions,\n  ListBranchesFilter,\n  MergeOptions,\n  MergeResult,\n  SchemaDiff,\n  SwitchBranchResult,\n} from './types.js';\n\nexport interface BranchManagerOptions {\n  driver: Driver;\n  mainSchemaName?: string;\n  branchPrefix?: string;\n  defaultAutoDeleteDays?: number;\n  metadataTableName?: string;\n}\n\nexport class BranchManager {\n  private driver: Driver;\n  private mainSchema: string;\n  private branchPrefix: string;\n  private defaultAutoDeleteDays: number;\n  private metadataTable: string;\n\n  constructor(options: BranchManagerOptions) {\n    this.driver = options.driver;\n    this.mainSchema = options.mainSchemaName ?? 'public';\n    this.branchPrefix = options.branchPrefix ?? 'branch_';\n    this.defaultAutoDeleteDays = options.defaultAutoDeleteDays ?? 7;\n    this.metadataTable = options.metadataTableName ?? 'lp_branch_metadata';\n  }\n\n  async ensureMetadataTable(): Promise<void> {\n    await this.driver.execute(`\n      CREATE TABLE IF NOT EXISTS ${this.quoteIdent(this.metadataTable)} (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        name VARCHAR(128) NOT NULL,\n        slug VARCHAR(128) NOT NULL UNIQUE,\n        schema_name VARCHAR(128) NOT NULL UNIQUE,\n        parent_branch_id UUID REFERENCES ${this.quoteIdent(this.metadataTable)}(id),\n\n        git_branch VARCHAR(256),\n        pr_number INTEGER,\n        pr_url TEXT,\n\n        status VARCHAR(20) NOT NULL DEFAULT 'active'\n          CHECK (status IN ('active', 'protected', 'stale', 'deleting')),\n        is_protected BOOLEAN NOT NULL DEFAULT FALSE,\n        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n        created_by VARCHAR(256),\n        last_accessed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n        deleted_at TIMESTAMPTZ,\n\n        migration_count INTEGER DEFAULT 0,\n        table_count INTEGER DEFAULT 0,\n        storage_bytes BIGINT DEFAULT 0,\n\n        auto_delete_days INTEGER DEFAULT 7,\n        copy_data BOOLEAN DEFAULT FALSE,\n        pii_masking BOOLEAN DEFAULT TRUE\n      )\n    `);\n\n    await this.driver.execute(`\n      CREATE INDEX IF NOT EXISTS idx_${this.metadataTable}_status\n      ON ${this.quoteIdent(this.metadataTable)}(status)\n    `);\n\n    await this.driver.execute(`\n      CREATE INDEX IF NOT EXISTS idx_${this.metadataTable}_parent\n      ON ${this.quoteIdent(this.metadataTable)}(parent_branch_id)\n    `);\n\n    await this.driver.execute(`\n      CREATE INDEX IF NOT EXISTS idx_${this.metadataTable}_pr\n      ON ${this.quoteIdent(this.metadataTable)}(pr_number)\n    `);\n\n    await this.driver.execute(`\n      CREATE INDEX IF NOT EXISTS idx_${this.metadataTable}_accessed\n      ON ${this.quoteIdent(this.metadataTable)}(last_accessed_at)\n    `);\n  }\n\n  async createBranch(options: CreateBranchOptions): Promise<Branch> {\n    await this.ensureMetadataTable();\n\n    const slug = this.generateSlug(options.name);\n    const schemaName = `${this.branchPrefix}${slug}`;\n\n    const existing = await this.getBranchBySlug(slug);\n    if (existing) {\n      throw new Error(`Branch '${slug}' already exists`);\n    }\n\n    const parentBranch = options.parentBranch\n      ? await this.getBranchBySlug(options.parentBranch)\n      : null;\n\n    const parentSchema = parentBranch?.schemaName ?? this.mainSchema;\n\n    return await this.driver.transaction(async (trx) => {\n      await trx.execute(`CREATE SCHEMA IF NOT EXISTS ${this.quoteIdent(schemaName)}`);\n\n      await this.cloneSchemaStructure(trx, parentSchema, schemaName);\n\n      if (options.copyData) {\n        await this.copyDataWithMasking(trx, parentSchema, schemaName, options.piiMasking ?? true);\n      }\n\n      const tableCount = await this.getTableCount(trx, schemaName);\n\n      const result = await trx.query<BranchRow>(\n        `\n        INSERT INTO ${this.quoteIdent(this.metadataTable)} (\n          name, slug, schema_name, parent_branch_id,\n          git_branch, pr_number, pr_url,\n          auto_delete_days, copy_data, pii_masking, created_by, table_count\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\n        RETURNING *\n      `,\n        [\n          options.name,\n          slug,\n          schemaName,\n          parentBranch?.id ?? null,\n          options.gitBranch ?? null,\n          options.prNumber ?? null,\n          options.prUrl ?? null,\n          options.autoDeleteDays ?? this.defaultAutoDeleteDays,\n          options.copyData ?? false,\n          options.piiMasking ?? true,\n          options.createdBy ?? null,\n          tableCount,\n        ]\n      );\n\n      return this.mapBranchRow(result.rows[0]);\n    });\n  }\n\n  async getBranchBySlug(slug: string): Promise<Branch | null> {\n    const result = await this.driver.query<BranchRow>(\n      `\n      SELECT * FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE slug = $1 AND deleted_at IS NULL\n    `,\n      [slug]\n    );\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    return this.mapBranchRow(result.rows[0]);\n  }\n\n  async getBranchById(id: string): Promise<Branch | null> {\n    const result = await this.driver.query<BranchRow>(\n      `\n      SELECT * FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE id = $1 AND deleted_at IS NULL\n    `,\n      [id]\n    );\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    return this.mapBranchRow(result.rows[0]);\n  }\n\n  async deleteBranch(branchSlug: string, force = false): Promise<void> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    if (branch.isProtected && !force) {\n      throw new Error(`Branch '${branchSlug}' is protected. Use force=true to delete.`);\n    }\n\n    await this.driver.transaction(async (trx) => {\n      await trx.execute(\n        `\n        UPDATE ${this.quoteIdent(this.metadataTable)}\n        SET status = 'deleting', deleted_at = NOW()\n        WHERE id = $1\n      `,\n        [branch.id]\n      );\n\n      await trx.execute(`DROP SCHEMA IF EXISTS ${this.quoteIdent(branch.schemaName)} CASCADE`);\n\n      await trx.execute(\n        `\n        DELETE FROM ${this.quoteIdent(this.metadataTable)} WHERE id = $1\n      `,\n        [branch.id]\n      );\n    });\n  }\n\n  async switchBranch(branchSlug: string): Promise<SwitchBranchResult> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    await this.driver.execute(\n      `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET last_accessed_at = NOW()\n      WHERE id = $1\n    `,\n      [branch.id]\n    );\n\n    const searchPath = `${branch.schemaName}, public`;\n\n    return {\n      connectionString: this.generateConnectionString(branch),\n      searchPath,\n      schemaName: branch.schemaName,\n    };\n  }\n\n  async diffBranches(sourceBranch: string, targetBranch: string): Promise<SchemaDiff> {\n    const source = await this.resolveSchemaName(sourceBranch);\n    const target = await this.resolveSchemaName(targetBranch);\n\n    const differ = new SchemaDiffer(this.driver);\n    return differ.diff(source, target);\n  }\n\n  async mergeBranch(options: MergeOptions): Promise<MergeResult> {\n    const merger = new MigrationMerger(this.driver, {\n      mainSchema: this.mainSchema,\n      branchPrefix: this.branchPrefix,\n    });\n\n    const result = await merger.merge(options);\n\n    if (result.success && options.deleteSourceAfterMerge) {\n      await this.deleteBranch(options.sourceBranch, true);\n    }\n\n    return result;\n  }\n\n  async listBranches(filter?: ListBranchesFilter): Promise<Branch[]> {\n    await this.ensureMetadataTable();\n\n    let sql = `SELECT * FROM ${this.quoteIdent(this.metadataTable)} WHERE deleted_at IS NULL`;\n    const params: unknown[] = [];\n    let paramIndex = 1;\n\n    if (filter?.status) {\n      sql += ` AND status = $${paramIndex++}`;\n      params.push(filter.status);\n    }\n\n    if (filter?.parentId) {\n      sql += ` AND parent_branch_id = $${paramIndex++}`;\n      params.push(filter.parentId);\n    }\n\n    if (filter?.staleDays) {\n      sql += ` AND last_accessed_at < NOW() - INTERVAL '${filter.staleDays} days'`;\n    }\n\n    sql += ' ORDER BY created_at DESC';\n\n    const result = await this.driver.query<BranchRow>(sql, params);\n    return result.rows.map((row) => this.mapBranchRow(row));\n  }\n\n  async cleanupStaleBranches(options: CleanupOptions = {}): Promise<CleanupResult> {\n    await this.ensureMetadataTable();\n\n    const maxAge = options.maxAgeDays ?? 7;\n    const skipProtected = options.skipProtected ?? true;\n\n    let sql = `\n      SELECT * FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE deleted_at IS NULL\n        AND last_accessed_at < NOW() - INTERVAL '${maxAge} days'\n        AND status != 'deleting'\n    `;\n\n    if (skipProtected) {\n      sql += ` AND is_protected = FALSE AND status != 'protected'`;\n    }\n\n    const result = await this.driver.query<BranchRow>(sql);\n    const deleted: string[] = [];\n    const skipped: string[] = [];\n\n    for (const row of result.rows) {\n      const branch = this.mapBranchRow(row);\n      if (options.dryRun) {\n        deleted.push(branch.slug);\n      } else {\n        try {\n          await this.deleteBranch(branch.slug, true);\n          deleted.push(branch.slug);\n        } catch (error) {\n          skipped.push(`${branch.slug}: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      }\n    }\n\n    return { deleted, skipped };\n  }\n\n  async protectBranch(branchSlug: string): Promise<void> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    await this.driver.execute(\n      `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET is_protected = TRUE, status = 'protected'\n      WHERE id = $1\n    `,\n      [branch.id]\n    );\n  }\n\n  async unprotectBranch(branchSlug: string): Promise<void> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    await this.driver.execute(\n      `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET is_protected = FALSE, status = 'active'\n      WHERE id = $1\n    `,\n      [branch.id]\n    );\n  }\n\n  async updateBranchStats(branchSlug: string): Promise<void> {\n    const branch = await this.getBranchBySlug(branchSlug);\n    if (!branch) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    const tableCount = await this.getTableCount(this.driver, branch.schemaName);\n\n    const storageResult = await this.driver.query<{ storage_bytes: string }>(\n      `\n      SELECT COALESCE(sum(pg_total_relation_size(quote_ident(schemaname) || '.' || quote_ident(tablename)))::bigint, 0)::text as storage_bytes\n      FROM pg_tables\n      WHERE schemaname = $1\n    `,\n      [branch.schemaName]\n    );\n\n    const storageBytes = Number.parseInt(storageResult.rows[0]?.storage_bytes ?? '0', 10);\n\n    await this.driver.execute(\n      `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET table_count = $1, storage_bytes = $2\n      WHERE id = $3\n    `,\n      [tableCount, storageBytes, branch.id]\n    );\n  }\n\n  private async cloneSchemaStructure(\n    trx: TransactionClient,\n    sourceSchema: string,\n    targetSchema: string\n  ): Promise<void> {\n    const tablesResult = await trx.query<{ tablename: string }>(\n      `\n      SELECT tablename FROM pg_tables\n      WHERE schemaname = $1 AND tablename NOT LIKE 'lp_%'\n    `,\n      [sourceSchema]\n    );\n\n    for (const { tablename } of tablesResult.rows) {\n      await trx.execute(`\n        CREATE TABLE ${this.quoteIdent(targetSchema)}.${this.quoteIdent(tablename)}\n        (LIKE ${this.quoteIdent(sourceSchema)}.${this.quoteIdent(tablename)}\n         INCLUDING ALL)\n      `);\n    }\n\n    await this.cloneSequences(trx, sourceSchema, targetSchema);\n    await this.cloneViews(trx, sourceSchema, targetSchema);\n  }\n\n  private async cloneSequences(\n    trx: TransactionClient,\n    sourceSchema: string,\n    targetSchema: string\n  ): Promise<void> {\n    const sequencesResult = await trx.query<{ sequence_name: string }>(\n      `\n      SELECT sequence_name\n      FROM information_schema.sequences\n      WHERE sequence_schema = $1\n    `,\n      [sourceSchema]\n    );\n\n    for (const { sequence_name } of sequencesResult.rows) {\n      const seqInfo = await trx.query<{\n        start_value: string;\n        increment_by: string;\n        min_value: string;\n        max_value: string;\n        last_value: string | null;\n      }>(\n        `\n        SELECT start_value::text, increment_by::text, min_value::text, max_value::text, last_value::text\n        FROM pg_sequences\n        WHERE schemaname = $1 AND sequencename = $2\n      `,\n        [sourceSchema, sequence_name]\n      );\n\n      if (seqInfo.rows.length > 0) {\n        const seq = seqInfo.rows[0];\n        await trx.execute(`\n          CREATE SEQUENCE IF NOT EXISTS ${this.quoteIdent(targetSchema)}.${this.quoteIdent(sequence_name)}\n          START WITH ${seq.last_value ?? seq.start_value}\n          INCREMENT BY ${seq.increment_by}\n          MINVALUE ${seq.min_value}\n          MAXVALUE ${seq.max_value}\n        `);\n      }\n    }\n  }\n\n  private async cloneViews(\n    trx: TransactionClient,\n    sourceSchema: string,\n    targetSchema: string\n  ): Promise<void> {\n    const viewsResult = await trx.query<{ viewname: string; definition: string }>(\n      `\n      SELECT viewname, definition\n      FROM pg_views\n      WHERE schemaname = $1\n    `,\n      [sourceSchema]\n    );\n\n    for (const { viewname, definition } of viewsResult.rows) {\n      const adjustedDefinition = definition.replace(\n        new RegExp(`${sourceSchema}\\\\.`, 'g'),\n        `${targetSchema}.`\n      );\n\n      await trx.execute(`\n        CREATE OR REPLACE VIEW ${this.quoteIdent(targetSchema)}.${this.quoteIdent(viewname)} AS\n        ${adjustedDefinition}\n      `);\n    }\n  }\n\n  private async copyDataWithMasking(\n    trx: TransactionClient,\n    sourceSchema: string,\n    targetSchema: string,\n    applyMasking: boolean\n  ): Promise<void> {\n    const tablesResult = await trx.query<{ tablename: string }>(\n      `\n      SELECT tablename FROM pg_tables\n      WHERE schemaname = $1 AND tablename NOT LIKE 'lp_%'\n    `,\n      [sourceSchema]\n    );\n\n    for (const { tablename } of tablesResult.rows) {\n      if (applyMasking) {\n        const columnsResult = await trx.query<{ column_name: string; data_type: string }>(\n          `\n          SELECT column_name, data_type\n          FROM information_schema.columns\n          WHERE table_schema = $1 AND table_name = $2\n          ORDER BY ordinal_position\n        `,\n          [sourceSchema, tablename]\n        );\n\n        const columnList = columnsResult.rows\n          .map((col) => this.quoteIdent(col.column_name))\n          .join(', ');\n        const selectList = columnsResult.rows\n          .map((col) => {\n            const isPii = this.isPiiColumn(col.column_name);\n            if ((isPii && col.data_type === 'character varying') || col.data_type === 'text') {\n              if (col.column_name.toLowerCase().includes('email')) {\n                return `CASE WHEN ${this.quoteIdent(col.column_name)} IS NOT NULL\n                THEN 'masked_' || substr(md5(${this.quoteIdent(col.column_name)}::text), 1, 8) || '@example.com'\n                ELSE NULL END AS ${this.quoteIdent(col.column_name)}`;\n              }\n              return `CASE WHEN ${this.quoteIdent(col.column_name)} IS NOT NULL\n              THEN 'masked_' || substr(md5(${this.quoteIdent(col.column_name)}::text), 1, 8)\n              ELSE NULL END AS ${this.quoteIdent(col.column_name)}`;\n            }\n            return this.quoteIdent(col.column_name);\n          })\n          .join(', ');\n\n        await trx.execute(`\n          INSERT INTO ${this.quoteIdent(targetSchema)}.${this.quoteIdent(tablename)} (${columnList})\n          SELECT ${selectList}\n          FROM ${this.quoteIdent(sourceSchema)}.${this.quoteIdent(tablename)}\n        `);\n      } else {\n        await trx.execute(`\n          INSERT INTO ${this.quoteIdent(targetSchema)}.${this.quoteIdent(tablename)}\n          SELECT * FROM ${this.quoteIdent(sourceSchema)}.${this.quoteIdent(tablename)}\n        `);\n      }\n    }\n  }\n\n  private isPiiColumn(columnName: string): boolean {\n    const piiPatterns = [\n      'email',\n      'phone',\n      'address',\n      'ssn',\n      'social_security',\n      'credit_card',\n      'password',\n      'secret',\n      'token',\n      'first_name',\n      'last_name',\n      'full_name',\n      'name',\n      'dob',\n      'date_of_birth',\n      'ip_address',\n      'ip',\n      'location',\n      'latitude',\n      'longitude',\n    ];\n\n    const lower = columnName.toLowerCase();\n    return piiPatterns.some((pattern) => lower.includes(pattern));\n  }\n\n  private async getTableCount(\n    client: Driver | TransactionClient,\n    schemaName: string\n  ): Promise<number> {\n    const result = await client.query<{ count: string }>(\n      `\n      SELECT COUNT(*)::text as count\n      FROM pg_tables\n      WHERE schemaname = $1 AND tablename NOT LIKE 'lp_%'\n    `,\n      [schemaName]\n    );\n\n    return Number.parseInt(result.rows[0]?.count ?? '0', 10);\n  }\n\n  private generateSlug(name: string): string {\n    return name\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, '_')\n      .replace(/^_|_$/g, '')\n      .substring(0, 100);\n  }\n\n  private quoteIdent(identifier: string): string {\n    return `\"${identifier.replace(/\"/g, '\"\"')}\"`;\n  }\n\n  private async resolveSchemaName(branchName: string): Promise<string> {\n    if (branchName === 'main' || branchName === 'public') {\n      return this.mainSchema;\n    }\n    const branch = await this.getBranchBySlug(branchName);\n    if (!branch) {\n      throw new Error(`Branch '${branchName}' not found`);\n    }\n    return branch.schemaName;\n  }\n\n  private generateConnectionString(branch: Branch): string {\n    const baseUrl = process.env.DATABASE_URL || '';\n    if (!baseUrl) {\n      return `options=-c search_path=${branch.schemaName},public`;\n    }\n    try {\n      const url = new URL(baseUrl);\n      url.searchParams.set('options', `-c search_path=${branch.schemaName},public`);\n      return url.toString();\n    } catch {\n      return `${baseUrl}?options=-c search_path=${branch.schemaName},public`;\n    }\n  }\n\n  private mapBranchRow(row: BranchRow): Branch {\n    return {\n      id: row.id,\n      name: row.name,\n      slug: row.slug,\n      schemaName: row.schema_name,\n      parentBranchId: row.parent_branch_id,\n      gitBranch: row.git_branch,\n      prNumber: row.pr_number,\n      prUrl: row.pr_url,\n      status: row.status as BranchStatus,\n      isProtected: row.is_protected,\n      createdAt: new Date(row.created_at),\n      createdBy: row.created_by,\n      lastAccessedAt: new Date(row.last_accessed_at),\n      deletedAt: row.deleted_at ? new Date(row.deleted_at) : null,\n      migrationCount: row.migration_count,\n      tableCount: row.table_count,\n      storageBytes:\n        typeof row.storage_bytes === 'string'\n          ? Number.parseInt(row.storage_bytes, 10)\n          : row.storage_bytes,\n      autoDeleteDays: row.auto_delete_days,\n      copyData: row.copy_data,\n      piiMasking: row.pii_masking,\n    };\n  }\n}\n\nexport function createBranchManager(options: BranchManagerOptions): BranchManager {\n  return new BranchManager(options);\n}\n","import type { Driver, TransactionClient } from '../driver/types.js';\n\nexport interface ConnectionManagerOptions {\n  driver: Driver;\n  mainSchema?: string;\n  branchPrefix?: string;\n}\n\nexport interface BranchConnection {\n  schemaName: string;\n  searchPath: string;\n  connectionString: string;\n}\n\nexport class ConnectionManager {\n  private driver: Driver;\n  private mainSchema: string;\n  private branchPrefix: string;\n  private currentSchema: string;\n\n  constructor(options: ConnectionManagerOptions) {\n    this.driver = options.driver;\n    this.mainSchema = options.mainSchema ?? 'public';\n    this.branchPrefix = options.branchPrefix ?? 'branch_';\n    this.currentSchema = this.mainSchema;\n  }\n\n  async switchToBranch(branchSlug: string): Promise<BranchConnection> {\n    const schemaName = await this.getSchemaForBranch(branchSlug);\n    const searchPath = `${schemaName}, public`;\n\n    await this.driver.execute(`SET search_path TO ${searchPath}`);\n\n    this.currentSchema = schemaName;\n\n    await this.updateLastAccessed(branchSlug);\n\n    return {\n      schemaName,\n      searchPath,\n      connectionString: this.generateConnectionString(schemaName),\n    };\n  }\n\n  async switchToMain(): Promise<BranchConnection> {\n    const searchPath = `${this.mainSchema}, public`;\n\n    await this.driver.execute(`SET search_path TO ${searchPath}`);\n\n    this.currentSchema = this.mainSchema;\n\n    return {\n      schemaName: this.mainSchema,\n      searchPath,\n      connectionString: this.generateConnectionString(this.mainSchema),\n    };\n  }\n\n  async withBranch<T>(\n    branchSlug: string,\n    callback: (client: TransactionClient) => Promise<T>\n  ): Promise<T> {\n    const schemaName = await this.getSchemaForBranch(branchSlug);\n    const searchPath = `${schemaName}, public`;\n\n    return await this.driver.transaction(async (trx) => {\n      await trx.execute(`SET LOCAL search_path TO ${searchPath}`);\n      return callback(trx);\n    });\n  }\n\n  async withSchema<T>(\n    schemaName: string,\n    callback: (client: TransactionClient) => Promise<T>\n  ): Promise<T> {\n    const searchPath = `${schemaName}, public`;\n\n    return await this.driver.transaction(async (trx) => {\n      await trx.execute(`SET LOCAL search_path TO ${searchPath}`);\n      return callback(trx);\n    });\n  }\n\n  getCurrentSchema(): string {\n    return this.currentSchema;\n  }\n\n  async getCurrentSearchPath(): Promise<string> {\n    const result = await this.driver.query<{ search_path: string }>('SHOW search_path');\n    return result.rows[0]?.search_path ?? this.mainSchema;\n  }\n\n  async validateSchema(schemaName: string): Promise<boolean> {\n    const result = await this.driver.query<{ exists: boolean }>(\n      `\n      SELECT EXISTS (\n        SELECT 1 FROM information_schema.schemata\n        WHERE schema_name = $1\n      ) as exists\n    `,\n      [schemaName]\n    );\n\n    return result.rows[0]?.exists ?? false;\n  }\n\n  async listAvailableSchemas(): Promise<string[]> {\n    const result = await this.driver.query<{ schema_name: string }>(\n      `\n      SELECT schema_name\n      FROM information_schema.schemata\n      WHERE schema_name LIKE $1 OR schema_name = $2\n      ORDER BY schema_name\n    `,\n      [`${this.branchPrefix}%`, this.mainSchema]\n    );\n\n    return result.rows.map((row) => row.schema_name);\n  }\n\n  generateConnectionString(schemaName: string): string {\n    const baseUrl = process.env.DATABASE_URL || '';\n    if (!baseUrl) {\n      return `options=-c search_path=${schemaName},public`;\n    }\n\n    try {\n      const url = new URL(baseUrl);\n      url.searchParams.set('options', `-c search_path=${schemaName},public`);\n      return url.toString();\n    } catch {\n      const separator = baseUrl.includes('?') ? '&' : '?';\n      return `${baseUrl}${separator}options=-c search_path=${schemaName},public`;\n    }\n  }\n\n  generateEnvVars(schemaName: string): Record<string, string> {\n    return {\n      DATABASE_URL: this.generateConnectionString(schemaName),\n      DB_SCHEMA: schemaName,\n      DB_SEARCH_PATH: `${schemaName}, public`,\n    };\n  }\n\n  private async getSchemaForBranch(branchSlug: string): Promise<string> {\n    if (branchSlug === 'main' || branchSlug === 'public') {\n      return this.mainSchema;\n    }\n\n    const result = await this.driver.query<{ schema_name: string }>(\n      `\n      SELECT schema_name FROM lp_branch_metadata\n      WHERE slug = $1 AND deleted_at IS NULL\n    `,\n      [branchSlug]\n    );\n\n    if (result.rows.length === 0) {\n      throw new Error(`Branch '${branchSlug}' not found`);\n    }\n\n    return result.rows[0].schema_name;\n  }\n\n  private async updateLastAccessed(branchSlug: string): Promise<void> {\n    await this.driver.execute(\n      `\n      UPDATE lp_branch_metadata\n      SET last_accessed_at = NOW()\n      WHERE slug = $1\n    `,\n      [branchSlug]\n    );\n  }\n}\n\nexport function createConnectionManager(options: ConnectionManagerOptions): ConnectionManager {\n  return new ConnectionManager(options);\n}\n","import type { Driver } from '../driver/types.js';\nimport type { Branch, BranchRow, CleanupResult } from './types.js';\n\nexport interface CleanupSchedulerOptions {\n  driver: Driver;\n  intervalMs?: number;\n  defaultMaxAgeDays?: number;\n  skipProtected?: boolean;\n  metadataTable?: string;\n  onCleanup?: (result: CleanupResult) => void;\n  onError?: (error: Error) => void;\n}\n\nexport interface CleanupJob {\n  id: string;\n  startedAt: Date;\n  completedAt?: Date;\n  result?: CleanupResult;\n  error?: string;\n}\n\nexport class CleanupScheduler {\n  private driver: Driver;\n  private intervalMs: number;\n  private defaultMaxAgeDays: number;\n  private skipProtected: boolean;\n  private metadataTable: string;\n  private onCleanup?: (result: CleanupResult) => void;\n  private onError?: (error: Error) => void;\n\n  private intervalId: ReturnType<typeof setInterval> | null = null;\n  private isRunning = false;\n  private lastRun: CleanupJob | null = null;\n  private history: CleanupJob[] = [];\n\n  constructor(options: CleanupSchedulerOptions) {\n    this.driver = options.driver;\n    this.intervalMs = options.intervalMs ?? 24 * 60 * 60 * 1000; // 24 hours\n    this.defaultMaxAgeDays = options.defaultMaxAgeDays ?? 7;\n    this.skipProtected = options.skipProtected ?? true;\n    this.metadataTable = options.metadataTable ?? 'lp_branch_metadata';\n    this.onCleanup = options.onCleanup;\n    this.onError = options.onError;\n  }\n\n  start(): void {\n    if (this.intervalId) {\n      return;\n    }\n\n    this.runCleanup().catch((error) => {\n      if (this.onError) {\n        this.onError(error instanceof Error ? error : new Error(String(error)));\n      }\n    });\n\n    this.intervalId = setInterval(() => {\n      this.runCleanup().catch((error) => {\n        if (this.onError) {\n          this.onError(error instanceof Error ? error : new Error(String(error)));\n        }\n      });\n    }, this.intervalMs);\n  }\n\n  stop(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n\n  isScheduled(): boolean {\n    return this.intervalId !== null;\n  }\n\n  isCurrentlyRunning(): boolean {\n    return this.isRunning;\n  }\n\n  getLastRun(): CleanupJob | null {\n    return this.lastRun;\n  }\n\n  getHistory(limit = 10): CleanupJob[] {\n    return this.history.slice(-limit);\n  }\n\n  async runCleanup(options?: {\n    maxAgeDays?: number;\n    dryRun?: boolean;\n  }): Promise<CleanupResult> {\n    if (this.isRunning) {\n      throw new Error('Cleanup is already running');\n    }\n\n    this.isRunning = true;\n    const job: CleanupJob = {\n      id: this.generateJobId(),\n      startedAt: new Date(),\n    };\n\n    try {\n      const result = await this.executeCleanup(options);\n      this.recordSuccess(job, result);\n      return result;\n    } catch (error) {\n      this.recordError(job, error);\n      throw error;\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  private async executeCleanup(options?: {\n    maxAgeDays?: number;\n    dryRun?: boolean;\n  }): Promise<CleanupResult> {\n    const maxAge = options?.maxAgeDays ?? this.defaultMaxAgeDays;\n    const staleBranches = await this.getStaleBranches(maxAge);\n    const deleted: string[] = [];\n    const skipped: string[] = [];\n\n    for (const branch of staleBranches) {\n      if (options?.dryRun) {\n        deleted.push(branch.slug);\n        continue;\n      }\n      await this.tryDeleteBranch(branch, deleted, skipped);\n    }\n\n    return { deleted, skipped };\n  }\n\n  private async tryDeleteBranch(\n    branch: Branch,\n    deleted: string[],\n    skipped: string[]\n  ): Promise<void> {\n    try {\n      await this.deleteBranch(branch);\n      deleted.push(branch.slug);\n    } catch (error) {\n      skipped.push(`${branch.slug}: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  private recordSuccess(job: CleanupJob, result: CleanupResult): void {\n    job.completedAt = new Date();\n    job.result = result;\n    this.lastRun = job;\n    this.history.push(job);\n\n    if (this.history.length > 100) {\n      this.history = this.history.slice(-100);\n    }\n\n    if (this.onCleanup) {\n      this.onCleanup(result);\n    }\n  }\n\n  private recordError(job: CleanupJob, error: unknown): void {\n    job.completedAt = new Date();\n    job.error = error instanceof Error ? error.message : String(error);\n    this.lastRun = job;\n    this.history.push(job);\n\n    if (this.onError) {\n      this.onError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  async getStaleBranches(maxAgeDays: number): Promise<Branch[]> {\n    let sql = `\n      SELECT * FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE deleted_at IS NULL\n        AND last_accessed_at < NOW() - INTERVAL '${maxAgeDays} days'\n        AND status != 'deleting'\n    `;\n\n    if (this.skipProtected) {\n      sql += ` AND is_protected = FALSE AND status != 'protected'`;\n    }\n\n    sql += ' ORDER BY last_accessed_at ASC';\n\n    const result = await this.driver.query<BranchRow>(sql);\n    return result.rows.map((row) => this.mapBranchRow(row));\n  }\n\n  async markAsStale(maxAgeDays: number): Promise<number> {\n    let sql = `\n      UPDATE ${this.quoteIdent(this.metadataTable)}\n      SET status = 'stale'\n      WHERE deleted_at IS NULL\n        AND last_accessed_at < NOW() - INTERVAL '${maxAgeDays} days'\n        AND status = 'active'\n    `;\n\n    if (this.skipProtected) {\n      sql += ' AND is_protected = FALSE';\n    }\n\n    const result = await this.driver.execute(sql);\n    return result.rowCount;\n  }\n\n  async getUpcomingCleanups(\n    daysAhead = 7\n  ): Promise<{ branch: Branch; daysUntilCleanup: number }[]> {\n    const sql = `\n      SELECT *,\n        EXTRACT(DAY FROM (last_accessed_at + (auto_delete_days * INTERVAL '1 day') - NOW())) as days_until_cleanup\n      FROM ${this.quoteIdent(this.metadataTable)}\n      WHERE deleted_at IS NULL\n        AND status != 'protected'\n        AND status != 'deleting'\n        AND is_protected = FALSE\n        AND last_accessed_at + (auto_delete_days * INTERVAL '1 day') < NOW() + INTERVAL '${daysAhead} days'\n      ORDER BY days_until_cleanup ASC\n    `;\n\n    const result = await this.driver.query<BranchRow & { days_until_cleanup: string }>(sql);\n\n    return result.rows.map((row) => ({\n      branch: this.mapBranchRow(row),\n      daysUntilCleanup: Number.parseFloat(row.days_until_cleanup),\n    }));\n  }\n\n  private async deleteBranch(branch: Branch): Promise<void> {\n    await this.driver.transaction(async (trx) => {\n      await trx.execute(\n        `\n        UPDATE ${this.quoteIdent(this.metadataTable)}\n        SET status = 'deleting', deleted_at = NOW()\n        WHERE id = $1\n      `,\n        [branch.id]\n      );\n\n      await trx.execute(`DROP SCHEMA IF EXISTS ${this.quoteIdent(branch.schemaName)} CASCADE`);\n\n      await trx.execute(\n        `\n        DELETE FROM ${this.quoteIdent(this.metadataTable)} WHERE id = $1\n      `,\n        [branch.id]\n      );\n    });\n  }\n\n  private generateJobId(): string {\n    return `cleanup_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n  }\n\n  private quoteIdent(identifier: string): string {\n    return `\"${identifier.replace(/\"/g, '\"\"')}\"`;\n  }\n\n  private mapBranchRow(row: BranchRow): Branch {\n    return {\n      id: row.id,\n      name: row.name,\n      slug: row.slug,\n      schemaName: row.schema_name,\n      parentBranchId: row.parent_branch_id,\n      gitBranch: row.git_branch,\n      prNumber: row.pr_number,\n      prUrl: row.pr_url,\n      status: row.status,\n      isProtected: row.is_protected,\n      createdAt: new Date(row.created_at),\n      createdBy: row.created_by,\n      lastAccessedAt: new Date(row.last_accessed_at),\n      deletedAt: row.deleted_at ? new Date(row.deleted_at) : null,\n      migrationCount: row.migration_count,\n      tableCount: row.table_count,\n      storageBytes:\n        typeof row.storage_bytes === 'string'\n          ? Number.parseInt(row.storage_bytes, 10)\n          : row.storage_bytes,\n      autoDeleteDays: row.auto_delete_days,\n      copyData: row.copy_data,\n      piiMasking: row.pii_masking,\n    };\n  }\n}\n\nexport function createCleanupScheduler(options: CleanupSchedulerOptions): CleanupScheduler {\n  return new CleanupScheduler(options);\n}\n"],"mappings":"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","names":["result","result","createMySQLDriver","createSQLiteDriver","createMongoDriver","join","DEFAULT_TENANT_COLUMNS","join","init_mysql","init_postgresql","init_sqlite","init_mongodb","init_mysql","init_postgresql","init_sqlite","init_mongodb","trimmed","createHash","compilerWithoutTenant","readFile","readdir","join","trimmed","result","fk","createHash","createHash","createHash","readFile","join","join","readFile","pascalCase","defaultLogger","readFile","readdir","join","trimmed","readdir","join","readFile","defaultLogger","createHash","createDriver","createDbClient"]}