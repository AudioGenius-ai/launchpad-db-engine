import type { SchemaDefinition } from './index.js';

export interface HooksGeneratorOptions {
  typesImportPath?: string;
  includeJsDoc?: boolean;
  primaryKeyColumn?: string;
}

function pascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function pluralize(word: string): string {
  if (word.endsWith('s') || word.endsWith('x') || word.endsWith('ch') || word.endsWith('sh')) {
    return `${word}es`;
  }
  if (word.endsWith('y') && !/[aeiou]y$/i.test(word)) {
    return `${word.slice(0, -1)}ies`;
  }
  if (word.endsWith('s')) {
    return word;
  }
  return `${word}s`;
}

function singularize(word: string): string {
  if (word.endsWith('ies') && word.length > 3) {
    return `${word.slice(0, -3)}y`;
  }
  if (
    word.endsWith('sses') ||
    word.endsWith('xes') ||
    word.endsWith('ches') ||
    word.endsWith('shes') ||
    word.endsWith('zes')
  ) {
    return word.slice(0, -2);
  }
  if (word.endsWith('ses') && word.length > 3) {
    return word.slice(0, -2);
  }
  if (word.endsWith('s') && !word.endsWith('ss') && word.length > 1) {
    return word.slice(0, -1);
  }
  return word;
}

export function generateHooks(
  schemas: Map<string, SchemaDefinition>,
  options: HooksGeneratorOptions = {}
): string {
  const { typesImportPath = './types', includeJsDoc = true, primaryKeyColumn = 'id' } = options;

  const lines: string[] = [
    '// Auto-generated by @launchpad/db-engine',
    '// Do not edit this file manually',
    '',
    "import { useQuery, useQuerySingle, useInsert, useUpdate, useDelete } from '@launchpad/db';",
    "import type { QueryOptions, MutationOptions } from '@launchpad/db';",
    '',
  ];

  const typeImports: string[] = [];
  for (const [schemaName, schema] of schemas) {
    const namespace = pascalCase(schemaName);
    for (const tableName of Object.keys(schema.tables)) {
      const typeName = pascalCase(tableName);
      typeImports.push(`${namespace}.${typeName}`);
      typeImports.push(`${namespace}.${typeName}Insert`);
      typeImports.push(`${namespace}.${typeName}Update`);
    }
  }

  lines.push(`import type { ${typeImports.join(', ')} } from '${typesImportPath}';`);
  lines.push('');

  for (const [schemaName, schema] of schemas) {
    const namespace = pascalCase(schemaName);

    for (const [tableName, table] of Object.entries(schema.tables)) {
      const typeName = pascalCase(tableName);
      const singularName = pascalCase(singularize(tableName));
      const pluralName = pascalCase(pluralize(singularize(tableName)));

      let pkColumn = primaryKeyColumn;
      let pkType = 'string';
      for (const [colName, col] of Object.entries(table.columns)) {
        if (col.primaryKey) {
          pkColumn = colName;
          if (col.type === 'integer' || col.type === 'bigint') {
            pkType = 'number';
          }
          break;
        }
      }

      if (includeJsDoc) {
        lines.push('/**');
        lines.push(` * Fetch all ${tableName} records with optional filtering`);
        lines.push(` * @table ${tableName}`);
        lines.push(' */');
      }
      lines.push(`export function use${pluralName}(`);
      lines.push(`  options?: Omit<QueryOptions<${namespace}.${typeName}>, 'table'>`);
      lines.push(') {');
      lines.push(
        `  return useQuery<${namespace}.${typeName}>({ ...options, table: '${tableName}' });`
      );
      lines.push('}');
      lines.push('');

      if (includeJsDoc) {
        lines.push('/**');
        lines.push(` * Fetch a single ${tableName} record by ${pkColumn}`);
        lines.push(` * @table ${tableName}`);
        lines.push(' */');
      }
      lines.push(`export function use${singularName}(`);
      lines.push(`  ${pkColumn}: ${pkType},`);
      lines.push(`  options?: Omit<QueryOptions<${namespace}.${typeName}>, 'table' | 'filter'>`);
      lines.push(') {');
      lines.push(`  return useQuerySingle<${namespace}.${typeName}>({`);
      lines.push('    ...options,');
      lines.push(`    table: '${tableName}',`);
      lines.push(`    filter: { column: '${pkColumn}', operator: 'eq', value: ${pkColumn} },`);
      lines.push('  });');
      lines.push('}');
      lines.push('');

      if (includeJsDoc) {
        lines.push('/**');
        lines.push(` * Insert a new ${tableName} record`);
        lines.push(` * @table ${tableName}`);
        lines.push(' */');
      }
      lines.push(`export function useInsert${singularName}(`);
      lines.push(
        `  options?: Omit<MutationOptions<${namespace}.${typeName}, { data: ${namespace}.${typeName}Insert }>, 'table'>`
      );
      lines.push(') {');
      lines.push(
        `  return useInsert<${namespace}.${typeName}>({ ...options, table: '${tableName}' });`
      );
      lines.push('}');
      lines.push('');

      if (includeJsDoc) {
        lines.push('/**');
        lines.push(` * Update an existing ${tableName} record`);
        lines.push(` * @table ${tableName}`);
        lines.push(' */');
      }
      lines.push(`export function useUpdate${singularName}(`);
      lines.push(
        `  options?: Omit<MutationOptions<${namespace}.${typeName}, { ${pkColumn}: ${pkType}; data: ${namespace}.${typeName}Update }>, 'table'>`
      );
      lines.push(') {');
      lines.push(
        `  return useUpdate<${namespace}.${typeName}>({ ...options, table: '${tableName}' });`
      );
      lines.push('}');
      lines.push('');

      if (includeJsDoc) {
        lines.push('/**');
        lines.push(` * Delete a ${tableName} record`);
        lines.push(` * @table ${tableName}`);
        lines.push(' */');
      }
      lines.push(`export function useDelete${singularName}(`);
      lines.push(
        `  options?: Omit<MutationOptions<${namespace}.${typeName}, { ${pkColumn}: ${pkType} }>, 'table'>`
      );
      lines.push(') {');
      lines.push(
        `  return useDelete<${namespace}.${typeName}>({ ...options, table: '${tableName}' });`
      );
      lines.push('}');
      lines.push('');
    }
  }

  return lines.join('\n');
}
