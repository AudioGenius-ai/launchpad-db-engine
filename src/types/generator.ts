import type { SchemaDefinition, ColumnType } from './index.js';

export interface TypeGeneratorOptions {
  includeInsertTypes?: boolean;
  includeUpdateTypes?: boolean;
  omitTenantColumns?: boolean;
}

function pascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function pgTypeToTs(type: ColumnType): string {
  const map: Record<ColumnType, string> = {
    uuid: 'string',
    string: 'string',
    text: 'string',
    integer: 'number',
    bigint: 'number',
    float: 'number',
    decimal: 'number',
    boolean: 'boolean',
    datetime: 'Date',
    date: 'Date',
    time: 'string',
    json: 'Record<string, unknown>',
    binary: 'Buffer',
  };
  return map[type] || 'unknown';
}

export function generateTypes(
  schemas: Map<string, SchemaDefinition>,
  options: TypeGeneratorOptions = {}
): string {
  const {
    includeInsertTypes = true,
    includeUpdateTypes = true,
    omitTenantColumns = true,
  } = options;

  const lines: string[] = [
    '// Auto-generated by @launchpad/db-engine',
    '// Do not edit this file manually',
    '',
  ];

  for (const [schemaName, schema] of schemas) {
    const namespace = pascalCase(schemaName);
    lines.push(`export namespace ${namespace} {`);

    for (const [tableName, table] of Object.entries(schema.tables)) {
      const typeName = pascalCase(tableName);

      lines.push(`  /** Row type for ${tableName} table */`);
      lines.push(`  export interface ${typeName} {`);

      for (const [colName, col] of Object.entries(table.columns)) {
        const tsType = pgTypeToTs(col.type);
        const nullable = col.nullable ? ' | null' : '';
        lines.push(`    ${colName}: ${tsType}${nullable};`);
      }

      lines.push(`  }`);
      lines.push('');

      if (includeInsertTypes) {
        lines.push(`  /** Insert type for ${tableName} table */`);
        lines.push(`  export interface ${typeName}Insert {`);

        for (const [colName, col] of Object.entries(table.columns)) {
          if (colName === 'id' && col.default) continue;
          if (colName === 'created_at' && col.default) continue;
          if (colName === 'updated_at' && col.default) continue;

          if (omitTenantColumns && col.tenant) continue;

          const tsType = pgTypeToTs(col.type);
          const optional = col.nullable || col.default ? '?' : '';
          lines.push(`    ${colName}${optional}: ${tsType};`);
        }

        lines.push(`  }`);
        lines.push('');
      }

      if (includeUpdateTypes) {
        lines.push(`  /** Update type for ${tableName} table */`);
        lines.push(`  export interface ${typeName}Update {`);

        for (const [colName, col] of Object.entries(table.columns)) {
          if (colName === 'id') continue;
          if (colName === 'created_at') continue;

          if (omitTenantColumns && col.tenant) continue;

          const tsType = pgTypeToTs(col.type);
          lines.push(`    ${colName}?: ${tsType} | null;`);
        }

        lines.push(`  }`);
        lines.push('');
      }
    }

    const tableNames = Object.keys(schema.tables).map(t => `'${t}'`).join(' | ');
    lines.push(`  export type TableName = ${tableNames};`);
    lines.push('');

    lines.push(`  export interface Tables {`);
    for (const tableName of Object.keys(schema.tables)) {
      const typeName = pascalCase(tableName);
      lines.push(`    ${tableName}: ${typeName};`);
    }
    lines.push(`  }`);

    lines.push(`}`);
    lines.push('');
  }

  lines.push('export type AllSchemas = {');
  for (const schemaName of schemas.keys()) {
    const namespace = pascalCase(schemaName);
    lines.push(`  ${schemaName}: typeof ${namespace};`);
  }
  lines.push('};');

  return lines.join('\n');
}

export function generateSchemaFromDefinition(schema: SchemaDefinition): string {
  const lines: string[] = [
    "import type { SchemaDefinition } from '@launchpad/db-engine';",
    '',
    'export const schema: SchemaDefinition = {',
    '  tables: {',
  ];

  for (const [tableName, table] of Object.entries(schema.tables)) {
    lines.push(`    ${tableName}: {`);
    lines.push('      columns: {');

    for (const [colName, col] of Object.entries(table.columns)) {
      const colDef: string[] = [];
      colDef.push(`type: '${col.type}'`);

      if (col.primaryKey) colDef.push('primaryKey: true');
      if (col.nullable) colDef.push('nullable: true');
      if (col.unique) colDef.push('unique: true');
      if (col.default) colDef.push(`default: '${col.default}'`);
      if (col.tenant) colDef.push('tenant: true');

      if (col.references) {
        colDef.push(`references: { table: '${col.references.table}', column: '${col.references.column}'${col.references.onDelete ? `, onDelete: '${col.references.onDelete}'` : ''} }`);
      }

      lines.push(`        ${colName}: { ${colDef.join(', ')} },`);
    }

    lines.push('      },');

    if (table.indexes?.length) {
      lines.push('      indexes: [');
      for (const index of table.indexes) {
        const indexDef: string[] = [];
        indexDef.push(`columns: [${index.columns.map(c => `'${c}'`).join(', ')}]`);
        if (index.name) indexDef.push(`name: '${index.name}'`);
        if (index.unique) indexDef.push('unique: true');
        if (index.where) indexDef.push(`where: '${index.where}'`);
        lines.push(`        { ${indexDef.join(', ')} },`);
      }
      lines.push('      ],');
    }

    lines.push('    },');
  }

  lines.push('  },');
  lines.push('};');

  return lines.join('\n');
}
