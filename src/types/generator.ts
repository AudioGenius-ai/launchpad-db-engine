import type { ColumnDefinition, ColumnType, SchemaDefinition } from './index.js';

export interface TypeGeneratorOptions {
  includeInsertTypes?: boolean;
  includeUpdateTypes?: boolean;
  includeZodSchemas?: boolean;
  omitTenantColumns?: boolean;
}

function pascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function camelCase(str: string): string {
  const pascal = pascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

function pgTypeToTs(type: ColumnType): string {
  const map: Record<ColumnType, string> = {
    uuid: 'string',
    string: 'string',
    text: 'string',
    integer: 'number',
    bigint: 'number',
    float: 'number',
    decimal: 'number',
    boolean: 'boolean',
    datetime: 'Date',
    date: 'Date',
    time: 'string',
    json: 'Record<string, unknown>',
    binary: 'Buffer',
  };
  return map[type] || 'unknown';
}

function pgTypeToZod(type: ColumnType): string {
  const map: Record<ColumnType, string> = {
    uuid: 'z.string().uuid()',
    string: 'z.string()',
    text: 'z.string()',
    integer: 'z.number().int()',
    bigint: 'z.number().int()',
    float: 'z.number()',
    decimal: 'z.number()',
    boolean: 'z.boolean()',
    datetime: 'z.coerce.date()',
    date: 'z.coerce.date()',
    time: 'z.string()',
    json: 'z.record(z.unknown())',
    binary: 'z.instanceof(Buffer)',
  };
  return map[type] || 'z.unknown()';
}

function isAutoGeneratedColumn(colName: string, col: ColumnDefinition): boolean {
  if (colName === 'id' && col.default) return true;
  if (colName === 'created_at' && col.default) return true;
  if (colName === 'updated_at' && col.default) return true;
  return false;
}

export function generateTypes(
  schemas: Map<string, SchemaDefinition>,
  options: TypeGeneratorOptions = {}
): string {
  const {
    includeInsertTypes = true,
    includeUpdateTypes = true,
    omitTenantColumns = true,
  } = options;

  const lines: string[] = [
    '// Auto-generated by @launchpad/db-engine',
    '// Do not edit this file manually',
    '',
  ];

  for (const [schemaName, schema] of schemas) {
    const namespace = pascalCase(schemaName);
    lines.push(`export namespace ${namespace} {`);

    for (const [tableName, table] of Object.entries(schema.tables)) {
      const typeName = pascalCase(tableName);

      lines.push(`  /** Row type for ${tableName} table */`);
      lines.push(`  export interface ${typeName} {`);

      for (const [colName, col] of Object.entries(table.columns)) {
        const tsType = pgTypeToTs(col.type);
        const nullable = col.nullable ? ' | null' : '';
        lines.push(`    ${colName}: ${tsType}${nullable};`);
      }

      lines.push('  }');
      lines.push('');

      if (includeInsertTypes) {
        lines.push(`  /** Insert type for ${tableName} table (omits auto-generated fields) */`);
        lines.push(`  export interface ${typeName}Insert {`);

        for (const [colName, col] of Object.entries(table.columns)) {
          if (isAutoGeneratedColumn(colName, col)) continue;
          if (omitTenantColumns && col.tenant) continue;

          const tsType = pgTypeToTs(col.type);
          const optional = col.nullable || col.default ? '?' : '';
          lines.push(`    ${colName}${optional}: ${tsType};`);
        }

        lines.push('  }');
        lines.push('');
      }

      if (includeUpdateTypes) {
        lines.push(`  /** Update type for ${tableName} table (all fields optional) */`);
        lines.push(`  export interface ${typeName}Update {`);

        for (const [colName, col] of Object.entries(table.columns)) {
          if (colName === 'id') continue;
          if (colName === 'created_at') continue;

          if (omitTenantColumns && col.tenant) continue;

          const tsType = pgTypeToTs(col.type);
          lines.push(`    ${colName}?: ${tsType} | null;`);
        }

        lines.push('  }');
        lines.push('');
      }
    }

    const tableNames = Object.keys(schema.tables)
      .map((t) => `'${t}'`)
      .join(' | ');
    lines.push(`  export type TableName = ${tableNames};`);
    lines.push('');

    lines.push('  export interface Tables {');
    for (const tableName of Object.keys(schema.tables)) {
      const typeName = pascalCase(tableName);
      lines.push(`    ${tableName}: ${typeName};`);
    }
    lines.push('  }');

    lines.push('}');
    lines.push('');
  }

  lines.push('export type AllSchemas = {');
  for (const schemaName of schemas.keys()) {
    const namespace = pascalCase(schemaName);
    lines.push(`  ${schemaName}: typeof ${namespace};`);
  }
  lines.push('};');

  return lines.join('\n');
}

export function generateZodSchemas(
  schemas: Map<string, SchemaDefinition>,
  options: TypeGeneratorOptions = {}
): string {
  const {
    includeInsertTypes = true,
    includeUpdateTypes = true,
    omitTenantColumns = true,
  } = options;

  const lines: string[] = [
    '// Auto-generated by @launchpad/db-engine',
    '// Do not edit this file manually',
    '',
    "import { z } from 'zod';",
    '',
  ];

  for (const [schemaName, schema] of schemas) {
    const schemaPrefix = camelCase(schemaName);
    lines.push(`// ==================== ${pascalCase(schemaName)} Schema ====================`);
    lines.push('');

    for (const [tableName, table] of Object.entries(schema.tables)) {
      const typeName = pascalCase(tableName);

      lines.push(`/** Zod schema for ${tableName} row */`);
      lines.push(`export const ${schemaPrefix}${typeName}Schema = z.object({`);

      for (const [colName, col] of Object.entries(table.columns)) {
        let zodType = pgTypeToZod(col.type);
        if (col.nullable) {
          zodType += '.nullable()';
        }
        lines.push(`  ${colName}: ${zodType},`);
      }

      lines.push('});');
      lines.push('');

      if (includeInsertTypes) {
        lines.push(`/** Zod schema for ${tableName} insert (omits auto-generated fields) */`);
        lines.push(`export const ${schemaPrefix}${typeName}InsertSchema = z.object({`);

        for (const [colName, col] of Object.entries(table.columns)) {
          if (isAutoGeneratedColumn(colName, col)) continue;
          if (omitTenantColumns && col.tenant) continue;

          let zodType = pgTypeToZod(col.type);
          if (col.nullable || col.default) {
            zodType += '.optional()';
          }
          lines.push(`  ${colName}: ${zodType},`);
        }

        lines.push('});');
        lines.push('');
      }

      if (includeUpdateTypes) {
        lines.push(`/** Zod schema for ${tableName} update (all fields optional) */`);
        lines.push(`export const ${schemaPrefix}${typeName}UpdateSchema = z.object({`);

        for (const [colName, col] of Object.entries(table.columns)) {
          if (colName === 'id') continue;
          if (colName === 'created_at') continue;

          if (omitTenantColumns && col.tenant) continue;

          let zodType = pgTypeToZod(col.type);
          zodType += '.nullable().optional()';
          lines.push(`  ${colName}: ${zodType},`);
        }

        lines.push('});');
        lines.push('');
      }

      lines.push('/** Inferred types from Zod schemas */');
      lines.push(`export type ${typeName} = z.infer<typeof ${schemaPrefix}${typeName}Schema>;`);
      if (includeInsertTypes) {
        lines.push(
          `export type ${typeName}Insert = z.infer<typeof ${schemaPrefix}${typeName}InsertSchema>;`
        );
      }
      if (includeUpdateTypes) {
        lines.push(
          `export type ${typeName}Update = z.infer<typeof ${schemaPrefix}${typeName}UpdateSchema>;`
        );
      }
      lines.push('');
    }
  }

  return lines.join('\n');
}

export function generateSchemaFromDefinition(schema: SchemaDefinition): string {
  const lines: string[] = [
    "import type { SchemaDefinition } from '@launchpad/db-engine';",
    '',
    'export const schema: SchemaDefinition = {',
    '  tables: {',
  ];

  for (const [tableName, table] of Object.entries(schema.tables)) {
    lines.push(`    ${tableName}: {`);
    lines.push('      columns: {');

    for (const [colName, col] of Object.entries(table.columns)) {
      const colDef: string[] = [];
      colDef.push(`type: '${col.type}'`);

      if (col.primaryKey) colDef.push('primaryKey: true');
      if (col.nullable) colDef.push('nullable: true');
      if (col.unique) colDef.push('unique: true');
      if (col.default) colDef.push(`default: '${col.default}'`);
      if (col.tenant) colDef.push('tenant: true');

      if (col.references) {
        colDef.push(
          `references: { table: '${col.references.table}', column: '${col.references.column}'${col.references.onDelete ? `, onDelete: '${col.references.onDelete}'` : ''} }`
        );
      }

      lines.push(`        ${colName}: { ${colDef.join(', ')} },`);
    }

    lines.push('      },');

    if (table.indexes?.length) {
      lines.push('      indexes: [');
      for (const index of table.indexes) {
        const indexDef: string[] = [];
        indexDef.push(`columns: [${index.columns.map((c) => `'${c}'`).join(', ')}]`);
        if (index.name) indexDef.push(`name: '${index.name}'`);
        if (index.unique) indexDef.push('unique: true');
        if (index.where) indexDef.push(`where: '${index.where}'`);
        lines.push(`        { ${indexDef.join(', ')} },`);
      }
      lines.push('      ],');
    }

    lines.push('    },');
  }

  lines.push('  },');
  lines.push('};');

  return lines.join('\n');
}
